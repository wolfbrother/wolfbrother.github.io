<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>跳绳减脂走起来！</title>
    <url>/2020/01/08/life/2020-01-08-%E8%B7%B3%E7%BB%B3%E5%87%8F%E8%84%82%E8%B5%B0%E8%B5%B7%E6%9D%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>工作后更要养成健身的习惯。</p>
<h3 id="一口气连续跳绳40分钟">一口气连续跳绳40分钟</h3>
<p>消耗的热量相当于减脂100g，连续这样跳5天则至少减掉1斤体重。</p>
<figure>
<img src="/images/20200108-一次连跳40分钟.jpg" alt="一次连跳40分钟"><figcaption>一次连跳40分钟</figcaption>
</figure>
<h3 id="连续跳20分钟无失误">连续跳20分钟无失误</h3>
<p>太难得了有没有？因为心理波动和肌体疲劳很容易导致跳绳失误。</p>
<figure>
<img src="/images/20200108-20分钟无失误.jpg" alt="20分钟无失误"><figcaption>20分钟无失误</figcaption>
</figure>
<h3 id="年11月份的跳绳总结">2019年11月份的跳绳总结</h3>
<p>各项参数的统计结果：</p>
<ul>
<li>累计用时1431分钟；</li>
<li>总数量20万4千多个；</li>
<li>消耗23421千卡，相当于6斤脂肪的热量。</li>
</ul>
<figure>
<img src="/images/20200108-11月跳绳总结.jpg" alt="11月跳绳总结"><figcaption>11月跳绳总结</figcaption>
</figure>
<h3 id="体重记录">体重记录</h3>
<p>不久前，持续两个月的锻炼和节食来减肥，如今恰好130斤体重。此后，一边增肌，一边减脂，保持体重130斤永不变。</p>
<figure>
<img src="/images/20200108-恰好130斤的体重.jpg" alt="恰好130斤的体重"><figcaption>恰好130斤的体重</figcaption>
</figure>
<h3 id="我养的缸子肉">我养的缸子肉</h3>
<p>最后贴上我养的多肉，其实是养在了一个小碟子里，然后把小碟子放在了一个小茶缸上面。 就叫它<em>缸子肉</em>吧。</p>
<figure>
<img src="/images/20200108-缸子肉.jpg" alt="缸子肉"><figcaption>缸子肉</figcaption>
</figure>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>运动健身</tag>
      </tags>
  </entry>
  <entry>
    <title>春日草木记</title>
    <url>/2020/03/20/life/2020-03-20-%E6%98%A5%E6%97%A5%E8%8D%89%E6%9C%A8%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今年天气特别暖和，三月下旬的之前几天，老家已经连续数天最高气温27摄氏度，已经有人开始对农田进行浇水。</p>
<h2 id="新栽花草">新栽花草</h2>
<p>网购了多种花草，有紫竹的根、常青藤苗、爬山虎、藤本蔷薇、凌霄花和佛肚竹。这些花草里面好几种都是耐阴耐旱的植物，主要栽种到了院子的四个角落，屋子两侧与院墙的夹缝，葡萄架与院墙的中间，厕所门口等。院墙外面的路边，也种了凌霄花。 <img src="/images/20200320-新栽花草之处.jpg" alt="新栽花草之处"></p>
<p>网购了两株金桂树，三年龄，当年开花，栽种到大门外两侧。金桂四季常绿，在北方的冬天显得很重要。</p>
<h2 id="果树护理">果树护理</h2>
<p>下图是3月20日的果林，最近处是樱桃，其次是桃树和杏树。 <img src="/images/20200320-3月20日的果林.jpg" alt="3月20日的果林"></p>
<p>一月下旬买了牛奶大青枣果树树苗，两株，栽在了院子里，至今未见发芽。还买了两株樱桃，嫁接好的，也栽在了院子南侧，未发芽。另有20株奶油草莓苗，栽在了院子东侧靠墙位置，本月初就开始开花结果了。 <img src="/images/20200320-草莓.jpg" alt="草莓"></p>
<p>院子里之前已经有数棵果树，分别是三棵桃树，一棵杏树，一株樱桃树，一株苹果树，和多株葡萄。樱桃树3月8日开始首先开花，有蜜蜂传粉。 <img src="/images/20200320-樱桃花.jpg" alt="樱桃花"> <img src="/images/20200320-樱桃花盛开.jpg" alt="樱桃花盛开"></p>
<p>其次是杏树开花， <img src="/images/20200320-杏花1.jpg" alt="杏花1"> <img src="/images/20200320-杏花2.jpg" alt="杏花2"> <img src="/images/20200320-杏花3.jpg" alt="杏花3"> 再然后是桃花，现在桃花正开。 <img src="/images/20200320-桃花1.jpg" alt="桃花1"> <img src="/images/20200320-桃花2.jpg" alt="桃花2"> <img src="/images/20200320-桃花盛开.jpg" alt="桃花盛开"> 苹果树开始发芽。 <img src="/images/20200320-苹果树.jpg" alt="苹果树"> 葡萄树至今未发芽。 <img src="/images/20200320-葡萄架.jpg" alt="葡萄架"></p>
<p>杏树、桃树和苹果树上面蚜虫很多，从含苞待放时花苞上就有很多蚜虫，然后现在幼芽上也满是。去镇上买了一瓶噻虫高氯氟，专治蚜虫的，用喷雾器连续喷了两天，效果不错。</p>
<h2 id="狗狗">狗狗</h2>
<p>一只纯种金毛，另一只个头和柴犬差不多的田园犬。 <img src="/images/20200320-冬天的狗狗.jpg" alt="冬天的狗狗"> <img src="/images/20200320-屋顶上的狗狗.jpg" alt="屋顶上的狗狗"> <img src="/images/20200320-洗澡吹干后的狗狗.jpg" alt="洗澡吹干后的狗狗"></p>
<p>春天宠物身上容易生跳蚤，冬天就在金毛身上发现了跳蚤。在一月初买了跳蚤药，并给两只狗狗使用，效果不错。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>花鸟虫鱼</tag>
      </tags>
  </entry>
  <entry>
    <title>我和她的重要节日之表白</title>
    <url>/2020/01/04/life/2020-01-04-%E6%88%91%E5%92%8C%E5%A5%B9%E7%9A%84%E9%87%8D%E8%A6%81%E8%8A%82%E6%97%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote class="blockquote-center"><p><font face="fantasy" color="FF00FF" size="15">阳历1月4日</font></p>
<figure>
<img src="/images/20200104-牵着她的手.jpg" alt="牵着她的手"><figcaption>牵着她的手</figcaption>
</figure>
<figure>
<img src="/images/20200104-蜡烛们.jpg" alt="蜡烛和花瓣们"><figcaption>蜡烛和花瓣们</figcaption>
</figure>
<figure>
<img src="/images/20200104-烛光合照.jpg" alt="烛光合照"><figcaption>烛光合照</figcaption>
</figure>
<figure>
<img src="/images/20200104-金针菇合照.jpg" alt="金针菇合照"><figcaption>金针菇合照</figcaption>
</figure>
</blockquote>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title>快排中的Partition函数</title>
    <url>/2019/09/30/algs/general/2019-09-30-%E5%BF%AB%E6%8E%92%E4%B8%AD%E7%9A%84Partition%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="快排算法与partition函数">快排算法与partition函数</h3>
<h4 id="快排算法的递归形式">快排算法的递归形式：</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(nums, l, r)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> l &gt;= r:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    k = partition(nums, l, r)</span><br><span class="line">    quicksort(nums, l, k - <span class="number">1</span>)</span><br><span class="line">    quicksort(nums, k + <span class="number">1</span>, r)</span><br></pre></td></tr></table></figure>
<h4 id="快排算法的非递归形式">快排算法的非递归形式</h4>
<ul>
<li>使用了栈</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(nums, l, r)</span>:</span></span><br><span class="line">    stack = [(l, r)]</span><br><span class="line">    <span class="keyword">while</span> len(stack) &gt; <span class="number">0</span>:</span><br><span class="line">        l, r = stack.pop(<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">if</span> l &gt;= r:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        ix = partition3(nums, l, r)</span><br><span class="line">        stack.append((ix+<span class="number">1</span>, r))</span><br><span class="line">        stack.append((l, ix<span class="number">-1</span>))</span><br></pre></td></tr></table></figure>
<h4 id="partition函数">partition函数</h4>
<p>其中partition函数输入参数是一个数组nums和两个位置索引<code>l</code>和<code>r</code>，输出为位置索引k。需要满足：</p>
<ul>
<li><span class="math inline">\(l\le k \le r\)</span></li>
<li><span class="math inline">\(nums[l..k-1]\le nums[k]\)</span> 且<span class="math inline">\(nums[k+1..r]\ge nums[k]\)</span></li>
</ul>
<p>而一般的partition函数的实现不仅能够满足上述两个条件，还会更严格，如把第二个条件中的其中一个等号去掉：</p>
<ul>
<li><span class="math inline">\(nums[l..k-1] &lt; nums[k]\)</span> 且<span class="math inline">\(nums[k+1..r]\ge nums[k]\)</span></li>
</ul>
<p>不但能够用来排序，还能做其它事情。</p>
<h3 id="partition函数实现">Partition函数实现：</h3>
<p>如下版本返回值k，均满足<span class="math inline">\(nums[l..k-1] &lt; nums[k]\)</span> 且<span class="math inline">\(nums[k+1..r]\ge nums[k]\)</span></p>
<h4 id="单向扫描">单向扫描</h4>
<ul>
<li><code>for</code>循环遍历基准元素左侧所有元素，里指针s所指元素及其左侧元素都是小于最右侧基准元素<code>nums[r]</code>。</li>
<li>出了<code>for</code>循环，s再前进一位，所指元素与基准元素对调，以确保最终的列表里其右侧元素均大于等于其所指元素。</li>
<li><code>for</code>循环里以指针<code>i</code>为核心，其向右遍历，如果小于基准元素，则替换以大于等于基准元素。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(nums, l, r)</span>:</span></span><br><span class="line">    s = l - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(l, r):</span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt; nums[r]:</span><br><span class="line">            s += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> s != i:</span><br><span class="line">                nums[s], nums[i] = nums[i], nums[s]</span><br><span class="line">    s += <span class="number">1</span></span><br><span class="line">    nums[s], nums[r] = nums[r], nums[s]</span><br><span class="line">    <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>
<h4 id="双向扫描">双向扫描</h4>
<ul>
<li>双重while循环出来，后有<code>i==j</code>且<code>nums[l..i-1]&lt;x</code>，<code>nums[i+1..r]&gt;=x</code>。
<ul>
<li>然后根据<code>nums[i]</code>与x的大小关系，分三种情况处理，并决定返回值： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> nums[i] &gt; x: </span><br><span class="line">    nums[i], nums[r] = x, nums[i]</span><br><span class="line"><span class="keyword">elif</span> nums[i] &lt; x: </span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> nums[i] &gt; x:</span><br><span class="line">        nums[i], nums[r] = x, nums[i]</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>返回值i必然大于等于l，小于等于r，quicksort根据其划分的子问题规模必然小于原问题。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition3</span><span class="params">(nums, l, r)</span>:</span></span><br><span class="line">    x = nums[r]</span><br><span class="line">    i, j = l, r<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; j: </span><br><span class="line">        <span class="keyword">while</span> nums[i] &lt; x <span class="keyword">and</span> i &lt; j: <span class="comment"># 循环终止时i满足nums[i]&gt;=x或者i==j</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> nums[j] &gt;= x <span class="keyword">and</span> i &lt; j: <span class="comment"># 循环终止时j满足nums[j]&lt;x或者i==j</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> j &gt; i: <span class="comment"># 说明必有nums[i]&gt;=x且nums[j]&lt;x，需要调换二者位置</span></span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> nums[i] &lt; x: </span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    nums[i], nums[r] = x, nums[i] </span><br><span class="line">    <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>
<h3 id="partition函数的应用">partition函数的应用</h3>
<h4 id="leetcode215.-数组中的第k个最大元素">LeetCode215. 数组中的第K个最大元素</h4>
<ul>
<li>第K大，就是第L-K+1个最小元素。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span> <span class="keyword">or</span> k &lt;= <span class="number">0</span> <span class="keyword">or</span> k &gt; len(nums):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        i, j = <span class="number">0</span>, len(nums)<span class="number">-1</span></span><br><span class="line">        k = len(nums) - k</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            ix = partition(nums, i, j)</span><br><span class="line">            <span class="keyword">if</span> ix == k:</span><br><span class="line">                <span class="keyword">return</span> nums[ix]</span><br><span class="line">            <span class="keyword">elif</span> ix &lt; k:</span><br><span class="line">                i = ix + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j = ix - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="剑指29-最小的k个数">剑指29-最小的K个数</h4>
<p>用快排的partition方法来找到第k大的数，那么该数以及其左侧k-1个数一起，就是最小的k个数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetLeastNumbers_Solution</span><span class="params">(self, tinput, k)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> tinput <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> len(tinput) &lt; k <span class="keyword">or</span> k &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        s, t = <span class="number">0</span>, len(tinput)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            ix = partition(tinput, s, t)</span><br><span class="line">            <span class="keyword">if</span> ix == k <span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">return</span> sorted(tinput[:k])</span><br><span class="line">            <span class="keyword">elif</span> ix &gt; k <span class="number">-1</span>:</span><br><span class="line">                t = ix <span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s = ix + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="剑指28-数组中出现次数超过一半的数字">剑指28-数组中出现次数超过一半的数字</h4>
<ul>
<li>快排的partition函数能够以某个数为基准，将数组内元素按大小分为小于该数和大于等于该数两部分。可以用来将数组分成前k个较小值和其余的值两部分，方法是迭代，将partition函数的输入区间向k和拢。</li>
<li>而出现次数超过一半的数，排序之后肯定会在下标<code>len(numbers)&gt;&gt;1</code>上出现，因此用partition函数找到该数，然后检查其是否满足条件即可。</li>
<li>每次迭代使得partition的输出更接近<code>len(numbers)&gt;&gt;1</code>这个下标，直到二者相等。如果有出现次数超过一半的数，则必然是该下标的元素。究竟是不是，也要检查一番才能确定。</li>
<li>注意：虽然partition的输出下标左侧的元素肯定要小于该下标所指的元素，但最终<code>len(numbers)&gt;&gt;1</code>这个下标左侧的元素却是小于等于该下标所指元素。只是由<code>while True</code>循环里对<code>s</code>和<code>t</code>的更新方式导致的。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(self, numbers)</span>:</span>  </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">checkMoreThanHalf</span><span class="params">(num, numbers)</span>:</span></span><br><span class="line">            half = (len(numbers)&gt;&gt;<span class="number">1</span>)+<span class="number">1</span> <span class="comment"># 一半加一</span></span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">                <span class="keyword">if</span> n == num:</span><br><span class="line">                    half -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> half &lt;= <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(numbers) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        s, t = <span class="number">0</span>, len(numbers)<span class="number">-1</span></span><br><span class="line">        mid = len(numbers)&gt;&gt;<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            ix = partition(numbers, s, t) </span><br><span class="line">            <span class="keyword">if</span> ix &gt; mid:</span><br><span class="line">                t = ix - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> ix &lt; mid: </span><br><span class="line">                s = ix + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        num = numbers[mid]</span><br><span class="line">        <span class="keyword">return</span> num <span class="keyword">if</span> checkMoreThanHalf(num, numbers) <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>partition</tag>
      </tags>
  </entry>
  <entry>
    <title>n位二进制中m个1的所有组合个数</title>
    <url>/2019/09/28/algs/general/2019-09-28-n%E4%BD%8D%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%ADm%E4%B8%AA1%E7%9A%84%E6%89%80%E6%9C%89%E7%BB%84%E5%90%88%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>用递归和动态规划：</p>
<p>将n个元素从左往右排好序。每次选择的m个元素的组合按如下步骤，</p>
<ul>
<li>先选第一个元素，有n-m+1种选择方案</li>
<li>第一个元素的位置确定后，其余待选择的m-1个元素从已选择元素的右边选择。这是个与原问题同构的子问题，可以用递归。</li>
<li>递归的终止条件有两个，一个是n==m也就是剩余元素数量和剩余位置数量相等，只有一种组合方法；一个是m==0也就是m个元素都已经排完了。</li>
<li>用一个全局的数据结构存储动态规划的子问题状态，避免重复计算。</li>
</ul>
<p>而根据第一个元素的位置生成的n-m+1个子问题是互斥且完备的，因此方法成立。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combination</span><span class="params">(n, m)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(n, m, states)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == m <span class="keyword">or</span> m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n-m+<span class="number">2</span>):</span><br><span class="line">                <span class="keyword">if</span> (n-i, m<span class="number">-1</span>) <span class="keyword">not</span> <span class="keyword">in</span>  states:</span><br><span class="line">                    num = recur(n-i, m<span class="number">-1</span>, states)</span><br><span class="line">                    states[(n-i, m<span class="number">-1</span>)] = num</span><br><span class="line">                    res += num</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res += states[(n-i, m<span class="number">-1</span>)]</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">    states = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span> <span class="keyword">and</span> n == <span class="number">0</span>) <span class="keyword">or</span> m &gt; n <span class="keyword">or</span> m &lt; <span class="number">0</span> <span class="keyword">or</span> n &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> recur(n,m, states)</span><br></pre></td></tr></table></figure>
<p>带入参数计算combination(1000, 500)得到一个很大的组合数数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2702882409454365695156146936259752754961520084465482870073928751066254287055</span><br><span class="line">2219389861248392450237016536260608502154610480220975005067991754989421969951</span><br><span class="line">8475423665484263751733356162464079737887344364574161119497604571044985756287</span><br><span class="line">880514600994219426752366915856603136862602484428109296905863799821216320</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>魔改hexo框架</title>
    <url>/2019/09/18/tools/2019-09-18-%E9%AD%94%E6%94%B9hexo%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="安装配置">安装配置</h3>
<p>下载本仓库，安装第三方包和环境，并在本机测试： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone -b hexo git@github.com:wolfbrother/wolfbrother.github.io.git</span><br><span class="line">npm install hexo --save</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">compile-push-deploy.bat</span><br><span class="line">compile-test.bat</span><br></pre></td></tr></table></figure></p>
<p>测试成功后部署到github pages： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile-push-deploy.bat</span><br></pre></td></tr></table></figure></p>
<p>清除历史commit记录并同步到远端仓库： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clean-history-hexo.bat</span><br></pre></td></tr></table></figure></p>
<p>从远端仓库同步到本地： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fetch-merge.bat</span><br></pre></td></tr></table></figure></p>
<p>提交本地仓库到远端： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add-commit-push.bat</span><br></pre></td></tr></table></figure></p>
<h3 id="列表顺序">列表顺序</h3>
<p>hexo平台有四中文章列表顺序的规则，分别对应about页面(也是最基本的排序方案)、category页面、archive页面和tag页面，分别由如下四处代码控制：</p>
<ul>
<li>文件<code>node_modules\hexo\lib\plugins\generator\post.js</code>
<ul>
<li>相关代码<code>const posts = locals.posts.sort('-date').toArray()</code></li>
</ul></li>
<li>文件<code>node_modules\hexo-generator-category\lib\generator.js</code>
<ul>
<li>相关代码<code>var posts = category.posts.sort(config.category_generator.order_by || '-date');</code></li>
</ul></li>
<li>文件<code>node_modules\hexo-generator-archive\lib\generator.js</code>
<ul>
<li>相关代码<code>var allPosts = locals.posts.sort(config.archive_generator.order_by || '-date');</code></li>
</ul></li>
<li>文件<code>node_modules\hexo-generator-tag\lib\generator.js</code>
<ul>
<li>相关代码<code>var posts = tag.posts.sort(config.tag_generator.order_by || '-date');</code></li>
</ul></li>
</ul>
<p>其中<code>post.js</code>文件的<code>-date</code>给替换成其它变量，不然会出错。而上面其它三个都是替换后的写法。其中的变量定义在根目录下的文件<code>_config.yml</code>，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index_generator:</span><br><span class="line">  path: &apos;&apos;</span><br><span class="line">  per_page: 10</span><br><span class="line">  order_by: -dtindex</span><br><span class="line">archive_generator:</span><br><span class="line">  per_page: 10</span><br><span class="line">  order_by: -dtindex </span><br><span class="line">category_generator:</span><br><span class="line">  per_page: 10</span><br><span class="line">  order_by: -dtindex </span><br><span class="line">tag_generator:</span><br><span class="line">  order_by: -dtindex</span><br></pre></td></tr></table></figure>
<p>上面的<code>-date</code>就是每篇文章的头部的<code>date</code>，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dtindex: 2018-07-27鸿鹄0000</span><br><span class="line">title: 鸿鹄</span><br><span class="line">categories: 风骚</span><br><span class="line">tags: Essay</span><br><span class="line">author: wolfbrother</span><br><span class="line">date: 2018-07-27</span><br></pre></td></tr></table></figure>
<p>其中的dtindex是我自己添加的，把date和title连接起来截取前面部分。相对于用date排序，dtindex可以在给date相同的多篇文章排序时考虑title部分。添加的Python脚本如下，放到文章所在目录，运行即可。可以重复运行。：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line">xmls = glob.glob(<span class="string">'*.md'</span>)</span><br><span class="line"><span class="keyword">for</span> one_xml <span class="keyword">in</span> xmls:</span><br><span class="line">    f = open(one_xml, <span class="string">'r+'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">    all_the_lines = f.readlines()</span><br><span class="line">    <span class="comment">#print(all_the_lines)</span></span><br><span class="line">    i, j = <span class="number">-1</span>, <span class="number">-1</span></span><br><span class="line">    date, title = <span class="string">''</span>, <span class="string">''</span></span><br><span class="line">    ret_len = <span class="number">6</span></span><br><span class="line">    is_done = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> row, line <span class="keyword">in</span> enumerate(all_the_lines):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'dtindex'</span> <span class="keyword">in</span> line:</span><br><span class="line">            is_done = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        lstrip = line.strip()</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'---'</span> <span class="keyword">in</span> lstrip:</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span>:</span><br><span class="line">                i = row </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j = row</span><br><span class="line">        <span class="keyword">if</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">'date'</span> <span class="keyword">in</span> lstrip:</span><br><span class="line">                date = lstrip.split(<span class="string">':'</span>)[<span class="number">1</span>].strip()</span><br><span class="line">            <span class="keyword">if</span> <span class="string">'title'</span> <span class="keyword">in</span> lstrip:</span><br><span class="line">                title = lstrip.split(<span class="string">':'</span>)[<span class="number">1</span>].strip()</span><br><span class="line">                <span class="keyword">if</span> len(title) &gt; ret_len:</span><br><span class="line">                    title = title[:ret_len]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    title += <span class="string">'0'</span>*ret_len</span><br><span class="line">                    title = title[:ret_len]</span><br><span class="line">        <span class="keyword">if</span> j &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    f.close()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> is_done:</span><br><span class="line">        all_the_lines.insert(i+<span class="number">1</span>, <span class="string">'dtindex: '</span>+ date+title+<span class="string">'\n'</span>)</span><br><span class="line">        print(i,j, date+title)</span><br><span class="line">        f = open(one_xml, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">        f.write(<span class="string">''</span>.join(all_the_lines))</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure>
<h3 id="tex语法冲突">TeX语法冲突</h3>
<p>由于markdown和TeX语法的冲突，hexo在渲染TeX公式方面有不足。config文件里有选项是否开启mathjax，但是渲染效果并不是那么好。比如说会出现公式内的下划线无法识别，而识别为markdown的斜体。</p>
<p>更换Hexo的markdown引擎。,就是把hexo默认的渲染markdown的引擎换掉。 hexo-renderer-pandoc, 很强大的解析器，先卸载hexo默认的markd,再安装新的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-pandoc --save</span><br></pre></td></tr></table></figure>
<p>这些第三方安装包的下载安装的位置是根目录的node_modules文件夹下。而配置记录可以在根目录的package.json找到，这样根据package.json可以重新构建编译环境。</p>
<h3 id="隐藏首页的某些文章">隐藏首页的某些文章</h3>
<p>安装包hexo-generator-index2自带过滤功能，可以根据tag或category来过滤掉首页的某些文章。比如过滤掉tag为hexo的文章，则在<code>_config.yml</code>中配置如下： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index2_include_index: true</span><br><span class="line">index2_generator:</span><br><span class="line">  per_page: 8</span><br><span class="line">  order_by: -dtindex # 按发布时间排序</span><br><span class="line">  exclude:</span><br><span class="line">    - tag  hexo # 不包含标签为hide的文章</span><br><span class="line">    - category hexo # 不包含分类为hide的文章</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，将order_by属性设置为-dtindex，也达到了首页文章按时间和标题排序的目的。</p>
<h3 id="文章结尾处的标签仓库链接">文章结尾处的标签、仓库链接</h3>
<p>位置<code>themes/next/layout/_macro/post.swig</code>，代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> post.tags and post.tags.length and not is_index %&#125;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"post-tags"</span>&gt;</span><br><span class="line">    &#123;% <span class="keyword">for</span> tag <span class="keyword">in</span> post.tags %&#125;</span><br><span class="line">      &lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" rel="tag"&gt;#&#123;&#123;tag.name &#125;&#125;&lt;/a&gt;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">    &lt;a href="https://github.com/wolfbrother/wolfbrother.github.io/blob/hexo/source/&#123;&#123;post.source&#125;&#125;" rel="tag" target="_blank"&gt;&amp;#64gitrepo&lt;/a&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&#123;% endif %&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&#123;% if not post.tags or not post.tags.length or is_index %&#125;</span></span><br><span class="line"><span class="regexp">  &lt;div class="post-tags"&gt; </span></span><br><span class="line"><span class="regexp">     &lt;a href="https:/</span><span class="regexp">/github.com/</span>wolfbrother/wolfbrother.github.io/blob/hexo/source/&#123;&#123;post.source&#125;&#125;<span class="string">" rel="</span>tag<span class="string">" target="</span>_blank<span class="string">"&gt;&amp;#64gitrepo&lt;/a&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">&#123;% endif %&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="在hexo-generator-index2的基础上添加文章置顶和解除主页过滤">在hexo-generator-index2的基础上添加文章置顶和解除主页过滤</h3>
<p>hexo-generator-index2自带过滤功能，能够按tag或category类别将文章从主页过滤，然而却不支持置顶和解除类别内特定文章的选项。</p>
<p>一方面，在文件<code>hexo-generator-index2/lib/generator2.js</code>的行<code>var posts = locals.posts.sort(generator.order_by);</code>下面添加如下代码来支持文章的top这个属性，也就是在已经按<code>generator.order_by</code>的文章的基础上，再按top属性排序：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">posts.data = posts.data.sort(<span class="function"><span class="keyword">function</span>(<span class="params">first, second</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (first.top &amp;&amp; second.top) &#123; <span class="comment">// 两篇文章top都有定义</span></span><br><span class="line">		<span class="keyword">if</span> (first.top != second.top) &#123;</span><br><span class="line">			<span class="keyword">return</span> second.top - first.top;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> ((!first.dtindex)||(!second.dtindex)) &#123;</span><br><span class="line">			<span class="keyword">return</span> second.date - first.date;					</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (second.dtindex &gt; first.dtindex) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (first.top &amp;&amp; !second.top) &#123; <span class="comment">// 以下是只有一篇文章top有定义，将有top的排在前面</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!first.top &amp;&amp; second.top) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> ((!first.dtindex)||(!second.dtindex)) &#123;</span><br><span class="line">			<span class="keyword">return</span> second.date - first.date;					</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (second.dtindex &gt; first.dtindex) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>接下来，是按tag或category类别判断每篇文章是否从主页过滤的代码，在里面添加如下代码,即当属性post.not_exclude或者post.top为真时，不把改文章过滤掉：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (post.not_exclude || post.top) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一篇文章在被过滤掉的category里，要将其置顶，其源文件顶格内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">dtindex: 2019-01-01更新中000</span><br><span class="line">date: 2019-01-01</span><br><span class="line">title: 更新中...</span><br><span class="line">categories: 工具箱</span><br><span class="line">tags:  </span><br><span class="line">author: wolfbrother  </span><br><span class="line">top: true</span><br><span class="line">not_exclude: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具箱</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指67-剪绳子</title>
    <url>/2019/09/13/algs/arrow4Offer/2019-09-13-67-%E5%89%AA%E7%BB%B3%E5%AD%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>给你一根长度为n的绳子，请把绳子剪成m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为<code>k[0],k[1],...,k[m]</code>。请问<code>k[0]*k[1]*...*k[m]</code>可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入描述:</span><br><span class="line">&gt; 输入一个数n，意义见题面。（2 &lt;= n &lt;= 60）</span><br><span class="line">输出描述:</span><br><span class="line">&gt; 输出答案。</span><br><span class="line"></span><br><span class="line">示例1</span><br><span class="line">输入 &gt; 8</span><br><span class="line">输出 &gt; 18</span><br></pre></td></tr></table></figure>
<hr>
<p>动态规划，递归。用函数cut(number)剪长度为number的绳子，由于m、n都是正整数，第一次调用cut和其后的调用有区别</p>
<ul>
<li>第一次调用必须非要把绳子至少一分为二为两个短绳子，对短绳子再次调用该cut函数，则可能会继续剪也可能不再继续剪。比如2第一次调用，必须要拆分成1和1；然而3的第二次调用也有的这个2，但是可以拆也可以不拆。 所以，cut函数内部要根据其是否是首次调用，分为两种情况处理。</li>
<li>由于number必然是整数，因此动态规划程序里可以用一个数组来保存子问题的结果。具体的，用长度为<code>number+1</code>的数组<code>cutlog</code>来记录非首次调用cut函数的返回值，cut(number)返回值用<code>cutlog[number]</code>来表示。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cutRope</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        self.cutlog = [<span class="number">0</span>]*(number+<span class="number">1</span>) <span class="comment">#记录非首次cut函数调用的返回值</span></span><br><span class="line">        self.cutlog[<span class="number">0</span>] = self.cutlog[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">cut</span><span class="params">(number, isDoor = False)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> isDoor:</span><br><span class="line">                res = []</span><br><span class="line">                <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">1</span>, number+<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> self.cutlog[number-n] == <span class="number">0</span>:</span><br><span class="line">                        self.cutlog[number-n] = cut(number-n)</span><br><span class="line">                    res.append(n*self.cutlog[number-n])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> number &lt;= <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">                res = []</span><br><span class="line">                <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">1</span>, number):</span><br><span class="line">                    <span class="keyword">if</span> self.cutlog[number-n] == <span class="number">0</span>:</span><br><span class="line">                        self.cutlog[number-n] = cut(number-n)</span><br><span class="line">                    res.append(n*self.cutlog[number-n])</span><br><span class="line">            <span class="keyword">return</span> max(res)</span><br><span class="line">        <span class="keyword">return</span> cut(number, isDoor=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指66-机器人的运动范围</title>
    <url>/2019/09/13/algs/arrow4Offer/2019-09-13-66-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
<hr>
<ul>
<li>用一个长度为<code>m*n</code>的列表来存储同样数量的方格是否访问，可以一一对应。访问效率和字典一样，应该比字典开销低一些，简单一些。</li>
<li>用一个全局变量记录已经访问的方格的数量。</li>
<li>用一个全局变量列表来记录每个方格是否已经被访问过。</li>
<li>边界检测要在被调用的子函数find里做。如果在movingCount里做，需要为四个调用分别做边界检测，麻烦且容易出错。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, r, c)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> r &lt; <span class="number">0</span> <span class="keyword">or</span> c &lt; <span class="number">0</span> <span class="keyword">or</span> r &gt;= self.rows <span class="keyword">or</span> c &gt;= self.cols <span class="keyword">or</span> self.logs[r*self.cols+c]:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            self.logs[r*self.cols+c] = <span class="literal">True</span></span><br><span class="line">        <span class="comment">#if sum(map(int, str(r)+str(c))) &lt;= self.threshold:</span></span><br><span class="line">        <span class="keyword">if</span> sum([int(s) <span class="keyword">for</span> s <span class="keyword">in</span> str(r)+str(c)]) &lt;= self.threshold:</span><br><span class="line">            self.count += <span class="number">1</span> </span><br><span class="line">            <span class="comment"># 如果格子(r,c)符合条件，则查询其四周的格子</span></span><br><span class="line">            self.find(r<span class="number">-1</span>, c)</span><br><span class="line">            self.find(r+<span class="number">1</span>, c)</span><br><span class="line">            self.find(r, c<span class="number">-1</span>)</span><br><span class="line">            self.find(r, c+<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span><span class="params">(self, threshold, rows, cols)</span>:</span></span><br><span class="line">        self.rows = rows</span><br><span class="line">        self.cols = cols</span><br><span class="line">        self.threshold = threshold</span><br><span class="line">        self.logs = [<span class="literal">False</span>]*(self.rows*self.cols) <span class="comment"># 记载已经找到的格子</span></span><br><span class="line">        self.count = <span class="number">0</span> <span class="comment"># 已经找到的可以到达的格子数量</span></span><br><span class="line">        </span><br><span class="line">        self.find(<span class="number">0</span>, <span class="number">0</span>) <span class="comment"># 从(0,0)位置开始找</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.count</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li>递归函数直接递归计算能够访问的节点数。思路与<code>剑指offer38-二叉树的深度</code>类似。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, r, c)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> r &lt; <span class="number">0</span> <span class="keyword">or</span> c &lt; <span class="number">0</span> <span class="keyword">or</span> r &gt;= self.rows <span class="keyword">or</span> c &gt;= self.cols <span class="keyword">or</span> self.logs[r*self.cols+c]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            self.logs[r*self.cols+c] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> sum(map(int, str(r)+str(c))) &lt;= self.threshold:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span> + self.find(r<span class="number">-1</span>,c) + self.find(r+<span class="number">1</span>,c) + self.find(r,c<span class="number">-1</span>) + self.find(r,c+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span><span class="params">(self, threshold, rows, cols)</span>:</span></span><br><span class="line">        self.rows = rows</span><br><span class="line">        self.cols = cols</span><br><span class="line">        self.threshold = threshold</span><br><span class="line">        self.logs = [<span class="literal">False</span>]*(self.rows*self.cols) <span class="comment"># 记载已经找到的格子</span></span><br><span class="line">        <span class="keyword">return</span> self.find(<span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指65-矩阵中的路径</title>
    <url>/2019/09/13/algs/arrow4Offer/2019-09-13-65-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串&quot;bcced&quot;的路径，但是矩阵中不包含&quot;abcb&quot;路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p>
<hr>
<ul>
<li>深度优先搜索，递归。与八皇后类似。差别在于搜索的起点可能在所有位置，可以向上下左右四个方向去搜索。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPath</span><span class="params">(self, matrix, rows, cols, path)</span>:</span></span><br><span class="line">        <span class="comment"># 一旦找到一个解，则设置isgot为True</span></span><br><span class="line">        <span class="comment"># 四个输入参数，各分支共享</span></span><br><span class="line">        self.matrix = matrix </span><br><span class="line">        self.rows = rows <span class="comment"># 矩阵matrix的行数</span></span><br><span class="line">        self.cols = cols <span class="comment"># 矩阵matrix的列数</span></span><br><span class="line">        self.path = path <span class="comment"># 要找的path</span></span><br><span class="line">        self.sol = [] <span class="comment"># 各分支共用的已经找到的解</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 检查输入是否符合条件，不然直接返回False作未找到解来处理</span></span><br><span class="line">        <span class="keyword">if</span> len(self.path) == <span class="number">0</span> <span class="keyword">or</span> len(self.matrix) == <span class="number">0</span> <span class="keyword">or</span> len(self.matrix) != self.rows*self.cols:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 启动查找</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(self.cols):</span><br><span class="line">                    <span class="keyword">if</span> self.find(i, j, <span class="number">1</span>):</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, i, j, k)</span>:</span> <span class="comment"># </span></span><br><span class="line">        <span class="comment"># self.sol里前k-1个位置属于当前分支找到的解，</span></span><br><span class="line">        <span class="comment"># 现在检测(i,j)可否作为当前分支解的第k个位置</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= self.rows <span class="keyword">or</span> j &gt;= self.cols <span class="keyword">or</span> (i, j) <span class="keyword">in</span> self.sol[:k]:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> self.matrix[i*self.cols+j] != self.path[k<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 将新找到的位置添加进self.sol</span></span><br><span class="line">        <span class="keyword">if</span> len(self.sol) &gt;= k:</span><br><span class="line">            self.sol[k<span class="number">-1</span>] = (i,j)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.sol.append((i, j))</span><br><span class="line">        <span class="keyword">if</span> k == len(self.path): <span class="comment"># 找到一个完整的解</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.find(i, j+<span class="number">1</span>, k+<span class="number">1</span>) <span class="keyword">or</span> self.find(i, j<span class="number">-1</span>, k+<span class="number">1</span>) <span class="keyword">or</span> self.find(i+<span class="number">1</span>, j, k+<span class="number">1</span>) <span class="keyword">or</span> self.find(i<span class="number">-1</span>, j, k+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指64-滑动窗口的最大值</title>
    <url>/2019/09/13/algs/arrow4Offer/2019-09-13-64-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p>
<hr>
<p>暴力求解法。可以扫描每一个滑动窗口的所有数字并找出其中的最大值。如果滑动窗口的大小为k，需要O(k)时间才能找出滑动窗口里的最大值。对于长度为n的输入数组，这个算法总的时间复杂度是O(nk)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxInWindows</span><span class="params">(self, num, size)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(num) == <span class="number">0</span> <span class="keyword">or</span> size &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [] <span class="comment"># 注意是返回空的列表，而非None或者0</span></span><br><span class="line">        res = [] <span class="comment"># 注意当len(num) &lt; size时，返回的是空列表，而不装载有是num的最小值的列表</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(num) - size + <span class="number">1</span>):</span><br><span class="line">            res.append(max(num[i:i+size]))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>存在如下低效之处：</p>
<ul>
<li>窗口里的元素不是都必要，比如<code>[6,2,1,4,5]</code>里的<code>2,1,4</code>在之后的滑动过程中不可能是窗口的最大值，就可以在加入元素<code>5</code>时删掉变成<code>[6,5]</code>。经过这么已处理，滑动窗口的最大值必然在窗口的最左端。</li>
<li>可以用一个队列作为存储窗口。</li>
</ul>
<hr>
<ul>
<li>用一个队列存储窗口。由于需要窗口元素和数组的位置对应，所以队列里存储窗口元素的下标，而不是元素的值。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxInWindows</span><span class="params">(self, nums, size)</span>:</span></span><br><span class="line">        <span class="comment"># 注意当len(num) &lt; size时，返回的是空列表，而不装载有是num的最小值的列表</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt; size <span class="keyword">or</span> size &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stackWin = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                stackWin.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> stackWin[::<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">if</span> nums[j] &lt; nums[i]:</span><br><span class="line">                        stackWin.pop(<span class="number">-1</span>)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                stackWin.append(i)</span><br><span class="line">        maxValues = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(size, len(nums)):</span><br><span class="line">            maxValues.append(nums[stackWin[<span class="number">0</span>]]) <span class="comment"># 窗口的第一个必然是最大</span></span><br><span class="line">            <span class="keyword">if</span> i - stackWin[<span class="number">0</span>] == size: <span class="comment"># 滑出窗口的条件</span></span><br><span class="line">                stackWin.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> stackWin[::<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">if</span> nums[j] &lt;= nums[i]:</span><br><span class="line">                    stackWin.pop(<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            stackWin.append(i)</span><br><span class="line">        maxValues.append(nums[stackWin[<span class="number">0</span>]])</span><br><span class="line">        <span class="keyword">return</span> maxValues</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指63-数据流中的中位数</title>
    <url>/2019/09/13/algs/arrow4Offer/2019-09-13-63-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p>
<hr>
<ul>
<li>Insert()方法维护一个排序列表，每读出一个数，用二分查找来找到其位置并插入队列。
<ul>
<li>每次迭代 mid = (i+j)//2， 根据mid位置的元素与要插入的num的大小关系，更新i或者j。更新确保不破坏循环条件i&lt;=j，还要[i,j]闭区间缩小，以确保不会有死循环。</li>
</ul></li>
<li>GetMedian()方法在上述排序列表上获取中位数。</li>
<li>运算符优先级： <code>幂运算</code>，<code>正负号</code>， <code>算数运算符（— = * /）</code>， <code>比较运算符（&lt; &gt; &lt;= &gt;=）</code>， <code>逻辑运算符（not and or）</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.array = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Insert</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        i , j = <span class="number">0</span>, len(self.array)<span class="number">-1</span></span><br><span class="line">        <span class="comment"># 使用了二分查找来插入元素</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; j:</span><br><span class="line">            self.array.insert(<span class="number">0</span>, num)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">            <span class="keyword">if</span> i == j:</span><br><span class="line">                <span class="keyword">if</span> self.array[i] &gt; num:</span><br><span class="line">                    self.array.insert(i, num)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.array.insert(i+<span class="number">1</span>, num)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            mid = (i+j)&gt;&gt;<span class="number">1</span> <span class="comment"># 整除</span></span><br><span class="line">            <span class="keyword">if</span> self.array[mid] &lt; num: <span class="comment"># 三种情况对i和j的处理都不会破坏循环条件 i&lt;=j</span></span><br><span class="line">                <span class="keyword">if</span> i == mid: <span class="comment"># 确保i和j在每次迭代中范围都会缩小</span></span><br><span class="line">                    i = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    i = mid</span><br><span class="line">            <span class="keyword">elif</span> self.array[mid] &gt; num: <span class="comment"># 确保i不会大于j</span></span><br><span class="line">                j = mid   </span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 这种情况，直接插入肯定是没问题的</span></span><br><span class="line">                self.array.insert(mid, num)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 注意本题的bug：data是一个没有用的参数，但是必须用，不然会出错 </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetMedian</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        mylen = len(self.array)</span><br><span class="line">        <span class="keyword">if</span> mylen&amp;<span class="number">1</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> self.array[mylen&gt;&gt;<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (self.array[(mylen&gt;&gt;<span class="number">1</span>) - <span class="number">1</span>] + self.array[mylen//<span class="number">2</span>])/<span class="number">2.0</span> <span class="comment"># 除数必须是小数，不然2.7版本会把它结果转换成整数</span></span><br></pre></td></tr></table></figure>
<hr>
<p>考虑如下思路：</p>
<ul>
<li>维护两个数据结构Less和Largue，每次收到一个数字：
<ul>
<li>如果该数字是第奇数个，要与Large里的最小数比较，如果较小则直接加入Less；否则取出Large里最小数添加进Less，然后把该数添加进Large。</li>
<li>如果该数字是第偶数个，要与Less里的最大数比较，如果较大则直接加入Large；否则取出Less里的最大数添加进Large，然后把该数添加进Less。</li>
</ul></li>
<li>获取中位数时：
<ul>
<li>如果一共有奇数个数，则返回Less的最大值。</li>
<li>如果一共有偶数个数，则返回Less最大值和Large最小值的平均数。</li>
</ul></li>
</ul>
<p>堆（heap），它是一种优先队列，能够以任意顺序添加对象，并随时找出（并删除）最小的元素（最小堆）。相比于列表方法min，这样做的效率要高得多。Python没有独立的堆类型，而只有一个包含一些堆操作函数的模块，名为heapq。将元素全部取负，用堆来处理，实际上就是用最小堆实现了最大堆。</p>
<ul>
<li>上面的Less是个最大堆，而Large是个最小堆。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq <span class="keyword">as</span> hq</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.less = [] <span class="comment"># 充当最大堆，存储较小数</span></span><br><span class="line">        self.large = [] <span class="comment"># 最小堆，存储较大数</span></span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Insert</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.count&amp;<span class="number">1</span> == <span class="number">1</span>: <span class="comment"># 目标是往最大堆里Less添加元素</span></span><br><span class="line">            min_large_list = hq.nsmallest(<span class="number">1</span>, self.large) </span><br><span class="line">            <span class="keyword">if</span> len(min_large_list) == <span class="number">0</span> <span class="keyword">or</span> num &lt;= min_large_list[<span class="number">0</span>]:</span><br><span class="line">                hq.heappush(self.less, -num)</span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># num比最小堆的最小数还要大</span></span><br><span class="line">                min_large = hq.heappop(self.large)</span><br><span class="line">                hq.heappush(self.less, -min_large)</span><br><span class="line">                hq.heappush(self.large, num)</span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 目标是往最小堆Large里添加元素</span></span><br><span class="line">            max_less = -hq.nsmallest(<span class="number">1</span>, self.less)[<span class="number">0</span>] <span class="comment"># 最大堆的最大值,肯定存在</span></span><br><span class="line">            <span class="keyword">if</span> num &gt;= max_less:</span><br><span class="line">                hq.heappush(self.large, num)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hq.heappush(self.large, -hq.heappop(self.less))</span><br><span class="line">                hq.heappush(self.less, -num)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 注意本题的bug：data是一个没有用的参数，但是必须用，不然会出错 </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetMedian</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> self.count == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> self.count&amp;<span class="number">1</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -hq.nsmallest(<span class="number">1</span>, self.less)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (-hq.nsmallest(<span class="number">1</span>, self.less)[<span class="number">0</span>]+hq.nsmallest(<span class="number">1</span>, self.large)[<span class="number">0</span>])/<span class="number">2.0</span></span><br></pre></td></tr></table></figure>
<hr>
<p>假如忽略掉题设中<code>数据流</code>这个场景，一开始就能拿到所有数据，则可以用partition函数法，</p>
<ul>
<li>如果数组长度是奇数，则找到下标为<code>len(nums)&gt;&gt;1</code>的元素将其作为返回值。</li>
<li>如果数组长度是偶数，先找到下标为<code>len(nums)&gt;&gt;1</code>的元素，然后再找到左子序列的最大值，返回二者平均数。</li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>partition</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指62-二叉搜索树的第k个结点</title>
    <url>/2019/09/13/algs/arrow4Offer/2019-09-13-62-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为4。</p>
<p>输入的是根节点，要求返回节点。</p>
<hr>
<ul>
<li>中序遍历二叉搜索树，输出序列是非递减序列。如下代码用了递归中序遍历，递归函数是返回的节点或者None。</li>
<li>用pt来记录得到结果要再访问的节点数，每访问一个节点，值减去1。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回对应节点TreeNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">KthNode</span><span class="params">(self, pRoot, k)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(root, pt)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                res_l = recur(root.left, pt)</span><br><span class="line">                <span class="keyword">if</span> res_l:</span><br><span class="line">                    <span class="keyword">return</span> res_l</span><br><span class="line">            <span class="keyword">if</span> pt[<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">            pt[<span class="number">0</span>] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> root.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                res_r = recur(root.right, pt)</span><br><span class="line">                <span class="keyword">if</span> res_r:</span><br><span class="line">                    <span class="keyword">return</span> res_r</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            </span><br><span class="line">        pt = [k]</span><br><span class="line">        <span class="keyword">if</span> pRoot <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> k &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> recur(pRoot, pt)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指61-序列化二叉树</title>
    <url>/2019/09/13/algs/arrow4Offer/2019-09-13-61-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>请实现两个函数，分别用来序列化和反序列化二叉树</p>
<p>二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。</p>
<p>二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</p>
<hr>
<ul>
<li>序列化和反序列化都用递归比较简单。特别是反序列化，能够免去回溯节点。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Serialize</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">'$,'</span></span><br><span class="line">            <span class="keyword">return</span> str(root.val) + <span class="string">','</span> + recur(root.left) + recur(root.right)</span><br><span class="line">        <span class="keyword">return</span> recur(root)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Deserialize</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># 递归的方法可以免去回溯操作</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(ss, pt)</span>:</span></span><br><span class="line">            c = ss[pt[<span class="number">0</span>]] </span><br><span class="line">            pt[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">'$'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = TreeNode(int(c))</span><br><span class="line">                node.left = recur(ss, pt)</span><br><span class="line">                node.right = recur(ss, pt)</span><br><span class="line">                <span class="keyword">return</span> node</span><br><span class="line">        ss = s.split(<span class="string">','</span>)[:<span class="number">-1</span>] <span class="comment"># 因为序列化之后最后一个字符是`,`，split函数分割的结果的最后一个是空字符串</span></span><br><span class="line">        pt = [<span class="number">0</span>] <span class="comment"># 用来记录扫描ss的指针</span></span><br><span class="line">        <span class="keyword">return</span> recur(ss, pt)</span><br></pre></td></tr></table></figure>
<hr>
<p>如下是非递归版本，序列化和反序列化都是用的非递归。</p>
<ul>
<li>反序列化里花费很大功夫去确定下一个字符属于哪个节点的哪个孩子。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Serialize</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        s = <span class="string">''</span></span><br><span class="line">        mystack = []</span><br><span class="line">        mystack.append(root)</span><br><span class="line">        <span class="keyword">while</span> len(mystack) &gt; <span class="number">0</span>:</span><br><span class="line">            node = mystack.pop(<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                s += <span class="string">'$,'</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            s += str(node.val) + <span class="string">','</span></span><br><span class="line">            mystack.append(node.right)</span><br><span class="line">            mystack.append(node.left)</span><br><span class="line">        <span class="keyword">return</span> s </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Deserialize</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        s = s.split(<span class="string">','</span>)[:<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">'$'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        mylist = [] <span class="comment"># 添加节点，或者None，与s里已经遍历的字符数相等</span></span><br><span class="line">        mylist.append(TreeNode(int(s[<span class="number">0</span>]))) </span><br><span class="line">        ix = <span class="number">0</span> </span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> s[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">if</span> ix == len(mylist) - <span class="number">1</span>: <span class="comment"># 说明左子树没有被遍历过</span></span><br><span class="line">                <span class="keyword">if</span> char == <span class="string">'$'</span>: <span class="comment">#ix不增</span></span><br><span class="line">                    mylist[ix].left = <span class="string">'$'</span></span><br><span class="line">                    mylist.append(<span class="string">'$'</span>)</span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># ix加1</span></span><br><span class="line">                    mylist[ix].left = TreeNode(int(char))</span><br><span class="line">                    mylist.append(mylist[ix].left)</span><br><span class="line">                    ix += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 左子树被遍历过，现在遍历右子树</span></span><br><span class="line">                <span class="keyword">if</span> char == <span class="string">'$'</span>:</span><br><span class="line">                    mylist[ix].right = <span class="string">'$'</span></span><br><span class="line">                    mylist.append(<span class="string">'$'</span>)        </span><br><span class="line">                    <span class="keyword">while</span> ix &gt;= <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> (mylist[ix] != <span class="string">'$'</span> <span class="keyword">and</span> mylist[ix].right <span class="keyword">is</span> <span class="literal">None</span>):</span><br><span class="line">                        ix -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    mylist[ix].right = TreeNode(int(char))</span><br><span class="line">                    mylist.append(mylist[ix].right)</span><br><span class="line">                    ix = len(mylist) - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 把设置的标志$都替换成None</span></span><br><span class="line">        <span class="comment"># 因为节点初始化的时候，其左右子树都是None，但最终的树里其左右子树不一定是None</span></span><br><span class="line">        <span class="comment"># 为了区分开来，就将已经确定是None的，用标志$来记录</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> mylist: </span><br><span class="line">            <span class="keyword">if</span> node != <span class="string">'$'</span> <span class="keyword">and</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> node.left == <span class="string">'$'</span>:</span><br><span class="line">                    node.left = <span class="literal">None</span></span><br><span class="line">                <span class="keyword">if</span> node.right == <span class="string">'$'</span>:</span><br><span class="line">                    node.right = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> mylist[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指60-把二叉树打印成多行</title>
    <url>/2019/09/13/algs/arrow4Offer/2019-09-13-60-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
<hr>
<ul>
<li>用队列存储节点，每层末尾做一个标志，这里以符号'n'来表示。</li>
<li>访问末尾节点之后，必然产生新的末尾标志。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回二维列表[[1,2],[4,5]]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> pRoot <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># 用队列存储节点，每层末尾做一个标志，这里以符号'n'来表示。</span></span><br><span class="line">        <span class="comment"># 访问末尾节点之后，必然产生新的末尾标志。</span></span><br><span class="line">        myqueue = [pRoot, <span class="string">'n'</span>]</span><br><span class="line">        mylist = []</span><br><span class="line">        s_layer = []</span><br><span class="line">        <span class="keyword">while</span> len(myqueue) != <span class="number">0</span>:</span><br><span class="line">            node = myqueue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> node != <span class="string">'n'</span>:</span><br><span class="line">                s_layer.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    myqueue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    myqueue.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> len(myqueue) != <span class="number">0</span> <span class="keyword">and</span> myqueue[<span class="number">0</span>] == <span class="string">'n'</span>:</span><br><span class="line">                mylist.append(s_layer[::])</span><br><span class="line">                s_layer = []</span><br><span class="line">                myqueue.pop(<span class="number">0</span>)</span><br><span class="line">                myqueue.append(<span class="string">'n'</span>)</span><br><span class="line">        <span class="keyword">return</span> mylist</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指59-按之字形顺序打印二叉树</title>
    <url>/2019/09/13/algs/arrow4Offer/2019-09-13-59-%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
<ul>
<li>用队列nodeQ来临时存储节点，进而访问其子节点。</li>
<li>队列里两层之间有个要有个标记<code>|</code>，层的奇偶性也要有一个标记issOdd。
<ul>
<li>访问到该标记时，在队列末尾添加该标记。</li>
</ul></li>
<li>要有个缓存nodeLayer来存放同一层访问到的节点值，该层结束时根据奇偶标记来选择输出顺序。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">levelrootSnake</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="comment"># 用队列存储节点，每层末尾做一个标志，这里以符号'n'来表示。</span></span><br><span class="line">    <span class="comment"># 访问末尾节点之后，必然产生新的末尾标志。</span></span><br><span class="line">    isOdd = <span class="literal">True</span></span><br><span class="line">    myqueue = [root, <span class="string">'n'</span>]</span><br><span class="line">    mylist, nodes_layer = [], []</span><br><span class="line">    <span class="keyword">while</span> len(myqueue) != <span class="number">0</span>:</span><br><span class="line">        node = myqueue.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> node != <span class="string">'n'</span>:</span><br><span class="line">            nodes_layer.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                myqueue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                myqueue.append(node.right)</span><br><span class="line">        <span class="keyword">if</span> len(myqueue) != <span class="number">0</span> <span class="keyword">and</span> myqueue[<span class="number">0</span>] == <span class="string">'n'</span>:</span><br><span class="line">            <span class="keyword">if</span> isOdd == <span class="literal">True</span>:</span><br><span class="line">                mylist.append(nodes_layer[::])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                mylist.append(nodes_layer[::<span class="number">-1</span>])</span><br><span class="line">            isOdd = <span class="keyword">not</span> isOdd</span><br><span class="line">            nodes_layer = []</span><br><span class="line">            myqueue.pop(<span class="number">0</span>)</span><br><span class="line">            myqueue.append(<span class="string">'n'</span>)</span><br><span class="line">    <span class="keyword">return</span> mylist</span><br></pre></td></tr></table></figure>
<hr>
<p>相对于前一个代码用一个数据结构来存储各层的节点，需要两个辅助数据：</p>
<ul>
<li>对层数是奇、偶，做标记。</li>
<li>两层的分割点，要做标记</li>
</ul>
<p>想到用两个数据结构来分别存储奇数、偶数层的节点，每个循环内依次对两个数据结构进行处理，不必追踪层数和层间隔。</p>
<ul>
<li>注意这两个数据结构可以用队列，也可以用栈，其实区别不大。比如前面的代码用数组，后面的代码用栈。</li>
<li>如下代码用的是栈，注意第一个栈先压入左节点，第二个栈先压入右节点。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回二维列表[[1,2],[4,5]]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        st1, st2 = [root], []</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> len(st1) &gt; <span class="number">0</span>:</span><br><span class="line">            temp = []</span><br><span class="line">            <span class="keyword">while</span> len(st1) &gt; <span class="number">0</span>:</span><br><span class="line">                node = st1.pop(<span class="number">-1</span>)</span><br><span class="line">                temp.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    st2.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    st2.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> len(temp) &gt; <span class="number">0</span>:</span><br><span class="line">                res.append(temp[::])</span><br><span class="line">            temp = []</span><br><span class="line">            <span class="keyword">while</span> len(st2) &gt; <span class="number">0</span>:</span><br><span class="line">                node = st2.pop(<span class="number">-1</span>)</span><br><span class="line">                temp.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    st1.append(node.right)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    st1.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> len(temp) &gt; <span class="number">0</span>:</span><br><span class="line">                res.append(temp[::])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指58-对称的二叉树</title>
    <url>/2019/09/13/algs/arrow4Offer/2019-09-13-58-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
<hr>
<ul>
<li>递归</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetrical</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">is_same</span><span class="params">(p1,p2)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> p1 <span class="keyword">and</span> <span class="keyword">not</span> p2:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> p1 <span class="keyword">and</span> p2 <span class="keyword">and</span> p1.val==p2.val:</span><br><span class="line">                <span class="keyword">return</span> is_same(p1.left, p2.right) <span class="keyword">and</span> is_same(p1.right, p2.left)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> <span class="keyword">not</span> pRoot <span class="keyword">else</span> is_same(pRoot.left,pRoot.right)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指57-二叉树的下一个结点</title>
    <url>/2019/09/13/algs/arrow4Offer/2019-09-13-57-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
<hr>
<p>画出一个二叉树的图来帮助分析，分两种情况：</p>
<ul>
<li>pNode有右子树，下一个节点肯定在右子树上。具体来说，在其右子树上一直迭代找到最后一个左孩子。</li>
<li>pNode无右子树，下一个节点得往回查。具体来说，查到某个父节点是祖节点的左孩子。如果这个祖节点存在，那么它就是下一个节点。如果不存在，pNode就是二叉树的中序遍历的最后一个节点。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNext</span><span class="params">(self, pNode)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> pNode.right: <span class="comment"># pNode有右子树，下一个节点肯定在右子树上</span></span><br><span class="line">            pNode = pNode.right</span><br><span class="line">            <span class="keyword">while</span> pNode.left:</span><br><span class="line">                pNode = pNode.left</span><br><span class="line">            <span class="keyword">return</span> pNode</span><br><span class="line">        <span class="comment"># 无右子树，下一个节点得往回查</span></span><br><span class="line">        <span class="comment"># pNode是父节点的左孩子，则下一个节点是其父节点</span></span><br><span class="line">        <span class="comment"># pNode是父节点的右孩子，就麻烦了。先往回查，直到某个父节点是祖节点的左孩子</span></span><br><span class="line">        <span class="keyword">while</span> pNode.next <span class="keyword">and</span> pNode != pNode.next.left:</span><br><span class="line">            pNode = pNode.next</span><br><span class="line">        <span class="keyword">return</span> pNode.next</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指56-删除链表中重复的结点</title>
    <url>/2019/09/13/algs/arrow4Offer/2019-09-13-56-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
<hr>
<ul>
<li>表头比较难处理，为了方便，新建了一个节点作为表头。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplication</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># 确定pHead不是重复节点</span></span><br><span class="line">        node = ListNode(<span class="number">20190915</span>)</span><br><span class="line">        node.next = pHead</span><br><span class="line">        p1 = p2 = node</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">while</span> p1:</span><br><span class="line">            p2 = p1.next</span><br><span class="line">            <span class="keyword">while</span> p2 <span class="keyword">and</span> p2.next <span class="keyword">and</span> p1.next.val == p2.next.val:</span><br><span class="line">                p2 = p2.next</span><br><span class="line">            <span class="keyword">if</span> p2 == p1.next:</span><br><span class="line">                p1 = p2 = p1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p1.next = p2.next</span><br><span class="line">                p2 = p1</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> node.next</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指55-链表中环的入口结点</title>
    <url>/2019/09/13/algs/arrow4Offer/2019-09-13-55-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p>
<hr>
<ul>
<li>从链头到链尾遍历链表并对访问一个节点做记录，每访问一个节点，还要检查其否是被访问过。第一个重复访问的节点，必然是环的入口节点。</li>
<li>需要O(n)的空间复杂度。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">EntryNodeOfLoop</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        idSet = set()</span><br><span class="line">        <span class="keyword">while</span> pHead:</span><br><span class="line">            <span class="keyword">if</span> id(pHead) <span class="keyword">in</span> idSet:</span><br><span class="line">                <span class="keyword">return</span> pHead</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                idSet.add(id(pHead))</span><br><span class="line">                pHead = pHead.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li>一快一慢两个指针遍历链表必然会相遇，相遇节点必在环上。</li>
<li>由环上一节点开始，循环一周，可得环上节点数。</li>
<li>两个指向链表头的指针，其中一个先移动步数位环上节点数，然后二者以相同的速度移动，首次相遇必在入口节点。
<ul>
<li>设环上节点数<code>n</code>，一共有节点数<code>L</code>，则不在环上的节点有<code>L-n</code>个。设相遇时第二个节点移动了<code>x</code>步，则第一个指针一共移动了<code>n+x</code>步。当<code>x=L-n</code>时，有第一个节点刚好遍历完所有节点，当前指向环的入口节点；而第二个节点也指向同样的节点，也就是说二者会相遇。</li>
</ul></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">EntryNodeOfLoop</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> pHead <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 通过两指针相遇找环上节点</span></span><br><span class="line">        p1, p2 = pHead, pHead.next</span><br><span class="line">        <span class="keyword">while</span> p1 != p2:</span><br><span class="line">            <span class="keyword">if</span> p1.next <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> p2.next <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> p2.next.next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            p1 = p1.next</span><br><span class="line">            p2 = p2.next.next</span><br><span class="line">        <span class="comment"># 获得环上节点数   </span></span><br><span class="line">        p2 = p2.next</span><br><span class="line">        nloop = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p1 != p2:</span><br><span class="line">            nloop += <span class="number">1</span></span><br><span class="line">            p2 = p2.next</span><br><span class="line">        <span class="comment"># 找到入口节点</span></span><br><span class="line">        p1, p2 = pHead, pHead</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(nloop):</span><br><span class="line">            p2 = p2.next</span><br><span class="line">        <span class="keyword">while</span> p1 != p2:</span><br><span class="line">            p1 = p1.next</span><br><span class="line">            p2 = p2.next</span><br><span class="line">        <span class="keyword">return</span> p1</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指54-字符流中第一个不重复的字符</title>
    <url>/2019/09/13/algs/arrow4Offer/2019-09-13-54-%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符&quot;go&quot;时，第一个只出现一次的字符是&quot;g&quot;。当从该字符流中读出前六个字符“google&quot;时，第一个只出现一次的字符是&quot;l&quot;。</p>
<p>输出描述:</p>
<blockquote>
<p>如果当前字符流没有存在出现一次的字符，返回#字符。</p>
</blockquote>
<hr>
<ul>
<li>注：FirstAppearingOnce和Insert都是预定义的函数。</li>
<li>O(1)的时间插入一个字符。</li>
</ul>
<p>如下代码用字典来插入字符。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.mydict = &#123;&#125;</span><br><span class="line">        self.string = <span class="string">''</span></span><br><span class="line">    <span class="comment"># 返回对应char</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FirstAppearingOnce</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.string)):</span><br><span class="line">            <span class="keyword">if</span> self.mydict[self.string[i]] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> self.string[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'#'</span> </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Insert</span><span class="params">(self, char)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.string += char</span><br><span class="line">        <span class="keyword">if</span> char <span class="keyword">in</span> self.mydict:</span><br><span class="line">            self.mydict[char] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.mydict[char] = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<hr>
<p>如下代码用数组记录字符，数组的位置用它的ascii码序号： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.mylist = [<span class="number">0</span>]*<span class="number">2</span>**<span class="number">8</span></span><br><span class="line">        self.string = <span class="string">''</span></span><br><span class="line">    <span class="comment"># 返回对应char</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FirstAppearingOnce</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.string)):</span><br><span class="line">            <span class="keyword">if</span> self.mylist[ord(self.string[i])] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> self.string[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'#'</span> </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Insert</span><span class="params">(self, char)</span>:</span></span><br><span class="line">        self.string += char</span><br><span class="line">        self.mylist[ord(char)] += <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指53-表示数值的字符串</title>
    <url>/2019/09/13/algs/arrow4Offer/2019-09-13-53-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串&quot;+100&quot;,&quot;5e2&quot;,&quot;-123&quot;,&quot;3.1416&quot;和&quot;-1E-16&quot;都表示数值。 但是&quot;12e&quot;,&quot;1a3.14&quot;,&quot;1.2.3&quot;,&quot;+-5&quot;和&quot;12e+4.3&quot;都不是。</p>
<hr>
<h3 id="模式匹配">模式匹配</h3>
<p>Python语言关于字符串是否是数值的判断（<code>float(str)</code>），有如下规则：</p>
<ul>
<li>e和E大小写不敏感，e后面必须是任意整数，e前面必须有个任意整数或浮点数。如e2非法，1e2.6非法。</li>
<li>整型数的第一个数字位，如果不是各位，不能为0。如03非法，0合法。然而012e01合法，</li>
<li>.1合法</li>
</ul>
<p>然后查看官方教程，觉得要求不像python的float方法那么完善。具体的，</p>
<ul>
<li>没有这一条要求：整型数的第一个数字位，如果不是个位，不能为0。如03非法，0合法。然而012e01合法，</li>
<li>没有考虑字符串中有空格的情形</li>
</ul>
<p>这就简单很多了。表示数值的字符串遵循如下模式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[sign]integeral-digits[.[fractional-digits]][eE[sign]exponential-digits]</span><br></pre></td></tr></table></figure>
<p>那么，一路按上述模式进行匹配就行了。不在分析线上的，或者在分析线上就有问题的，就是不符合标准的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumeric</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        lens = len(s)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> lens == <span class="number">0</span>: <span class="comment">#空字符串直接返回False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        idx = <span class="number">0</span> <span class="comment"># 首位是符号位</span></span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>] <span class="keyword">in</span> <span class="string">'+-'</span>:</span><br><span class="line">            <span class="keyword">if</span> lens == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span> idx &lt; lens: <span class="comment"># 往下走到遇到小数点或者E</span></span><br><span class="line">            <span class="keyword">if</span> s[idx] <span class="keyword">in</span> <span class="string">'0123456789'</span>:</span><br><span class="line">                idx += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span>          </span><br><span class="line">        <span class="keyword">if</span> idx == lens:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> s[idx] == <span class="string">'.'</span>: <span class="comment"># 小数点及之后，知道遇到E</span></span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> idx &lt; lens:</span><br><span class="line">                <span class="keyword">if</span> s[idx] <span class="keyword">in</span> <span class="string">'0123456789'</span>:</span><br><span class="line">                    idx += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> idx == lens:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">if</span> s[idx] <span class="keyword">in</span> <span class="string">'eE'</span>: <span class="comment"># 检查E</span></span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> idx &lt; lens:</span><br><span class="line">                <span class="keyword">if</span> s[idx] <span class="keyword">in</span> <span class="string">'+-'</span>:</span><br><span class="line">                    idx += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> idx == lens:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">while</span> idx &lt; lens:</span><br><span class="line">                <span class="keyword">if</span> s[idx] <span class="keyword">in</span> <span class="string">'0123456789'</span>:</span><br><span class="line">                    idx += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> idx == lens:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span> <span class="comment"># 不在上述分析线上的，返回False</span></span><br></pre></td></tr></table></figure>
<h3 id="有限状态机">有限状态机</h3>
<p>有七个状态：</p>
<ul>
<li>state_0: 开始。</li>
<li>state_1: 已有正负号。</li>
<li>state_2: 已有数字。</li>
<li>state_3：已有小数点。</li>
<li>state_4：已有e</li>
<li>state_5：已有e和正负号</li>
<li>state_6: 已有e和[正负号]和数字</li>
</ul>
<p>可以得到状态切换矩阵：</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>正负号</th>
<th>数字</th>
<th>小数点</th>
<th>E</th>
<th>结束</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>state_0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>F</td>
<td>F</td>
</tr>
<tr class="even">
<td>state_1</td>
<td>F</td>
<td>2</td>
<td>3</td>
<td>F</td>
<td>F</td>
</tr>
<tr class="odd">
<td>state_2</td>
<td>F</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>T</td>
</tr>
<tr class="even">
<td>state_3</td>
<td>F</td>
<td>3</td>
<td>F</td>
<td>4</td>
<td>T</td>
</tr>
<tr class="odd">
<td>state_4</td>
<td>5</td>
<td>6</td>
<td>F</td>
<td>F</td>
<td>F</td>
</tr>
<tr class="even">
<td>state_5</td>
<td>F</td>
<td>6</td>
<td>F</td>
<td>F</td>
<td>F</td>
</tr>
<tr class="odd">
<td>state_6</td>
<td>F</td>
<td>6</td>
<td>F</td>
<td>F</td>
<td>T</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumeric</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        F, T = <span class="literal">False</span>, <span class="literal">True</span></span><br><span class="line">        tx = [</span><br><span class="line">            [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, F, F],</span><br><span class="line">            [F, <span class="number">2</span>, <span class="number">3</span>, F, F],</span><br><span class="line">            [F, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, T],</span><br><span class="line">            [F, <span class="number">3</span>, F, <span class="number">4</span>, T],</span><br><span class="line">            [<span class="number">5</span>, <span class="number">6</span>, F, F, F],</span><br><span class="line">            [F, <span class="number">6</span>, F, F, F],</span><br><span class="line">            [F, <span class="number">6</span>, F, F, T]</span><br><span class="line">        ]</span><br><span class="line">        state = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> <span class="string">'+-'</span>:</span><br><span class="line">                state = tx[state][<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">elif</span> c <span class="keyword">in</span> <span class="string">'0123456789'</span>:</span><br><span class="line">                state = tx[state][<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> c <span class="keyword">in</span> <span class="string">'.'</span>:</span><br><span class="line">                state = tx[state][<span class="number">2</span>]</span><br><span class="line">            <span class="keyword">elif</span> c <span class="keyword">in</span> <span class="string">'eE'</span>:</span><br><span class="line">                state = tx[state][<span class="number">3</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> state == <span class="literal">False</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> state <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>有限状态机</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指52-正则表达式匹配</title>
    <url>/2019/09/13/algs/arrow4Offer/2019-09-13-52-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>请实现一个函数用来匹配包括<code>.</code>和<code>*</code>的正则表达式。模式中的字符<code>.</code>表示任意一个字符，而<code>*</code>表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串<code>aaa</code>与模式<code>a.a</code>和<code>ab*ac*a</code>匹配，但是与<code>aa.a</code>和<code>ab*a</code>均不匹配</p>
<hr>
<p>关于模式匹配：</p>
<ul>
<li>一条包括<code>.</code>和<code>*</code>的正则表达式，即模式，可以用<code>非确定有限状态机</code>来阐述。可知比较麻烦的是处理<code>*</code>。
<ul>
<li><code>ba*ab.</code>的状态机来举例，状态s1是初始状态，收到b进入s2，s2收到a有两个选择，可能回到s2，也可能进入新状态s3，s3收到b进入s4，s4收到任意一个字符进入s5。</li>
</ul></li>
<li>用递归。</li>
</ul>
<p>关于如下代码：</p>
<ul>
<li>根据是否处理<code>*</code>分为前后两部分，后者是<code>第二个字符是*</code>这一种情况，前者包括<code>s为空</code>、<code>无.和*的参与</code>和<code>.后面没有*</code>这三种情况。而前者根据是否处理<code>.</code>又分为<code>.后面没有*</code>这种情况，以及<code>s为空</code>、<code>无.和*的参与</code>这种情况。四种类别互斥且完备，如下树状图所示。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                         p为空</span><br><span class="line">                        /</span><br><span class="line">                       /</span><br><span class="line">           无 ---- p[0]有无`.`  --- 有`.`其后无`*`</span><br><span class="line">          /            \</span><br><span class="line">         /              \</span><br><span class="line">p[2]是否有`*`            无`.`           无</span><br><span class="line">         \                             /</span><br><span class="line">          \                           /</span><br><span class="line">           有 ---- s[0]是否为对应元素</span><br><span class="line">                                      \</span><br><span class="line">                                       \</span><br><span class="line">                                         有</span><br></pre></td></tr></table></figure>
<ul>
<li>处理部分只主动返回True，为确保返回的是True而非False，在返回之前有确认逻辑。坚持不返回False，因为不知为不知，以确保四分支处理线互不干扰。最后一行有个返回False，可以认为是被动返回。</li>
<li>返回True的确认逻辑的match函数，其输入参数s和p的变更要有依据。如<code>无.和*的参与</code>部分里参数变更为<code>s[1:], p[1:]</code>，是因为有<code>s[0] == p[0]</code>；而<code>第二个字符是*</code>部分里参数变更为<code>s, p[2:]</code>，是因为有<code>p[1] == '*'</code>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">match</span><span class="params">(self, s, p)</span>:</span></span><br><span class="line">        <span class="comment"># s为空</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">0</span> <span class="keyword">and</span> len(p) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 无.和*的参与，且s和p的第一个字符匹配</span></span><br><span class="line">        <span class="keyword">if</span> len(s) &gt; <span class="number">0</span> <span class="keyword">and</span> len(p) &gt; <span class="number">0</span> <span class="keyword">and</span> s[<span class="number">0</span>] == p[<span class="number">0</span>] <span class="keyword">and</span> p[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">'.*'</span>:</span><br><span class="line">            <span class="keyword">if</span> len(p) &gt;=<span class="number">2</span> <span class="keyword">and</span> p[<span class="number">1</span>] != <span class="string">'*'</span> <span class="keyword">or</span> len(p) == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> self.match(s[<span class="number">1</span>:], p[<span class="number">1</span>:]):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 第一个字符是`.`，后面没有`*`</span></span><br><span class="line">        <span class="keyword">if</span> len(p) &gt; <span class="number">0</span> <span class="keyword">and</span> p[<span class="number">0</span>] == <span class="string">'.'</span> <span class="keyword">and</span> (len(p) == <span class="number">1</span> <span class="keyword">or</span> len(p) &gt;= <span class="number">2</span> <span class="keyword">and</span>  p[<span class="number">1</span>] != <span class="string">'*'</span> ) <span class="keyword">and</span> len(s) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> self.match(s[<span class="number">1</span>:], p[<span class="number">1</span>:]):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第二个字符是`*`</span></span><br><span class="line">        <span class="keyword">if</span> len(p) &gt;= <span class="number">2</span> <span class="keyword">and</span> p[<span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">            <span class="keyword">if</span> self.match(s, p[<span class="number">2</span>:]):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> len(s) &gt; <span class="number">0</span> <span class="keyword">and</span> (s[<span class="number">0</span>] == p[<span class="number">0</span>] <span class="keyword">or</span> p[<span class="number">0</span>] == <span class="string">'.'</span>):</span><br><span class="line">                <span class="keyword">if</span> self.match(s[<span class="number">1</span>:], p) <span class="keyword">or</span> self.match(s[<span class="number">1</span>:], p[<span class="number">2</span>:]):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li>动态规划。</li>
</ul>
<p>长度为x的字符串<span class="math inline">\(s_1s_2\cdots s_x\)</span>，模式长度为y的模式序列<span class="math inline">\(p_1\cdots p_y\)</span>。如字符串<code>aaa</code>的长度是3，而模式序列<code>ab*ac*a</code>有5个子模式<code>a,b*,a,c*,a</code>。令g(x,y)表示<span class="math inline">\(s_1s_2\cdots s_x\)</span>与<span class="math inline">\(p_1\cdots p_y\)</span>的匹配状态，如g(x,y)=0表示匹配不成功，g(x,y)=1表示匹配成功。 则g(x,y)有如下递推关系：</p>
<ul>
<li>如果<span class="math inline">\(p_y\)</span>不是带<code>*</code>子模式，有<code>g(x,y) = g(s_x, p_y) and g(x-1,y-1)</code>。其中<span class="math inline">\(g(s_x, p_y)\)</span>表示字符<span class="math inline">\(s_x\)</span>与模式<span class="math inline">\(p_y\)</span>的匹配状态，很容易计算。特殊的，有<code>g(0,y)=g(0,p_y)=1 if y&gt;=1</code>，以及<code>g(x,0)=g(s_x,0) if x&gt;=1</code>。</li>
<li>如果<span class="math inline">\(p_y\)</span>是带<code>*</code>子模式，有<code>g(x,y)=g(x,y-1) or g(s_x,s_y) and g(x-1,y)</code>。其中，<code>g(x,y-1)=1</code>则说明去掉<span class="math inline">\(p_y\)</span>仍匹配，即<span class="math inline">\(p_y\)</span>匹配0个字符。而<code>g(s_x,s_y)&amp; g(x-1,y)=1</code>则说明<span class="math inline">\(p_y\)</span>匹配一个或多个字符。特殊的，有<code>g(0,y)=g(0,y-1) if y&gt;=1</code></li>
<li><code>g(0,?)</code>和<code>g(?,0)</code>分别表示空模式和空字符串。</li>
<li>边界值<code>g(0,0)=1</code></li>
<li>g(x,y)组成一个维度为<code>(x+1)*(y+1)</code>的二维矩阵。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">match</span><span class="params">(self, s, p)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">limit</span><span class="params">(sc,pc)</span>:</span> <span class="comment"># 计算sc是单字符或者空字符，以及pc是单模式和空模式的情形</span></span><br><span class="line">            <span class="keyword">if</span> len(sc) == <span class="number">0</span> <span class="keyword">and</span> len(pc) == <span class="number">0</span>: <span class="comment"># 空字串和空子模式</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> len(pc)==<span class="number">2</span> <span class="keyword">and</span> pc[<span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">                <span class="keyword">if</span> pc[<span class="number">0</span>] == <span class="string">'.'</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> len(sc) == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> sc == pc[<span class="number">0</span>]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> len(sc) == <span class="number">1</span> <span class="keyword">and</span> len(pc) == <span class="number">1</span> <span class="keyword">and</span> sc == pc:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> len(sc) == <span class="number">1</span> <span class="keyword">and</span> len(pc) == <span class="number">1</span> <span class="keyword">and</span> pc == <span class="string">'.'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getPatentsNumber</span><span class="params">(p)</span>:</span> <span class="comment"># 获得模式序列中的所有子模式，返回子模式列表</span></span><br><span class="line">            ps = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(p)):</span><br><span class="line">                <span class="keyword">if</span> i + <span class="number">1</span> &lt;= len(p)<span class="number">-1</span>:</span><br><span class="line">                    <span class="keyword">if</span> p[i+<span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> p[i] == <span class="string">'*'</span> <span class="keyword">and</span> i<span class="number">-1</span> &gt;= <span class="number">0</span>:</span><br><span class="line">                    ps.append(p[i<span class="number">-1</span>:i+<span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                ps.append(p[i])</span><br><span class="line">            <span class="keyword">return</span> ps          </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">computeMatch</span><span class="params">(s, ps, x, y, G)</span>:</span> <span class="comment">#以递归和动态规划的思想获得矩阵G</span></span><br><span class="line">            <span class="keyword">if</span> x + y == <span class="number">0</span>:</span><br><span class="line">                G[x][y] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> x == <span class="number">0</span> <span class="keyword">and</span> len(ps[y<span class="number">-1</span>]) &gt; <span class="number">1</span> <span class="keyword">and</span> ps[y<span class="number">-1</span>][<span class="number">1</span>] != <span class="string">'*'</span>:</span><br><span class="line">                G[x][y] = limit(<span class="string">''</span>, ps[y<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> y == <span class="number">0</span>:</span><br><span class="line">                G[x][y] = limit(s[x<span class="number">-1</span>],<span class="string">''</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> x &gt; <span class="number">0</span> <span class="keyword">and</span> y &gt; <span class="number">0</span> <span class="keyword">and</span> (len(ps[y<span class="number">-1</span>]) &gt; <span class="number">1</span> <span class="keyword">and</span> ps[y<span class="number">-1</span>][<span class="number">1</span>] != <span class="string">'*'</span> <span class="keyword">or</span> len(ps[y<span class="number">-1</span>]) == <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> G[x<span class="number">-1</span>][y<span class="number">-1</span>] == <span class="number">-1</span>:</span><br><span class="line">                    computeMatch(s, ps, x<span class="number">-1</span>, y<span class="number">-1</span>, G)</span><br><span class="line">                G[x][y] = limit(s[x<span class="number">-1</span>],ps[y<span class="number">-1</span>]) <span class="keyword">and</span> G[x<span class="number">-1</span>][y<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> len(ps[y<span class="number">-1</span>]) &gt; <span class="number">1</span> <span class="keyword">and</span> ps[y<span class="number">-1</span>][<span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">                <span class="keyword">if</span> G[x][y<span class="number">-1</span>] == <span class="number">-1</span>:</span><br><span class="line">                    computeMatch(s, ps, x, y<span class="number">-1</span>, G)</span><br><span class="line">                <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">                    G[x][y] = G[x][y<span class="number">-1</span>]</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> G[x<span class="number">-1</span>][y] == <span class="number">-1</span>:</span><br><span class="line">                        computeMatch(s, ps, x<span class="number">-1</span>, y, G)</span><br><span class="line">                    G[x][y] = G[x][y<span class="number">-1</span>] <span class="keyword">or</span> limit(s[x<span class="number">-1</span>],ps[y<span class="number">-1</span>]) <span class="keyword">and</span> G[x<span class="number">-1</span>][y]</span><br><span class="line">                        </span><br><span class="line">        ps = getPatentsNumber(p)</span><br><span class="line">        x, y = len(s), len(ps)</span><br><span class="line">        G = [([<span class="number">-1</span>]*(y+<span class="number">1</span>))[::] <span class="keyword">for</span> _ <span class="keyword">in</span> range(x+<span class="number">1</span>)]</span><br><span class="line">        computeMatch(s, ps, x, y, G)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> G[x][y] == <span class="number">1</span> <span class="keyword">else</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指51-构建乘积数组</title>
    <url>/2019/09/13/algs/arrow4Offer/2019-09-13-51-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>给定一个数组<code>A[0,1,...,n-1]</code>,请构建一个数组<code>B[0,1,...,n-1]</code>,其中B中的元素<code>B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]</code>。不能使用除法。</p>
<hr>
<p>直接套用B[i]的计算公式一次计算B中每个元素。该方法牵涉到大量的重复的乘运算，效率较低。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(A) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> len(A) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">0</span>]</span><br><span class="line">        B = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">            val = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(A)):</span><br><span class="line">                <span class="keyword">if</span> j != i:</span><br><span class="line">                    val *= A[j]</span><br><span class="line">            B.append(val)</span><br><span class="line">        <span class="keyword">return</span> B</span><br></pre></td></tr></table></figure>
<hr>
<p>令<code>C[i] = A[0]*A[1]*...*A[i-1]</code>，<code>D[i] = A[i+1]*...*A[n-1]</code>，则<code>B[i] = C[i]*D[i]</code>。且有<code>C[i+1]=C[i]*A[i]</code>和<code>D[i]=A[i+1]*D[i+1]</code>。可以大大简化乘运算数量。如下版本的代码还避免了新数组的构建，空间效率也比较高。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(A) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> len(A) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">0</span>]</span><br><span class="line">        B = [<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(A)):</span><br><span class="line">            B.append(B[i<span class="number">-1</span>]*A[i<span class="number">-1</span>])</span><br><span class="line">        temp = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(A)<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            temp *= A[j+<span class="number">1</span>]</span><br><span class="line">            B[j] *= temp</span><br><span class="line">        <span class="keyword">return</span> B</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指50-数组中重复的数字</title>
    <url>/2019/09/13/algs/arrow4Offer/2019-09-13-50-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
<blockquote>
<p>本题的后台评估算法有问题，实际中要求是找到第一个重复值并赋值到duplication[0]，然后如果有重复值则函数返回True否则False。</p>
</blockquote>
<hr>
<p>效率低版本：用字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 这里要特别注意~找到任意重复的一个值并赋值到duplication[0]</span></span><br><span class="line">    <span class="comment"># 函数返回True/False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">duplicate</span><span class="params">(self, numbers, duplication)</span>:</span></span><br><span class="line">        mydict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> mydict.has_key(num):</span><br><span class="line">                mydict[num] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                mydict[num] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="keyword">if</span> mydict[num] &gt; <span class="number">1</span>:</span><br><span class="line">                duplication[<span class="number">0</span>] = num</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<hr>
<p>题目里写了数组里数字是整型数，且的范围保证在0 ~ n-1 之间，所以可以利用现有数组设置标志，当一个数字被访问过后，可以设置对应位上的数 + n，之后再遇到相同的数时，会发现对应位上的数已经大于等于n了，那么直接返回这个数即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 这里要特别注意~找到任意重复的一个值并赋值到duplication[0]</span></span><br><span class="line">    <span class="comment"># 函数返回True/False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">duplicate</span><span class="params">(self, numbers, duplication)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(numbers) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        mylist = [<span class="literal">False</span>]*len(numbers)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="keyword">if</span> mylist[num]:</span><br><span class="line">                duplication[<span class="number">0</span>] = num</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                mylist[num] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指49-把字符串转换成整数</title>
    <url>/2019/09/13/algs/arrow4Offer/2019-09-13-49-%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。</p>
<p>输入描述:</p>
<blockquote>
<p>输入一个字符串,包括数字字母符号,可以为空</p>
</blockquote>
<p>输出描述:</p>
<blockquote>
<p>如果是合法的数值表达则返回该数字，否则返回0</p>
</blockquote>
<p>示例1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">+2147483647</span><br><span class="line">    1a33</span><br><span class="line">输出</span><br><span class="line">2147483647</span><br><span class="line">    0</span><br></pre></td></tr></table></figure>
<hr>
<p>其实题目的返回值设定有问题，返回0时无法推断出其输入是合法的0，还是非法表达。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">StrToInt</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        digits = [<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>]</span><br><span class="line">        pres = [<span class="string">'+'</span>, <span class="string">'-'</span>]</span><br><span class="line">        </span><br><span class="line">        val = <span class="number">0</span></span><br><span class="line">        sign = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> s[i] <span class="keyword">in</span> pres:</span><br><span class="line">                    sign = s[i]</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">not</span> <span class="keyword">in</span> digits:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            val *= <span class="number">10</span></span><br><span class="line">            val += int(s[i])</span><br><span class="line">        <span class="keyword">if</span> sign == <span class="string">'-'</span>:</span><br><span class="line">            val = <span class="number">0</span>-val</span><br><span class="line">        <span class="keyword">return</span> val</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指48-不用加减乘除做加法</title>
    <url>/2019/09/13/algs/arrow4Offer/2019-09-13-48-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p>
<hr>
<p>首先看十进制是如何做加法的的： 5+7=12，三步走</p>
<ul>
<li>第一步：相加各位的值，不算进位，得到2。</li>
<li>第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。</li>
<li>第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。</li>
</ul>
<p>同样我们可以用三步走的方式计算二进制值相加： 5-101，7-111</p>
<ul>
<li>第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。</li>
<li>第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。</li>
<li>重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&amp;1010)&lt;&lt;1。</li>
<li>继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果</li>
</ul>
<p>下面的代码忠实地执行了上述步骤，但不能很好地处理负数，可能会陷入死循环。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(self, num1, num2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> num1 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> num2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> num2 != <span class="number">0</span>:</span><br><span class="line">            num1, num2 = num1^num2, (num1&amp;num2)&lt;&lt;<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> num1</span><br></pre></td></tr></table></figure>
<p>而上述代码的C++或Java版本是没有上述问题的。原因在于：左移操作（即将一个数的二进制位整体向左移若干位，移位后在低位补零，高位溢出部分舍弃），在Python语言里的实现是不完善的，属于历史问题。</p>
<p>改进版代码稍作修改，避免了上述问题，可以处理各种正负数情形，但看不懂原理（<a href="https://blog.csdn.net/s1314p/article/details/95769392" target="_blank" rel="noopener">链接</a>）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(self, num1, num2)</span>:</span>           </span><br><span class="line">        <span class="keyword">while</span>(num2): </span><br><span class="line">            num1,num2 = (num1^num2) &amp; <span class="number">0xFFFFFFFF</span>,((num1&amp;num2)&lt;&lt;<span class="number">1</span>) &amp; <span class="number">0xFFFFFFFF</span></span><br><span class="line">        <span class="keyword">return</span> num1 <span class="keyword">if</span> num1&lt;=<span class="number">0x7FFFFFFF</span> <span class="keyword">else</span> ~(num1^<span class="number">0xFFFFFFFF</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指47-求1+2+3+...+n</title>
    <url>/2019/09/13/algs/arrow4Offer/2019-09-13-47-%E6%B1%821+2+3+...+n/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>求1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<hr>
<p>核心在于实现判断终止条件的逻辑：逻辑短路规则适用于return语句，结合递归来判断终止条件，一个全局变量记录递归逻辑所作的状态更新。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_n</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_sum</span><span class="params">(n, mysum)</span>:</span></span><br><span class="line">        mysum[<span class="number">0</span>] += n</span><br><span class="line">        <span class="keyword">return</span> n<span class="number">-1</span> <span class="keyword">and</span> get_sum(n<span class="number">-1</span>,mysum)</span><br><span class="line">    </span><br><span class="line">    mysum = [<span class="number">0</span>]</span><br><span class="line">    get_sum(n,mysum)</span><br><span class="line">    <span class="keyword">return</span> mysum[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>或者在对象里用成员变量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Sum_Solution</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.sum = <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getsum</span><span class="params">(n)</span>:</span></span><br><span class="line">            self.sum += n</span><br><span class="line">            n  -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> n &gt; <span class="number">0</span> <span class="keyword">and</span> getsum(n)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            getsum(n)</span><br><span class="line">            <span class="keyword">return</span> self.sum</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指46-孩子们的游戏(圆圈中最后剩下的数)</title>
    <url>/2019/09/13/algs/arrow4Offer/2019-09-13-46-%E5%AD%A9%E5%AD%90%E4%BB%AC%E7%9A%84%E6%B8%B8%E6%88%8F(%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0)/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0...m-1报数....这样下去....直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</p>
<p>如果没有小朋友，请返回-1</p>
<hr>
<p>约瑟夫环问题Josephus problem。</p>
<h4 id="模拟法">模拟法</h4>
<p>此代码模拟了整个过程，只是在计算出列的编号时用了求余这个操作。</p>
<ul>
<li>如果某一圈从位置<code>0</code>开始报数<code>0</code>，圈的长度为<code>L</code>，则报<code>m-1</code>的小朋友的位置将是<code>(m-1)%L</code>。</li>
<li>剔除该位置元素之后，将该位置左侧子序列和右侧子序列调换位置连起来形成一个新的序列，执行第一步。直到新序列只剩下一个元素。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LastRemaining_Solution</span><span class="params">(self, n, m)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span> <span class="keyword">or</span> m &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span> <span class="comment">#该返回值在题目中有说</span></span><br><span class="line">        boys = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">while</span> len(boys) &gt; <span class="number">1</span>:</span><br><span class="line">            ix = (m - <span class="number">1</span>) % len(boys)</span><br><span class="line">            boys = boys[ix+<span class="number">1</span>:] + boys[:ix]</span><br><span class="line">        <span class="keyword">return</span> boys[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="递归法">递归法</h4>
<p>原问题标记为函数<code>f(n, m)</code>，表示n个小朋友序号为<code>0, 1, ..., n-1</code>，从0位置开始报0，报出<code>m-1</code>的出列，从下一个继续报0，最后剩下的小朋友的序号。该问题的首个出列序号可以按公式<code>(m-1)%n</code>来获得。</p>
<p>设想序列为<code>0, 1, ..., n-1</code>的首个小朋友（序号是<code>m-1</code>）出列后，剩下长度为<code>n-1</code>的序列标记为<code>m, m+1, ..., n-2, n-1, 0, 1, 2, .., m-3, m-2</code>，接下来仍然从第0位置开始报0，最后剩下的小朋友的序号。该问题的小朋友序列不是问题<code>f(n-1, m)</code>的<code>0, 1, ..., n-2</code>，因为其首个出列序号不能按公式<code>(m-1)%(n-1)</code>来计算。而是一个新问题，标记为<code>g(n-1, m)</code>，而且有<code>f(n, m)=g(n-1, m)</code>。</p>
<p>那么，如果能将<code>g(n-1, m)</code>用<code>f(n-1, m)</code>来表示，则可以用递归求解原问题了。</p>
<p>再看<code>f(n-1, m)</code>与<code>g(n-1, m)</code>的输入序列的对比：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><strong>x</strong></th>
<th style="text-align: center;">0</th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">...</th>
<th style="text-align: center;">n-m-1</th>
<th style="text-align: center;">n-m</th>
<th style="text-align: center;">n-m+1</th>
<th style="text-align: center;">...</th>
<th style="text-align: center;">n-3</th>
<th style="text-align: center;">n-2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>y</strong></td>
<td style="text-align: center;">m</td>
<td style="text-align: center;">m+1</td>
<td style="text-align: center;">...</td>
<td style="text-align: center;">n-1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">...</td>
<td style="text-align: center;">m-3</td>
<td style="text-align: center;">m-2</td>
</tr>
</tbody>
</table>
<p>则有对应元素的映射关系<code>y=(x+m)%n</code>。</p>
<p>由于<code>f(n-1, m)</code>与<code>g(n-1, m)</code>的对应位置是相同的，所以二者的值可以套用上述映射关系，有<code>g(n-1, m)=(f(n-1, m)+m)%n</code>。 因此有递归公式<code>f(n, m)=(f(n-1, m)+m)%n</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LastRemaining_Solution</span><span class="params">(self, n, m)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span> <span class="keyword">or</span> m &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span> </span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> (self.LastRemaining_Solution(n<span class="number">-1</span>,m)+m)%n</span><br></pre></td></tr></table></figure>
<p>注意栈溢出问题，实际测试中原始序列长度大于3700则会栈溢出。</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指45-扑克牌顺子</title>
    <url>/2019/09/13/algs/arrow4Offer/2019-09-13-45-%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张)...他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子.....LL不高兴了,他想了想,决定大王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。</p>
<hr>
<ul>
<li>大小王都是0，其它牌从1到13。</li>
<li>输入是一个数组，判断能否组成5个顺子，其中大小王可以当任意数字。</li>
<li>gap：非0牌按顺序排列之后，相邻两张牌的缺牌数之和（3和4gap为0，4和7的gap为2)。</li>
<li>当gap总数小于0牌个数，则能组成顺子。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsContinuous</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(numbers) != <span class="number">5</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        numbers.sort()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 统计0的个数</span></span><br><span class="line">        zerocount = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">            <span class="keyword">if</span> numbers[i] == <span class="number">0</span>:</span><br><span class="line">                zerocount += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#gap是数组里两个挨着的数字的大小间隔大于1，这时候需要用大王小王来填充他们之间</span></span><br><span class="line">        <span class="comment"># 因此第i和i+1两个数的gap的计算方式是numbers[i+1] - numbers[i] - 1</span></span><br><span class="line">        <span class="comment"># 且gapcount &lt;= zerocount</span></span><br><span class="line">        gapcount = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(zerocount, <span class="number">4</span>):</span><br><span class="line">            <span class="keyword">if</span> numbers[i] == numbers[i+<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            gapcount += numbers[i+<span class="number">1</span>] - numbers[i] - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> gapcount &lt;= zerocount</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指44-翻转单词顺序列</title>
    <url>/2019/09/13/algs/arrow4Offer/2019-09-13-44-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseSentence</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span>.join(s.split(<span class="string">' '</span>)[::<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指43-左旋转字符串</title>
    <url>/2019/09/13/algs/arrow4Offer/2019-09-13-43-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p>
<hr>
<p>巧用求余数运算</p>
<ul>
<li>左移后的第i位，是原字符串的第(i+n)%lens位。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LeftRotateString</span><span class="params">(self, s, n)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join([s[(i+n)%len(s)] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s))])</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指42-和为S的两个数字</title>
    <url>/2019/09/13/algs/arrow4Offer/2019-09-13-42-%E5%92%8C%E4%B8%BAS%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p>
<p>输出描述:</p>
<blockquote>
<p>对应每个测试案例，输出两个数，小的先输出。</p>
</blockquote>
<hr>
<ul>
<li>乘积最小，肯定是两头优先，即较小值从序列最左侧开始找。</li>
<li>较小值上界是<code>0.5*tsum</code>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindNumbersWithSum</span><span class="params">(self, array, tsum)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(array) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> array:</span><br><span class="line">            <span class="keyword">if</span> num &gt;= <span class="number">0.5</span>*tsum:</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line">            <span class="keyword">if</span> tsum - num <span class="keyword">in</span> array:</span><br><span class="line">                <span class="keyword">return</span> [num, tsum-num]</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li>将查看数组是否包含某元素的操作，即'if tsum-num in array'，替换成了二分查找。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindNumbersWithSum</span><span class="params">(self, array, tsum)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(num, array)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(array) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            s, t = <span class="number">0</span>, len(array)<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> s &lt; t:</span><br><span class="line">                mid = (s+t)&gt;&gt;<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> array[mid] == num:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">elif</span> array[mid] &gt; num:</span><br><span class="line">                    t = mid</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    s = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> array[s] == num</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">if</span> len(array) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">for</span> ix, num <span class="keyword">in</span> enumerate(array):</span><br><span class="line">            <span class="keyword">if</span> num &gt;= <span class="number">0.5</span>*tsum:</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line">            <span class="keyword">if</span> search(tsum - num, array[ix+<span class="number">1</span>:]):</span><br><span class="line">                <span class="keyword">return</span> [num, tsum-num]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指41-和为S的连续正数序列</title>
    <url>/2019/09/13/algs/arrow4Offer/2019-09-13-41-%E5%92%8C%E4%B8%BAS%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!</p>
<p>输出描述:</p>
<blockquote>
<p>输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺</p>
</blockquote>
<hr>
<ul>
<li>设s是满足条件的连续正数序列的第一个数
<ul>
<li>s最小值的下界是1，</li>
<li>s最大值时，肯定只包含两个数，另一个是s+1，则有2s+1=S，故s上界为floor(0.5*(S-1))</li>
</ul></li>
<li>设t是满足条件的连续正数序列的最后一个数
<ul>
<li>t的下界是s+1</li>
<li>t取上界时，也是包含两个数，2t-1=S，故t上界为floor(0.5*(S+1))</li>
</ul></li>
<li>当s确定了之后，t也就确定了。
<ul>
<li><code>s + (s+1) + (s+2) + ...+ t</code>，一旦累加和等于等于S或者大于S则停止，前者说明找到了s开头的序列，后者说明序列不存在。</li>
</ul></li>
<li>如果把握不准s和t的上界，可以适当把上界调高，反正不会影响最终的结果。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindContinuousSequence</span><span class="params">(self, tsum)</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, ((tsum<span class="number">-1</span>)&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>):</span><br><span class="line">            mysum = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, ((tsum+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>):</span><br><span class="line">                mysum += j</span><br><span class="line">                <span class="keyword">if</span> mysum == tsum:</span><br><span class="line">                    res.append(list(range(i, j + <span class="number">1</span>)))</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">elif</span> mysum &gt; tsum:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指40-数组中只出现一次的数字</title>
    <url>/2019/09/13/algs/arrow4Offer/2019-09-13-40-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>一个整型数组里除了<code>两个数字</code>之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
<hr>
<ul>
<li>从头到尾依次异或数组中的每一个数字，那么最终得到的结果就是两个只出现一次的数字的异或的结果。因为其他数字都出现两次，在异或中全部抵消了。由于这两个数字肯定不一样，那么异或的结果肯定不为0，也就是说在这个结果数字的二进制表示中至少有一位为1.我们在结果数字中找到第一个为1的位的位置，记为第k位。</li>
<li>现在我们以第k位是不是1为标准把原数组中的数字分成两个子数组。出现了两次的数字肯定被分配到同一个子数组中，因为两个相同的数字的任意一位都是相同的。不可能把两个相同的数字分配到两个子数组中去。</li>
<li>每个子数组都包含了一个只出现一次的数字，而其他数字都出现了两次，分别对子数组所有元素求异或，就把那个只出现一次的数找出来了。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回[a,b] 其中ab是出现一次的两个数字</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindNumsAppearOnce</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">k_bit_0</span><span class="params">(num, k)</span>:</span></span><br><span class="line">            <span class="comment"># 本函数查看num的第k个比特位是否是1</span></span><br><span class="line">            <span class="comment"># k为0,1,2,...</span></span><br><span class="line">            <span class="keyword">while</span> k &gt; <span class="number">0</span>:</span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">                num = num&gt;&gt;<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> num&amp;<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">first_bit_1</span><span class="params">(num)</span>:</span></span><br><span class="line">            <span class="comment"># 本函数返回数字二进制位从最低位开始的第一个非0位置</span></span><br><span class="line">            <span class="comment"># k为0,1,2,...</span></span><br><span class="line">            k = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">if</span> num&amp;<span class="number">1</span> == <span class="number">0</span>:</span><br><span class="line">                    num = num&gt;&gt;<span class="number">1</span></span><br><span class="line">                    k += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">return</span> k        </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 所有数求异或得到xor_all</span></span><br><span class="line">        xor_all = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> array:</span><br><span class="line">            xor_all ^= num</span><br><span class="line">        <span class="comment"># 找到xor_all的从最低位开始的第一个二进制1的位置</span></span><br><span class="line">        k = first_bit_1(xor_all)</span><br><span class="line"></span><br><span class="line">        a, b = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> array:</span><br><span class="line">            <span class="keyword">if</span> k_bit_0(num, k): </span><br><span class="line">                <span class="comment"># 根据第k个二进制位是否是1，可以将所有数字分为两类，两个只出现一次的数肯定不在同一类，因为第k二进制位肯定不一样。</span></span><br><span class="line">                <span class="comment">#而且每一类除了只出现一次的数，其它数都是成对出现。</span></span><br><span class="line">                <span class="comment">#那么，两类分别对其所有元素求异或，则异或结果是那个只出现一次的数。</span></span><br><span class="line">                a ^= num</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                b ^= num</span><br><span class="line">        <span class="keyword">return</span> [a, b]</span><br></pre></td></tr></table></figure>
<hr>
<p>遍历数组，用字典统计每个元素的频度。然后把字典里频度为1的数找出来。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回[a,b] 其中ab是出现一次的两个数字</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindNumsAppearOnce</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        mydict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> array:</span><br><span class="line">            <span class="keyword">if</span> mydict.has_key(num):</span><br><span class="line">                mydict[num] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                mydict[num] = <span class="number">1</span></span><br><span class="line">        mylist = []</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> mydict.items():</span><br><span class="line">            <span class="keyword">if</span> v == <span class="number">1</span>:</span><br><span class="line">                mylist.append(k)</span><br><span class="line">        <span class="keyword">return</span> mylist</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指39-平衡二叉树</title>
    <url>/2019/09/13/algs/arrow4Offer/2019-09-13-39-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
<blockquote>
<p>平衡二叉树：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p>
</blockquote>
<hr>
<ul>
<li>递归，参数是节点，返回节点是否是平衡二叉树的判断，如果是平衡二叉树返回以其为根节点的子树的深度。如下代码用一个返回项来表示返回的状态。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsBalanced_Solution</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getDepth</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="comment"># 终止条件</span></span><br><span class="line">            <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 左右节点一旦有一个不是平衡二叉树，就不再处理，直接向上返回-1</span></span><br><span class="line">            leftDepth = getDepth(root.left)</span><br><span class="line">            <span class="keyword">if</span> leftDepth == <span class="number">-1</span>: </span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            rightDepth = getDepth(root.right)</span><br><span class="line">            <span class="keyword">if</span> rightDepth == <span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 递推式</span></span><br><span class="line">            <span class="keyword">if</span> abs(leftDepth - rightDepth) &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span> + max(leftDepth, rightDepth)</span><br><span class="line">        <span class="keyword">return</span> getDepth(pRoot) != <span class="number">-1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指38-二叉树的深度</title>
    <url>/2019/09/13/algs/arrow4Offer/2019-09-13-38-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
<hr>
<p>循环和递归，递归函数的参数是节点root及其父节点的深度k，以及一个全局的引用变量dpthlist（用对象的成员变量也行）用来存储叶节点的深度。</p>
<ul>
<li>一旦遇到空节点，返回，存储其父节点也是叶节点的深度进dpthlist。</li>
<li>非空节点，分别对其左右孩子节点执行递归函数。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">TreeDepth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        dpthlist = [<span class="number">0</span>]</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(root, k, dpthlist)</span>:</span></span><br><span class="line">            <span class="comment"># 首次调用recur(root, 0, dpthlist)，故k是root父节点的深度</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                dpthlist.append(k)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            recur(root.left, k+<span class="number">1</span>, dpthlist)</span><br><span class="line">            recur(root.right, k+<span class="number">1</span>, dpthlist)</span><br><span class="line">        recur(root, <span class="number">0</span>, dpthlist)</span><br><span class="line">        <span class="keyword">return</span> max(dpthlist)</span><br></pre></td></tr></table></figure>
<hr>
<p>上面版本在叶节点上获知深度，而如下版本在根节点获知深度，代码更简洁：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">TreeDepth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span>(root.left <span class="keyword">or</span> root.right):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + max(self.TreeDepth(root.left), self.TreeDepth(root.right))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指37-数字在排序数组中出现的次数</title>
    <url>/2019/09/13/algs/arrow4Offer/2019-09-13-37-%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>统计一个数字在排序数组中出现的次数。</p>
<hr>
<ul>
<li>二分递归查找，终止条件是找到一个该数字，边界是递归函数的参数数组是空。</li>
<li>如果找到了该数字，分别向左右遍历该数字直到不是该数字为止，计数。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNumberOfK</span><span class="params">(self, data, k)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(data) == <span class="number">0</span>: <span class="comment"># 如果data是空列表，返回0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> data[<span class="number">0</span>] &gt; data[<span class="number">-1</span>]: <span class="comment"># 按从小到大排序</span></span><br><span class="line">            data = data[::<span class="number">-1</span>]</span><br><span class="line">            </span><br><span class="line">        loc = len(data)&gt;&gt;<span class="number">1</span> <span class="comment"># data的中间位置索引号</span></span><br><span class="line">        <span class="keyword">if</span> data[loc] &gt; k: <span class="comment"># 在左侧检查</span></span><br><span class="line">            <span class="keyword">return</span> self.GetNumberOfK(data[:loc], k)</span><br><span class="line">        <span class="keyword">elif</span> data[loc] &lt; k: <span class="comment"># 在右侧检查 </span></span><br><span class="line">            <span class="keyword">return</span> self.GetNumberOfK(data[loc+<span class="number">1</span>:], k)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> data[:loc][::<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">if</span> num == k:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> data[loc:]:</span><br><span class="line">                <span class="keyword">if</span> num == k:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<hr>
<p>因为数组元素都是整数，所以可以稍微变一下，不是搜索k的两个边界位置，而是搜索k-0.5和k+0.5这两个数应该插入的位置，然后相减即可得到k值的数量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNumberOfK</span><span class="params">(self, data, k)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(nums, target)</span>:</span></span><br><span class="line">            s, t = <span class="number">0</span>, len(nums)</span><br><span class="line">            <span class="keyword">while</span> s &lt; t:</span><br><span class="line">                m = (s + t) &gt;&gt; <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> nums[m] == target:</span><br><span class="line">                    <span class="keyword">while</span> m &gt; <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">if</span> nums[m<span class="number">-1</span>] == target:</span><br><span class="line">                            m -= <span class="number">1</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">return</span> m</span><br><span class="line">                <span class="keyword">elif</span> nums[m] &gt; target:</span><br><span class="line">                    <span class="keyword">if</span> m == s:</span><br><span class="line">                        <span class="keyword">return</span> m</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        t = m</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    s = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">if</span> len(data) &lt;= <span class="number">1</span>:</span><br><span class="line">            delta = <span class="number">0.0001</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            delta = min(<span class="number">0.0001</span>, max([data[i+<span class="number">1</span>]-data[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(data)<span class="number">-1</span>)]))</span><br><span class="line">        loc1 = searchInsert(data, k<span class="number">-0.0001</span>)</span><br><span class="line">        loc2 = searchInsert(data, k+<span class="number">0.0001</span>)</span><br><span class="line">        <span class="keyword">return</span> loc2 - loc1</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指36-两个链表的第一个公共结点</title>
    <url>/2019/09/13/algs/arrow4Offer/2019-09-13-36-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>输入两个链表，找出它们的第一个公共结点。</p>
<hr>
<p>找出2个链表的长度，然后让长的先走两个链表的长度差，然后再一起走。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindFirstCommonNode</span><span class="params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        p1, p2 = pHead1, pHead2</span><br><span class="line">        len1, len2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p1:</span><br><span class="line">            len1 += <span class="number">1</span></span><br><span class="line">            p1 = p1.next</span><br><span class="line">        <span class="keyword">while</span> p2:</span><br><span class="line">            len2 += <span class="number">1</span></span><br><span class="line">            p2 = p2.next</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> len1 &lt; len2:</span><br><span class="line">            p1, p2 = pHead2, pHead1</span><br><span class="line">            len1, len2 = len2, len1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p1, p2 = pHead1, pHead2</span><br><span class="line">        <span class="keyword">while</span> len1 &gt; len2:</span><br><span class="line">            len1 -= <span class="number">1</span></span><br><span class="line">            p1 = p1.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> p1 <span class="keyword">and</span> p2 <span class="keyword">and</span> p1 != p2:</span><br><span class="line">            p1 = p1.next</span><br><span class="line">            p2 = p2.next</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> p1</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指35-数组中的逆序对</title>
    <url>/2019/09/13/algs/arrow4Offer/2019-09-13-35-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>问题</p>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。 并将P对1000000007取模的结果输出。 即输出P%1000000007</p>
<hr>
<ul>
<li>分治和递归。将序列每次折半划分成两个子数组，对应两个子问题。两个子问题解决了，即得到子序列的逆序对数量之后，再统计分别在两个子序列的逆序对的数量，加起来就是原问题的逆序对数量。</li>
<li>归并排序。如果两个子序列都是已经排好序的，统计分别在两个子序列的逆序对的数量就有复杂度低的方法，那么就需要对已经拍好序的两个子序列合并成一个排好序的序列，这其实就是归并排序要做的。</li>
</ul>
<p>难点在于如何在归并过程中统计分别在两个子序列的逆序对的数量。核心代码：左子序列<code>left..mid</code>，右子序列<code>mid+1..high</code>，i和j分别是左、右子序列上的指针。</p>
<ul>
<li>其中<code>mid-i+1</code>是左子序列上与右子序列的元素<code>nums[j]</code>形成逆序对的所有元素数量，即<code>i..mid</code>位置的元素，将其标记为x(j)。那么只要把右子序列所有元素的x(j)计算并求和即可得到所有逆序对的数量。
<ul>
<li>x(j)是互斥且完备的。</li>
</ul></li>
<li><code>x(j)=mid-i+1</code>的理解：当要添加<code>nums[j]</code>到辅助数组时，说明<code>nums[i]&gt;nums[j]</code>，且<code>nums[i..mid]&gt;nums[j]</code>，一共有<code>mid-i+1</code>个逆序对。
<ul>
<li>从小到大归并时，是从前往后的顺序，只能是计算x(j)，也就是添加<code>nums[j]</code>时计算。若要计算x(j)进而求和获得左右子序列的逆序对数，那么需要从大到小归并，且从后向前的顺序。</li>
</ul></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= high:</span><br><span class="line">    <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">        temp.append(nums[j])</span><br><span class="line">        xcount += mid-i+<span class="number">1</span></span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        temp.append(nums[i])</span><br><span class="line">        i += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>完整代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">InversePairs</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> self.mergeSort(nums, <span class="number">0</span>, len(nums)<span class="number">-1</span>) % <span class="number">1000000007</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span><span class="params">(self, nums, low, high)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> low &gt;= high:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 下面三行是分治的架构， left和right分别是两个分支数组所拥有的逆序对   </span></span><br><span class="line">        mid = int((low + high) / <span class="number">2</span>)</span><br><span class="line">        lcount = self.mergeSort(nums, low, mid)</span><br><span class="line">        rcount = self.mergeSort(nums, mid+<span class="number">1</span>, high)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 分治之后的合并，用了归并算法 </span></span><br><span class="line">        <span class="comment"># 下面代码有两个任务：1.统计归并过程中新发现的逆序对数量；2.使合并得到的新数组按顺序排列</span></span><br><span class="line">        xcount = <span class="number">0</span> <span class="comment"># 用于统计归并过程中发现的新的逆序对     </span></span><br><span class="line">        i = low</span><br><span class="line">        j = mid+<span class="number">1</span></span><br><span class="line">        temp = []</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 以下是归并排序，只有xcount += mid-i+1是统计新的的逆序对数量</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= high:</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                temp.append(nums[j])</span><br><span class="line">                xcount += mid-i+<span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temp.append(nums[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= mid:</span><br><span class="line">            temp.append(nums[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &lt;= high:</span><br><span class="line">            temp.append(nums[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 将排好序的子序列拷贝到nums</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(low, high+<span class="number">1</span>):</span><br><span class="line">            nums[i] = temp[i-low]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> xcount + lcount + rcount</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>归并排序</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指34-第一个只出现一次的字符位置</title>
    <url>/2019/09/12/algs/arrow4Offer/2019-09-12-34-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.</p>
<hr>
<p>字典记录，前后只要遍历两次，复杂度是O(n)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        mydict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> mydict.has_key(char):</span><br><span class="line">                mydict[char] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                mydict[char] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> mydict[s[i]] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指33-丑数</title>
    <url>/2019/09/12/algs/arrow4Offer/2019-09-12-33-%E4%B8%91%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
<hr>
<p>定义了一个丑数递增序列L,和列表<code>L</code>上的三个下标ix2、ix3、ix5为：</p>
<ul>
<li>ix2是满足<code>2*L[ix2]&gt;L[-1]</code>的最小,</li>
<li>ix3是满足<code>3*L[ix3]&gt;L[-1]</code>的最小,</li>
<li>ix5是满足<code>5*L[ix5]&gt;L[-1]</code>的最小。</li>
</ul>
<p>其中<code>L[-1]</code>是列表L的最后一个元素。</p>
<p>由于丑数是只包含质因子2、3和5的数，那么下一个丑数必然出自<code>L[ix2]*2,L[ix3]*3,L[ix5]*5</code>这三个数。</p>
<p>可以证明：如果<code>L[ix2]*2</code>被选中，则更新公式必然是<code>ix2 += 1</code>。如下证明<code>ix2+1</code>是满足<code>2*L[ix2+1]&gt;L[ix2]*2</code>的最小：</p>
<ul>
<li>由于<code>L[ix2+1]&gt;L[ix2]</code>,则<code>L[ix2+1]*2&gt;L[ix2]*2=L[-1]</code>，这里<code>L[-1]</code>是刚添加进L的<code>L[ix2]*2</code>。即<code>ix2+1</code>必然满足。</li>
<li>不存在<code>ix&lt;ix2+1</code>，使得<code>L[ix]*2&gt;L[-1]</code>。因为此时必有<code>ix&lt;=ix2</code>,必有<code>L[ix]*2&lt;=L[ix2]*2=L[-1]</code>。即<code>ix2+1</code>必然最小。</li>
</ul>
<p>同理可得ix3和ix5的更新公式。如果有多与一个序号被选中，即<code>L[ix2]*2,L[ix3]*3,L[ix5]*5</code>里有大于1个数相等且为下一个丑数，此时对应的序号分别更新。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt;= <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        L = [<span class="number">1</span>]</span><br><span class="line">        ix2, ix3, ix5 = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(index<span class="number">-1</span>):</span><br><span class="line">            newUgly = min(L[ix2]*<span class="number">2</span>, L[ix3]*<span class="number">3</span>, L[ix5]*<span class="number">5</span>)</span><br><span class="line">            L.append(newUgly)</span><br><span class="line">            <span class="keyword">if</span> (newUgly % <span class="number">2</span> == <span class="number">0</span>):</span><br><span class="line">                ix2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (newUgly % <span class="number">3</span> == <span class="number">0</span>):</span><br><span class="line">                ix3 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (newUgly % <span class="number">5</span> == <span class="number">0</span>):</span><br><span class="line">                ix5 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> L[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指32-把数组排成最小的数</title>
    <url>/2019/09/12/algs/arrow4Offer/2019-09-12-32-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
<hr>
<p>设num1和num2分别是两个数，定义符号<code>_</code>为连接两个数成一个数，如<code>2_3</code>表示连接2和3生成23这个数。有：</p>
<ul>
<li>如果num1_num2&lt;num2_num1，则num1、num2和其它任意个数连接生成的最小的数字里，必定num1在num2之前。</li>
<li>即，由num1和num2自身，就可以决定其在拼接的前后顺序关系。</li>
<li>如果知道任意两个数的顺序关系，则包含所有数的全局的拼接方案就固定了。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintMinNumber</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="comment"># 据测试结果发现，要求返回值是字符串</span></span><br><span class="line">        <span class="keyword">if</span> len(numbers) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        numbers = [str(i) <span class="keyword">for</span> i <span class="keyword">in</span> numbers]</span><br><span class="line">        numbers.sort(cmp = <span class="keyword">lambda</span> x, y: int(x+y)-int(y+x))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(numbers)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指31-整数中1出现的次数（从1到n整数中1出现的次数）</title>
    <url>/2019/09/12/algs/arrow4Offer/2019-09-12-31-%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%EF%BC%88%E4%BB%8E1%E5%88%B0n%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>求出<code>1~13</code>的整数中1出现的次数,并算出<code>100~1300</code>的整数中1出现的次数？为此他特别数了一下<code>1~13</code>中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。</p>
<hr>
<p>效率低：把数字转换成字符串，统计字符串中符号<code>1</code>的个数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        mystr = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            mystr += str(i)</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(mystr)):</span><br><span class="line">            <span class="keyword">if</span> mystr[i] == <span class="string">'1'</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<hr>
<p>效率高。</p>
<p>首先三个概念：每个数位的round，base和former，以数532里的数字3来说，round是5，base=10，former是2。</p>
<ul>
<li>数从0累加1直到等于其自身，某个数字位上经过0-9的一次周期变换称为一个round。可知3所在的数字位经历了5次完整的round。</li>
<li>一个round里，某个数字位的一个数字出现的次数称为base。3所在的数字位的每个数字，其实出现的次数相同，base=10。</li>
<li>3的右邻的数字是former。</li>
</ul>
<p>根据某个数位的round、base和former，有公式可以计算该数位上每个数字出现的次数。设该数位上的数是n，计算该数位上m出现的次数，有：</p>
<ul>
<li><code>n&lt;m</code>时，有<code>round*base</code>，第<code>round+1</code>这个不完整的周期里，m在该数位上没出现。</li>
<li><code>n&gt;m</code>是，有<code>(round+1)*base</code>，第<code>round+1</code>这个不完整的周期里，m出现了，出现次数与一个完整周期相同。</li>
<li><code>n=m</code>时，有<code>round*base+former+1</code>，处于前两者之间，出现次数用<code>former+1</code>表示。</li>
</ul>
<p>另外，最高数字位的<code>round=0</code>。而最低数字位，即个位，的<code>former+1</code>这一项等于0，<code>base=1</code>：</p>
<ul>
<li><code>n&lt;m</code>时，有<code>round</code></li>
<li><code>n&gt;=m</code>时，有<code>round+1</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        counts = []</span><br><span class="line">        round = n</span><br><span class="line">        base = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> round:</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            weight = round%<span class="number">10</span></span><br><span class="line">            round = round/<span class="number">10</span></span><br><span class="line">            former = n%base</span><br><span class="line">            <span class="keyword">if</span> weight &lt; <span class="number">1</span>:</span><br><span class="line">                count += round*base</span><br><span class="line">            <span class="keyword">elif</span> weight &gt; <span class="number">1</span>:</span><br><span class="line">                count += round*base + base</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count += round*base + former + <span class="number">1</span> </span><br><span class="line">            counts.append(count)</span><br><span class="line">            base *= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> sum(counts)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指30-连续子数组的最大和</title>
    <url>/2019/09/12/algs/arrow4Offer/2019-09-12-30-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)</p>
<hr>
<p>动态规划思想，可以参考<code>股票的最大利润问题</code>。</p>
<ul>
<li>F(i)：以array[i]为末尾元素的子数组的和的最大值。</li>
<li>则有F(i)=max(F(i-1)+array[i],array[i])</li>
<li>max(res,F(i))就是所求。</li>
<li>子向量的长度至少是1，如果子向量长度可以为0，则F(i)&gt;=0，公式略有不同。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="comment"># 在每次元素累加和小于0时，从下一个元素重新开始累加</span></span><br><span class="line">        <span class="keyword">if</span> len(array) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        sumlist = []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> array:</span><br><span class="line">            <span class="keyword">if</span> len(sumlist)&gt; <span class="number">0</span> <span class="keyword">and</span> sumlist[<span class="number">-1</span>] &gt; <span class="number">0</span>:</span><br><span class="line">                temp = sumlist[<span class="number">-1</span>] + num</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temp = num</span><br><span class="line">            sumlist.append(temp)</span><br><span class="line">        <span class="keyword">return</span> max(sumlist)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指29-最小的K个数</title>
    <url>/2019/09/12/algs/arrow4Offer/2019-09-12-29-%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p>
<hr>
<p>长度为k的辅助数组。</p>
<ul>
<li>每次遍历到一个数，可能需要给辅助数组排序，因此时间复杂度是<span class="math inline">\(n\log k\)</span></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetLeastNumbers_Solution</span><span class="params">(self, tinput, k)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(tinput) &lt; k <span class="keyword">or</span> k &lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        lk = tinput[:k]</span><br><span class="line">        lk.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k, len(tinput)):</span><br><span class="line">            <span class="keyword">if</span> lk[<span class="number">-1</span>] &gt; tinput[i]:</span><br><span class="line">                lk[<span class="number">-1</span>] = tinput[i]</span><br><span class="line">            lk.sort()</span><br><span class="line">        <span class="keyword">return</span> lk</span><br></pre></td></tr></table></figure>
<hr>
<p>用内置的堆实现heapq，性能也不错： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetLeastNumbers_Solution</span><span class="params">(self, tinput, k)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> tinput <span class="keyword">or</span> <span class="keyword">not</span> k <span class="keyword">or</span> k &gt; len(tinput):</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        heapq.heapify(tinput)</span><br><span class="line">        <span class="keyword">return</span> [heapq.heappop(tinput) <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(k)]</span><br></pre></td></tr></table></figure></p>
<hr>
<p>用快排的partition方法来找到第k大的数，那么该数以及其左侧k-1个数一起，就是最小的k个数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetLeastNumbers_Solution</span><span class="params">(self, tinput, k)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(nums, l, r)</span>:</span></span><br><span class="line">            x = nums[r]</span><br><span class="line">            i, j = l, r<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; j: </span><br><span class="line">                <span class="keyword">while</span> nums[i] &lt; x <span class="keyword">and</span> i &lt; j: <span class="comment"># 循环终止时i满足nums[i]&gt;=x或者i==j</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> nums[j] &gt;= x <span class="keyword">and</span> i &lt; j: <span class="comment"># 循环终止时j满足nums[j]&lt;x或者i==j</span></span><br><span class="line">                    j -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> j &gt; i: <span class="comment"># 说明必有nums[i]&gt;=x且nums[j]&lt;x，需要调换二者位置</span></span><br><span class="line">                    nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; x: </span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            nums[i], nums[r] = x, nums[i] </span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">if</span> tinput <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> len(tinput) &lt; k <span class="keyword">or</span> k &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        s, t = <span class="number">0</span>, len(tinput)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            ix = partition(tinput, s, t)</span><br><span class="line">            <span class="keyword">if</span> ix == k <span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">return</span> sorted(tinput[:k])</span><br><span class="line">            <span class="keyword">elif</span> ix &gt; k <span class="number">-1</span>:</span><br><span class="line">                t = ix <span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s = ix + <span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>partition</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指28-数组中出现次数超过一半的数字</title>
    <url>/2019/09/12/algs/arrow4Offer/2019-09-12-28-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
<hr>
<ul>
<li>遍历数组，用字典统计数字的频率，一旦某个数字的频数大于数组长度的一半，则返回该数。</li>
<li>如果遍历数组过程中没有返回，则说明没有数字频数大于数组长度的一半，返回0。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        log = &#123;&#125;</span><br><span class="line">        half = len(numbers)/<span class="number">2.0</span></span><br><span class="line">        <span class="keyword">if</span> half == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> half == <span class="number">0.5</span>:</span><br><span class="line">            <span class="keyword">return</span> numbers[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="keyword">if</span> log.has_key(num):</span><br><span class="line">                log[num] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> log[num] &gt; half:</span><br><span class="line">                    <span class="keyword">return</span> num</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                log[num] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<hr>
<p>用字典的时间效率是O(n)，但空间效率不占有，而空间效率是O(1)的算法是存在的。</p>
<ul>
<li>遍历数组时保存两个值，一个是数组中的一个数字，一个是次数。</li>
<li>每遍历到一个数字，如果该数字与所保存值相等，次数加1；不相等则次数减去1；如果次数已经为0且不相等，则将保存值更新为该数字，次数置为1。</li>
<li>如果存在出现次数超过一半的数字，则必定是最后的保存值。由于是必要条件，所以程序中要确认该值是否真的出现了超过一半的次数，即至少为<code>(len(numbers)&gt;&gt;1)+1</code>。</li>
</ul>
<p>分析原理：数组长度为N，最后的次数值是M，则M&lt;=N，由于次数值一直都是非负数，那么可知有<code>2*(N-M)</code>个数在加减运算中两两抵消掉了。而出现一半的数字肯定不会全被抵消掉。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        log = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="keyword">if</span> num == log[<span class="number">0</span>]:</span><br><span class="line">                log[<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> log[<span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">                    log[<span class="number">0</span>], log[<span class="number">1</span>] =  num, <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    log[<span class="number">1</span>] -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        half = (len(numbers)&gt;&gt;<span class="number">1</span>)+<span class="number">1</span> <span class="comment"># 一半加一</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="keyword">if</span> num == log[<span class="number">0</span>]:</span><br><span class="line">                half -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> half &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> log[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<hr>
<p>partition函数法。</p>
<ul>
<li>快排的partition函数能够以某个数为基准，将数组内元素按大小分为小于该数和大于等于该数两部分。可以用来将数组分成前k个较小值和其余的值两部分，方法是迭代，将partition函数的输入区间向k和拢。</li>
<li>而出现次数超过一半的数，排序之后肯定会在下标<code>len(numbers)&gt;&gt;1</code>上出现，因此用partition函数找到该数，然后检查其是否满足条件即可。</li>
<li>每次迭代使得partition的输出更接近<code>len(numbers)&gt;&gt;1</code>这个下标，直到二者相等。如果有出现次数超过一半的数，则必然是该下标的元素。究竟是不是，也要检查一番才能确定。</li>
<li>注意：虽然partition的输出下标左侧的元素肯定要小于该下标所指的元素，但最终<code>len(numbers)&gt;&gt;1</code>这个下标左侧的元素却是小于等于该下标所指元素。只是由<code>while True</code>循环里对<code>s</code>和<code>t</code>的更新方式导致的。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(nums, l, r)</span>:</span></span><br><span class="line">            x = nums[r]</span><br><span class="line">            i, j = l, r<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; j: </span><br><span class="line">                <span class="keyword">while</span> nums[i] &lt; x <span class="keyword">and</span> i &lt; j: <span class="comment"># 循环终止时i满足nums[i]&gt;=x或者i==j</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> nums[j] &gt;= x <span class="keyword">and</span> i &lt; j: <span class="comment"># 循环终止时j满足nums[j]&lt;x或者i==j</span></span><br><span class="line">                    j -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> j &gt; i: <span class="comment"># 说明必有nums[i]&gt;=x且nums[j]&lt;x，需要调换二者位置</span></span><br><span class="line">                    nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; x: </span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            nums[i], nums[r] = x, nums[i] </span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">checkMoreThanHalf</span><span class="params">(num, numbers)</span>:</span></span><br><span class="line">            half = (len(numbers)&gt;&gt;<span class="number">1</span>)+<span class="number">1</span> <span class="comment"># 一半加一</span></span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">                <span class="keyword">if</span> n == num:</span><br><span class="line">                    half -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> half &lt;= <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(numbers) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        s, t = <span class="number">0</span>, len(numbers)<span class="number">-1</span></span><br><span class="line">        mid = len(numbers)&gt;&gt;<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            ix = partition(numbers, s, t) </span><br><span class="line">            <span class="keyword">if</span> ix &gt; mid:</span><br><span class="line">                t = ix - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> ix &lt; mid: </span><br><span class="line">                s = ix + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        num = numbers[mid]</span><br><span class="line">        <span class="keyword">return</span> num <span class="keyword">if</span> checkMoreThanHalf(num, numbers) <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>partition</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指27-字符串的排列</title>
    <url>/2019/09/12/algs/arrow4Offer/2019-09-12-27-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p>
<p>输入描述:</p>
<blockquote>
<p>输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</p>
</blockquote>
<hr>
<p>递归法求全排列，思路：对字符串a_b_c有</p>
<ul>
<li>Perm(a_b_c)= a_Perm(b_c)+ b_Perm(a_c)+ c_Perm(a_b)，</li>
<li>Perm(b_c)=b_Perm(c)+c_Perm(b)，</li>
<li>Perm(a)=a。</li>
</ul>
<p>其中加号<code>+</code>表示添加到序列组成的列表里。</p>
<p>难点在于字符序列的重复元素会带来冗余排列要如何避免。例如<code>Perm(a_b_b)=a_Perm(b_b)+2b_Perm(a_b)</code>产生了两个<code>b_Perm(a_b)</code>，原因在于先后有两个b被从a_b_b里取出。解决方案：</p>
<ul>
<li>既然原因在于重复的元素先后从序列里取出，那么只要给取出的元素做个记录，再次访问时能够识别出来，跳过即可。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Perm</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(s, str) <span class="keyword">or</span> len(s) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">elif</span> len(s) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> [s]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        r = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">not</span> <span class="keyword">in</span> s[:i]:<span class="comment"># s[:i]是已经取出过的元素，如果s[i]在里面出现过则跳过</span></span><br><span class="line">                myset = [s[i]+child <span class="keyword">for</span> child <span class="keyword">in</span> Perm(s[:i]+s[i+<span class="number">1</span>:])]</span><br><span class="line">                r.extend(myset)</span><br><span class="line">        <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>
<p>上述实现版本有两个不完美的地方：</p>
<ul>
<li>低效的递归</li>
<li>输出的全排列不是字典序的</li>
</ul>
<hr>
<p>根据一个字符串序列，有效的计算其下一个字典序列的方法是存在的。这不但能避免低效的递归，而且能按字典序输出全排列。</p>
<p>计算下一个字典序的方法：</p>
<ul>
<li>从后向前找第一对相邻的递增元素，称前一个为替换数<code>a</code>，其位置为替换点。</li>
<li>再从<code>a</code>的后面找一个比它大的最小元素<code>b</code>，如果有多个元素值与<code>b</code>相等，就选择最右边的那个（其实，<code>b</code>是从后边开始的第一个大于<code>a</code>的元素），交换二者位置。。</li>
<li>将替换点之后（不包括替换点）的右子序列的元素反转。</li>
</ul>
<p>如下版本的代码，接收参数为字符串，是不可变对象，因此把字符串转换为数组之后再操作，最后再变回字符串。有用到冒泡排序将输入转换成其最小字典序。主题部分用了一个循环，从最小字典序依次产生不重复的序列，直到最大字典序。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Perm</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="comment">#arr是字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(arr)</span>:</span></span><br><span class="line">        l = len(arr)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(l<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,l):</span><br><span class="line">                <span class="keyword">if</span> arr[i] &gt; arr[j]:</span><br><span class="line">                    arr[i],arr[j] = arr[j],arr[i]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> isinstance(arr,str):</span><br><span class="line">        arr = [char <span class="keyword">for</span> char <span class="keyword">in</span> arr]</span><br><span class="line">    bubble_sort(arr) <span class="comment"># 得到最小字典序</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> len(arr) == <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line">    result = [<span class="string">''</span>.join(arr)]</span><br><span class="line">    is_next = <span class="literal">True</span> <span class="comment"># 是否还有更大的字典序，用来判断是否结束</span></span><br><span class="line">    <span class="keyword">while</span> is_next:</span><br><span class="line">        is_next = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)<span class="number">-2</span>,<span class="number">0</span><span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[i] &lt; arr[i+<span class="number">1</span>]: <span class="comment"># 找到替换数和替换点</span></span><br><span class="line">                is_next = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(len(arr)<span class="number">-1</span>,i,<span class="number">-1</span>):</span><br><span class="line">                    <span class="keyword">if</span> arr[i] &lt; arr[j]:</span><br><span class="line">                        arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line">                        arr[i+<span class="number">1</span>:] = arr[i+<span class="number">1</span>:][::<span class="number">-1</span>] <span class="comment"># 反转替换点之后的右子序列</span></span><br><span class="line">                        result.append(<span class="string">''</span>.join(arr))</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指26-二叉搜索树与双向链表</title>
    <url>/2019/09/12/algs/arrow4Offer/2019-09-12-26-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<p>如下代码构建了一个二叉搜索树，用于测试用。</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> class TreeNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = None</span><br><span class="line">        self.right = None</span><br><span class="line"></span><br><span class="line">L = &#123;&apos;A&apos;: TreeNode(3), </span><br><span class="line">     &apos;B&apos;: TreeNode(2), </span><br><span class="line">     &apos;C&apos;: TreeNode(6), </span><br><span class="line">     &apos;D&apos;: TreeNode(1), </span><br><span class="line">     &apos;E&apos;: TreeNode(4), </span><br><span class="line">     &apos;F&apos;: TreeNode(8), </span><br><span class="line">     &apos;G&apos;: TreeNode(5), </span><br><span class="line">     &apos;H&apos;: TreeNode(7), </span><br><span class="line">     &apos;I&apos;: TreeNode(9)&#125;</span><br><span class="line"></span><br><span class="line">L[&apos;F&apos;].left, L[&apos;F&apos;].right = L[&apos;H&apos;], L[&apos;I&apos;]</span><br><span class="line">L[&apos;E&apos;].right = L[&apos;G&apos;]</span><br><span class="line">L[&apos;C&apos;].left, L[&apos;C&apos;].right = L[&apos;E&apos;], L[&apos;F&apos;]</span><br><span class="line">L[&apos;A&apos;].left, L[&apos;A&apos;].right = L[&apos;B&apos;], L[&apos;C&apos;]</span><br><span class="line">L[&apos;B&apos;].left = L[&apos;D&apos;]</span><br><span class="line">root = L[&apos;A&apos;]</span><br></pre></td></tr></table></figure></p>
<hr>
<p>递归。</p>
<ul>
<li>函数recur(root)能够把root为根的树编程一个排序的双向链表，root不变。</li>
<li>已有root，根据双向链表的特性，可以很容易得到该双向链表的收尾节点。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 只要中序遍历即可</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Convert</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                recur(root.left)</span><br><span class="line">                lr = root.left</span><br><span class="line">                <span class="keyword">while</span> lr.right:</span><br><span class="line">                    lr = lr.right</span><br><span class="line">                root.left, lr.right = lr, root</span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                recur(root.right)</span><br><span class="line">                rl = root.right</span><br><span class="line">                <span class="keyword">while</span> rl.left:</span><br><span class="line">                    rl = rl.left</span><br><span class="line">                root.right, rl.left = rl,root</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            recur(root)</span><br><span class="line">            <span class="keyword">while</span> root.left:</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<hr>
<p>中序遍历，把节点都存放到一个列表里，然后构建相邻节点之间的双向连接。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 只要中序遍历即可</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Convert</span><span class="params">(self, pRootOfTree)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        logs = set()</span><br><span class="line">        mystack = []</span><br><span class="line">        mylist = []</span><br><span class="line">        node = pRootOfTree</span><br><span class="line">        <span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> id(node) <span class="keyword">not</span> <span class="keyword">in</span> logs:</span><br><span class="line">                logs.add(id(node))</span><br><span class="line">                mystack.append(node)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    node = node.left</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    node = mystack.pop(<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                mylist.append(node)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    node = node.right</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 列表如果不包含元素，则不能用pop否则会出错</span></span><br><span class="line">                    <span class="keyword">if</span> len(mystack) &gt; <span class="number">0</span>:</span><br><span class="line">                        node = mystack.pop(<span class="number">-1</span>)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        node = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> len(mylist) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">elif</span> len(mylist) == <span class="number">1</span>:</span><br><span class="line">            mylist[<span class="number">0</span>].left, mylist[<span class="number">0</span>].right = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">            <span class="keyword">return</span> mylist[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mylist[<span class="number">0</span>].left = <span class="literal">None</span></span><br><span class="line">            mylist[<span class="number">0</span>].right = mylist[<span class="number">1</span>]</span><br><span class="line">            mylist[<span class="number">-1</span>].right = <span class="literal">None</span></span><br><span class="line">            mylist[<span class="number">-1</span>].left = mylist[<span class="number">-2</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(mylist)<span class="number">-1</span>):</span><br><span class="line">                mylist[i].left = mylist[i<span class="number">-1</span>]</span><br><span class="line">                mylist[i].right = mylist[i+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">return</span> mylist[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指25-复杂链表的复制</title>
    <url>/2019/09/12/algs/arrow4Offer/2019-09-12-25-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p>
<hr>
<p>分解成如下三步：</p>
<ul>
<li>复制主链表节点。将<code>n1——n2——n3——n4——NULL</code>变成<code>n1——m1——n2——m2——n3——m3——n4——m4———NULL</code>。</li>
<li>复制兄弟连接。如果ni有指向nj的兄弟连接，则通过<code>ni.next.random = ni.random.next</code>建立<code>mi</code>到<code>mj</code>的连接。</li>
<li>分离n节点和m节点，得到原链表<code>n1——n2——n3——n4——NULL</code>和复制链表<code>m1——m2——m3——m4——NULL</code>，兄弟链接在两个链表的节点之间无交叉，故与分离操作无关。通过<code>p.next.next, p.next = p.next.next.next, p.next.next</code>来实现，该语句避免使用中间变量。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># class RandomListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.label = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="comment">#         self.random = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回 RandomListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Clone</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> pHead <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 复制主链表，不考虑兄弟链接。兄弟链接的构建需要所有节点都已经存在，因此在之后的一步处理。</span></span><br><span class="line">        p = pHead</span><br><span class="line">        <span class="keyword">while</span> p <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            node = RandomListNode(p.label)</span><br><span class="line">            node.next = p.next</span><br><span class="line">            p.next = node</span><br><span class="line">            p = node.next</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 复制兄弟链接</span></span><br><span class="line">        head = pHead.next</span><br><span class="line">        p = pHead</span><br><span class="line">        <span class="keyword">while</span> p <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> p.random <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                p.next.random = p.random.next</span><br><span class="line">            p = p.next.next</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将两个链表切割</span></span><br><span class="line">        p = pHead</span><br><span class="line">        <span class="keyword">while</span> p.next.next:</span><br><span class="line">            p.next.next, p.next = p.next.next.next, p.next.next</span><br><span class="line">            p = p.next</span><br><span class="line">        p.next = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指24-二叉树中和为某一值的路径</title>
    <url>/2019/09/12/algs/arrow4Offer/2019-09-12-24-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。返回值的形式是路径节点值的列表集，按节点数量从大到小排列。</p>
<hr>
<ul>
<li>思路与八皇后问题相似，下面的代码用了循环和递归，可以轻易地修改成尾递归版本和完全循环的版本。</li>
<li>定义递归函数<code>recur(root, number, k, path)</code>，参数里root是要访问的节点, path的前k个是路径的上游节点。如果有满足条件的路径，则返回路径为元素（也是列表）的列表；如果没有，则返回空列表。
<ul>
<li>参数root是叶节而且路径满足条件时，要避免调用两次<code>recur(None, number, k, path)</code>，不然满足条件的路径会被重复计入。以此语句应对：<code>if not root.left and not root.right: return recur(None, number-root.val, k+1, path)</code></li>
</ul></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回二维列表，内部每个列表表示找到的路径</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindPath</span><span class="params">(self, root, expectNumber)</span>:</span>        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(root, number, k, path)</span>:</span> <span class="comment"># </span></span><br><span class="line">            <span class="comment"># 要访问root, path的前k个是路径的上游节点</span></span><br><span class="line">            <span class="comment"># 如果有满足条件的路径，则返回列表的列表；如果没有，则返回空列表。</span></span><br><span class="line">            <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> number == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">if</span> k &lt;= <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">return</span> []</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">return</span> [path[:k]]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> []</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> len(path) == k:</span><br><span class="line">                    path.append(root.val)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    path[k] = root.val</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                    <span class="keyword">return</span> recur(<span class="literal">None</span>, number-root.val, k+<span class="number">1</span>, path)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res= recur(root.left, number-root.val, k+<span class="number">1</span>, path)</span><br><span class="line">                    res.extend(recur(root.right, number-root.val, k+<span class="number">1</span>, path))</span><br><span class="line">                    <span class="keyword">return</span> res</span><br><span class="line">        result = recur(root, expectNumber, <span class="number">0</span>, [])</span><br><span class="line">        result.sort(key=len, reverse=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指23-二叉搜索树的后序遍历序列</title>
    <url>/2019/09/12/algs/arrow4Offer/2019-09-12-23-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p>
<blockquote>
<p>二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）。它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。</p>
</blockquote>
<hr>
<p>用了递归思想</p>
<ul>
<li>后序遍历长度为n的列表，前面n-1个元素可以分为相邻的两个子序列，前子序列的所有元素不大于第n个元素，后子序列所有元素不小于第n个元素。</li>
<li>前后两个子序列也是二叉搜索树的后序遍历结果。因此可以用递归。</li>
<li>边界：列表长度小于等于1的时候，认为该列表是二叉搜索树的后序遍历结果。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">VerifySquenceOfBST</span><span class="params">(self, sequence)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">judge</span><span class="params">(sequence)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(sequence) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            mid = sequence[<span class="number">-1</span>]</span><br><span class="line">            idx = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> sequence[:<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">if</span> i &gt; mid:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                idx += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> sequence[idx:<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">if</span> i &lt; mid:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> judge(sequence[:idx]) <span class="keyword">and</span> judge(sequence[idx:<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(sequence) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> judge(sequence)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指22-从上往下打印二叉树</title>
    <url>/2019/09/12/algs/arrow4Offer/2019-09-12-22-%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<hr>
<ul>
<li>用到队列。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回从上到下每个节点值列表，例：[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintFromTopToBottom</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 虽然题目中说是打印，其实仍然是要求返回列表</span></span><br><span class="line">        s = []</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        myqueue = [root]</span><br><span class="line">        <span class="keyword">while</span> len(myqueue) &gt; <span class="number">0</span>:</span><br><span class="line">            node = myqueue.pop(<span class="number">0</span>)</span><br><span class="line">            s.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                myqueue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                myqueue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指21-栈的压入、弹出序列</title>
    <url>/2019/09/12/algs/arrow4Offer/2019-09-12-21-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。</p>
<p>例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
<hr>
<p>思路如下，pushV上的指针左侧的子序列，其实模拟的是栈的变化：</p>
<ul>
<li>对出栈序列popV的第一个元素，用一个指向pushV的指针从左向右找到第一个相等的元素，并将其pushV中删除，并将指针左移一位。</li>
<li>然后对popV的下一个元素，用指针继续向右查找，找到想等元素之后，执行与第一步相同的工作。直到pushV的指针超出范围或者popV的元素都被处理完。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsPopOrder</span><span class="params">(self, pushV, popV)</span>:</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> len(popV) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 注意循环条件i+1&lt;=len(pushV)不可少，不然弹出序列某元素不在入栈序列中时，i会往上累加去产生死循环</span></span><br><span class="line">            <span class="keyword">while</span> popV[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> pushV[:i+<span class="number">1</span>] <span class="keyword">and</span> i+<span class="number">1</span>&lt;=len(pushV): </span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 上一句的while循环的终止条件有两个,分别是popV[0] in pushV[:i+1] 和 i+1&gt;len(pushV)。</span></span><br><span class="line">            <span class="comment"># 如果后者成立，则说明popV的元素在pushV中找不到，要返回False</span></span><br><span class="line">            <span class="keyword">if</span> i+<span class="number">1</span> &gt; len(pushV):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> popV.pop(<span class="number">0</span>) != pushV.pop(i): </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>进一步分析：</p>
<ul>
<li>如果压入序列pushV里有两个相等元素，而弹出序列popV与pushV对应也就有同样的两个相等元素，那么无法判断彼此元素的对应关系。</li>
<li>删除元素时pushV和popV都有操作，栈顶元素和弹出元素一定要有相等关系<code>popV.pop(0) != pushV.pop(i)</code>，不然后边肯定对不上。因此该相等关系的判断，不影响最终的判断结果。</li>
</ul>
<hr>
<p>如下代码的思想和上面版本一样，只是更具体化了，直接构建了个栈。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsPopOrder</span><span class="params">(self,pushV, popV)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment">#边界情况</span></span><br><span class="line">        <span class="keyword">if</span> len(pushV) == <span class="number">0</span> <span class="keyword">or</span> len(pushV) != len(popV):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">         </span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> pushV:</span><br><span class="line">            stack.append(num)</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">if</span> popV[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> stack: <span class="comment">#如果第一个弹出的元素不在栈里，则继续压入栈</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 如果第一个弹出的元素在栈里，则分为是否在栈顶两种情况</span></span><br><span class="line">                <span class="keyword">if</span> popV[<span class="number">0</span>] != stack[<span class="number">-1</span>]:<span class="comment"># 不在栈顶，肯定错误</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>: </span><br><span class="line">                    <span class="comment"># 可能会有多个出栈的情况</span></span><br><span class="line">                    <span class="keyword">while</span> len(popV) &gt; <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">if</span> popV[<span class="number">0</span>] != stack[<span class="number">-1</span>]:</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            <span class="keyword">del</span> stack[<span class="number">-1</span>]</span><br><span class="line">                            <span class="keyword">del</span> popV[<span class="number">0</span>]</span><br><span class="line">         </span><br><span class="line">        <span class="comment"># 遍历了一遍pushV之后，如果popV不为空，则失败</span></span><br><span class="line">        <span class="keyword">if</span> len(popV) == <span class="number">0</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指20-包含min函数的栈</title>
    <url>/2019/09/12/algs/arrow4Offer/2019-09-12-20-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O(1)）。</p>
<hr>
<ul>
<li>两个元素一一对应的栈，在push和pop操作中同进同退：一个主栈，用来作为存储元素的栈；一个辅栈，用来存储最小元素，其每个元素表示主栈对应元素自身和之前元素里的最小值。
<ul>
<li>计算栈中最小元素时，只要返回辅栈栈顶元素即可。</li>
</ul></li>
<li>辅栈的构建
<ul>
<li>主栈push元素时，检查该元素与辅栈栈顶元素的大小关系，如果较小则也将该值push到辅栈，否则将辅栈栈顶元素复制一份push到辅栈。</li>
<li>主栈pop元素时，辅栈也pop元素。</li>
</ul></li>
<li>思路与<code>64-滑动窗口的最大值</code>有异曲同工之妙。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.minstack = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        self.stack.append(num)</span><br><span class="line">        <span class="keyword">if</span> len(self.minstack) == <span class="number">0</span>:</span><br><span class="line">            self.minstack.append(num)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.minstack.append(min(self.minstack[<span class="number">-1</span>], num))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.minstack.pop(<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.stack.pop(<span class="number">-1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.minstack[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指19-顺时针打印矩阵</title>
    <url>/2019/09/12/algs/arrow4Offer/2019-09-12-19-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
<hr>
<p>M*N 的矩阵A，第i（0,1，...）圈 的四个坐标序列分别是A[i][i..N-2-i] 和A[i..M-2-i][N-1-i]和A[M-1-i][N-1-i..i+1]和A[M-1-i..i+1][i]，切记是闭区间。 对于每个序列，如果不存在则打印停止，其不存在的条件分别是 i&gt;N-2-i,i&gt;M-2-i,N-1-i&lt;i+1,M-1-i&lt;i+1。以第一圈为例来说明对每一圈的打印规则，是依次打印N-1个、M-1个、N-1个和M-1个。</p>
<p>然而按上述思路实现的代码却不可行，会漏掉数字，比如对于<span class="math inline">\(3\times 3\)</span>或者<span class="math inline">\(3\times 5\)</span>的矩阵。经分析知是四个坐标序列有时候会无法捕捉到某个数字。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># matrix类型为二维列表，需要返回列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printMatrix</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> matrix <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> len(matrix) == <span class="number">0</span> <span class="keyword">or</span> len(matrix[<span class="number">0</span>]) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        M,N = len(matrix),len(matrix[<span class="number">0</span>])</span><br><span class="line">        i = <span class="number">-1</span></span><br><span class="line">        numlist = []</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i &lt;= N<span class="number">-2</span>-i:</span><br><span class="line">                numlist.extend(matrix[i][i:N<span class="number">-2</span>-i+<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> len(numlist) == M*N:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> i &lt;= M<span class="number">-2</span>-i:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(i,M<span class="number">-2</span>-i+<span class="number">1</span>): <span class="comment"># 二维数组不能对同列不同行的元素进行切片，所以需要挨个访问每个元素</span></span><br><span class="line">                    numlist.append(matrix[j][N<span class="number">-1</span>-i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> len(numlist) == M*N:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> N<span class="number">-1</span>-i&gt;=i+<span class="number">1</span>:</span><br><span class="line">                numlist.extend(matrix[M<span class="number">-1</span>-i][N<span class="number">-1</span>-i:i+<span class="number">1</span><span class="number">-1</span>:<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> len(numlist) == M*N:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> M<span class="number">-1</span>-i &gt;= i+<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(M<span class="number">-1</span>-i,i+<span class="number">1</span><span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                    numlist.append(matrix[j][i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> len(numlist) == M*N:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> numlist</span><br></pre></td></tr></table></figure>
<hr>
<p>抓住三点，一个是首先计算出打印的圈数是<code>(min(M,N)+1)//2</code>，其次设定打印停止条件即当已经打印的数字的数量等于矩阵包含的数字个数<code>M*N</code>时，最后每圈打印的规则，依次打印N个、M-1个、N-1个、M-2个，有点贪心算法的意味。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># matrix类型为二维列表，需要返回列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printMatrix</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        M,N = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> M &lt; <span class="number">1</span> <span class="keyword">or</span> N &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">elif</span> M == <span class="number">1</span> <span class="keyword">and</span> N == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [matrix[<span class="number">0</span>][<span class="number">0</span>]]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> o <span class="keyword">in</span> range((min(M,N)+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>):</span><br><span class="line">            res.extend([matrix[o][n] <span class="keyword">for</span> n <span class="keyword">in</span> range(o, N-o)])</span><br><span class="line">            <span class="keyword">if</span> len(res) == M*N: <span class="comment"># 判断是否已经打印结束</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            res.extend([matrix[m][N<span class="number">-1</span>-o] <span class="keyword">for</span> m <span class="keyword">in</span> range(o+<span class="number">1</span>, M-o)])</span><br><span class="line">            <span class="keyword">if</span> len(res) == M*N:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            res.extend([matrix[M<span class="number">-1</span>-o][n] <span class="keyword">for</span> n <span class="keyword">in</span> range(o, N-o<span class="number">-1</span>)[::<span class="number">-1</span>]])</span><br><span class="line">            <span class="keyword">if</span> len(res) == M*N:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            res.extend([matrix[m][o] <span class="keyword">for</span> m <span class="keyword">in</span> range(o+<span class="number">1</span>, M-o<span class="number">-1</span>)[::<span class="number">-1</span>]])</span><br><span class="line">            <span class="keyword">if</span> len(res) == M*N:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>注意事项： + 上述<code>M,N = len(matrix), len(matrix[0])</code>的写法不完善，会有matrix或者matrix[0]不是列表的情况，会出现异常。改成 <code>if matrix is None or len(matrix) == 0 or len(matrix[0]) == 0:return None</code>，根据短路运算规则，可以避免程序异常。</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指18-二叉树的镜像</title>
    <url>/2019/09/12/algs/arrow4Offer/2019-09-12-18-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>操作给定的二叉树，将其变换为源二叉树的镜像。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入描述:</span><br><span class="line">二叉树的镜像定义：源二叉树 </span><br><span class="line">    	    8</span><br><span class="line">    	   /  \</span><br><span class="line">    	  6   10</span><br><span class="line">    	 / \  / \</span><br><span class="line">    	5  7 9 11</span><br><span class="line">    	镜像二叉树</span><br><span class="line">    	    8</span><br><span class="line">    	   /  \</span><br><span class="line">    	  10   6</span><br><span class="line">    	 / \  / \</span><br><span class="line">    	11 9 7  5</span><br></pre></td></tr></table></figure>
<h4 id="破坏了原二叉树">破坏了原二叉树</h4>
<hr>
<p>用递归。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Mirror</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">None</span>:</span><br><span class="line">        root.left,root.right = root.right,root.left</span><br><span class="line">        Mirror(root.left)</span><br><span class="line">        Mirror(root.right)</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<hr>
<p>不用递归。</p>
<ul>
<li>重要的是循环体有对父子关系的描述，即<code>node.left, node.right = node.right, node.left</code>。</li>
<li>用队列或者栈，都行。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回镜像树的根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Mirror</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        myqueue = [root]</span><br><span class="line">        <span class="keyword">while</span> len(myqueue) &gt; <span class="number">0</span>:</span><br><span class="line">            node = myqueue.pop(<span class="number">0</span>)</span><br><span class="line">            node.left, node.right = node.right, node.left</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                myqueue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                myqueue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h4 id="不破坏原二叉树返回新建的二叉树">不破坏原二叉树，返回新建的二叉树</h4>
<ul>
<li>递归。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copyTreeMirror</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> root </span><br><span class="line">    rootC = TreeNode(root.val)</span><br><span class="line">    rootC.left, rootC.right = copyTreeMirror(root.right), copyTreeMirror(root.left)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> rootC</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指17-树的子结构</title>
    <url>/2019/09/12/algs/arrow4Offer/2019-09-12-17-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
<hr>
<h4 id="非递归版本">非递归版本</h4>
<ul>
<li>首先遍历A，对其每个节点node用check函数判断其能否对应B的根节点rB，并且B是A的子结构。</li>
<li>check函数，遍历B，并以B为标准从rB和node核对，B有的结构A也要有，对应节点的值也要相等。</li>
<li>一旦核对不上，返回False。</li>
<li>直到B遍历结束，返回True。</li>
<li>至于遍历顺序是先根、后根、中根（递归，或者用栈），或者层次遍历（用到了队列），都无所谓。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">HasSubtree</span><span class="params">(self, pRoot1, pRoot2)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(node, pRoot2)</span>:</span></span><br><span class="line">            <span class="comment"># 检查pRoot1的node节点作为起点的树，</span></span><br><span class="line">            <span class="comment"># 是否包含了pRoot2,并且node节点对应pRoot2节点</span></span><br><span class="line">            <span class="comment"># 注意node和pRoot2地位不对等，以pRoot2为准</span></span><br><span class="line">            q1, q2 = [node], [pRoot2]</span><br><span class="line">            <span class="keyword">while</span> len(q2) &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> len(q1) &lt;= <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                node1, node2 = q1.pop(<span class="number">0</span>), q2.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> node1.val != node2.val:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">if</span> node2.left:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> node1.left:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                    q1.append(node1.left)</span><br><span class="line">                    q2.append(node2.left)</span><br><span class="line">                <span class="keyword">if</span> node2.right:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> node1.right:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                    q1.append(node1.right)</span><br><span class="line">                    q2.append(node2.right)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">if</span> pRoot2 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> pRoot1 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        q = [pRoot1]</span><br><span class="line">        <span class="keyword">while</span> len(q) &gt; <span class="number">0</span>:</span><br><span class="line">            node = q.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                q.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                q.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> check(node, pRoot2):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="递归版本">递归版本</h4>
<ul>
<li>巧用逻辑短路规则</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">HasSubtree</span><span class="params">(p1, p2)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(r1,r2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> r2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> r1 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> r1.val == r2.val <span class="keyword">and</span> check(r1.left, r2.left) <span class="keyword">and</span> check(r1.right, r2.right)</span><br><span class="line">    <span class="keyword">if</span> p1 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> p2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> check(p1, p2) <span class="keyword">or</span> HasSubtree(p1.left, p2) <span class="keyword">or</span> HasSubtree(p1.right, p2)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指16-合并两个排序的链表</title>
    <url>/2019/09/12/algs/arrow4Offer/2019-09-12-16-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<hr>
<ul>
<li>首先一个辅助节点ListNode(0)</li>
<li>以及，两个指针，一个用来返回合成后的链表的表头，一个用来辅助合成链表。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回合并后列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Merge</span><span class="params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        pTemp = ListNode(<span class="number">0</span>)</span><br><span class="line">        p = pTemp</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> pHead1:</span><br><span class="line">                pTemp.next = pHead2</span><br><span class="line">                <span class="keyword">return</span> p.next</span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> pHead2:</span><br><span class="line">                pTemp.next = pHead1</span><br><span class="line">                <span class="keyword">return</span> p.next</span><br><span class="line">            <span class="keyword">if</span> pHead1.val &lt; pHead2.val:</span><br><span class="line">                pTemp.next = pHead1</span><br><span class="line">                pTemp = pHead1</span><br><span class="line">                pHead1 = pHead1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pTemp.next = pHead2</span><br><span class="line">                pTemp = pHead2</span><br><span class="line">                pHead2 = pHead2.next</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指15-反转链表</title>
    <url>/2019/09/12/algs/arrow4Offer/2019-09-12-15-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>输入一个链表，反转链表后，输出新链表的表头。</p>
<p>链表的准备，构建四个节点的单链表，表头是phead：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Node:</span><br><span class="line">    def __init__(self, val):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.next = None</span><br><span class="line"></span><br><span class="line">nodeList = [Node(1),Node(2),Node(3),Node(4)]</span><br><span class="line">phead = nodeList[0]</span><br><span class="line">for i in range(len(nodeList)-1):</span><br><span class="line">    nodeList[i].next = nodeList[i+1]</span><br><span class="line">p = phead</span><br><span class="line">while p is not None:</span><br><span class="line">    p = p.next</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="辅助列表">辅助列表</h4>
<p>遍历链表，用一个列表存储遍历到的所有节点，然后从后往前新建反转版本的链表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回ListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseList</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> pHead <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> pHead.next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> pHead</span><br><span class="line">            </span><br><span class="line">        mylist = []</span><br><span class="line">        <span class="keyword">while</span> pHead <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            mylist.append(pHead)</span><br><span class="line">            pHead = pHead.next</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(mylist)):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                mylist[i].next = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                mylist[i].next = mylist[i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> mylist[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="递归的方法翻转链表">递归的方法翻转链表</h4>
<p>记输入链表是L0=phead+L1。既然用递归，则函数的输入是L0的表头phead，输出是新链表的表头，即L0的尾节点。内部调用自身的语句的输入应该是L1，其输出是L1的尾结点，也是L0的尾结点，新的表尾也就是L0的表头指向None。可知新链表的表头从递归的最深层，一路传送到最上层。亦可知，之后需要处理链表与子链表的衔接，即<code>phead.next.next = phead; phead.next = None</code>，L1的原表头即phead.next要指向phead。：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseL</span><span class="params">(phead)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> phead <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> phead.next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> phead</span><br><span class="line">    </span><br><span class="line">    node = reverseL(phead.next)</span><br><span class="line">    phead.next.next = phead</span><br><span class="line">    phead.next = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="非递归的方法翻转链表">非递归的方法翻转链表</h4>
<ul>
<li>递归和非递归两种翻转方法，对输入的检测都是一样的逻辑<code>if not phead or not phead.next: return phead</code></li>
<li>每次循环，都要拿到前两个节点的指针p和q，循环以q.next的存在性判断是否终止</li>
<li>更新p,q和连接时需要一个临时节点指针</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseL</span><span class="params">(phead)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> phead <span class="keyword">or</span> <span class="keyword">not</span> phead.next:</span><br><span class="line">        <span class="keyword">return</span> phead</span><br><span class="line">    p, q = phead, phead.next <span class="comment"># 每次循环，要有前两个节点的指针</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> q.next:</span><br><span class="line">            temp = q <span class="comment"># 临时变量</span></span><br><span class="line">            q = q.next</span><br><span class="line">            temp.next = p <span class="comment">#</span></span><br><span class="line">            p = temp</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            q.next = p</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    phead.next = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> q</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指14-链表中倒数第k个结点</title>
    <url>/2019/09/12/algs/arrow4Offer/2019-09-12-14-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>输入一个链表，输出该链表中倒数第k个结点。</p>
<hr>
<h4 id="辅助指针">辅助指针</h4>
<p>从头到尾遍历链表，辅助指针总是指向当前访问节点的之前的第k个节点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindKthToTail</span><span class="params">(self, head, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> k &lt; <span class="number">1</span> <span class="keyword">or</span> head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        node_k = head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, k):</span><br><span class="line">            head = head.next</span><br><span class="line">            <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> head.next <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            head = head.next</span><br><span class="line">            node_k = node_k.next</span><br><span class="line">        <span class="keyword">return</span> node_k</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指13-调整数组顺序使奇数位于偶数前面</title>
    <url>/2019/09/12/algs/arrow4Offer/2019-09-12-13-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<hr>
<h4 id="辅助数组法">辅助数组法</h4>
<p>遍历一次数组，将其中的奇数和偶数分别摘出来放在两个辅助数组里，再将辅助数组合并。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reOrderArray</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        odds = []</span><br><span class="line">        evens = []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> array:</span><br><span class="line">            <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                odds.append(num)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                evens.append(num)</span><br><span class="line">        <span class="keyword">return</span> odds+evens</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指12-数值的整数次方</title>
    <url>/2019/09/12/algs/arrow4Offer/2019-09-12-12-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>
<hr>
<ul>
<li>负幂转为正幂，便于操作。方法：对于a的b次幂<code>a**b</code>，如果b&lt;0，则<code>a**b</code>等价于<code>(1.0/a)**(-b)</code>。</li>
<li>提高效率，有公式：<code>a**(2b)=(a**b)**2, a**(2b+1)=a*(a**b)**2</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Power</span><span class="params">(self, base, exponent)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">pr</span><span class="params">(base, expo)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> expo == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> expo &amp; <span class="number">1</span> == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> base*pr(base, expo&gt;&gt;<span class="number">1</span>)**<span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> pr(base, expo&gt;&gt;<span class="number">1</span>)**<span class="number">2</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> exponent &lt; <span class="number">0</span>:</span><br><span class="line">            base = <span class="number">1.0</span>/base</span><br><span class="line">            exponent = -exponent</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pr(base, exponent)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指11-二进制中1的个数</title>
    <url>/2019/09/12/algs/arrow4Offer/2019-09-12-11-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<ul>
<li>整型数占4个字节</li>
<li>负数的补码，等于其相反数的所有二进制位取反，然后加1。</li>
</ul>
<hr>
<p>位移运算子特性：</p>
<ul>
<li>负数的补码最高位1，右移则在最高位补1而不是0。因此负数时要限定位移运算子使用次数。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        bits = <span class="number">32</span></span><br><span class="line">        <span class="keyword">while</span> bits &gt; <span class="number">0</span>:</span><br><span class="line">            bits -= <span class="number">1</span></span><br><span class="line">            count += n&amp;<span class="number">1</span></span><br><span class="line">            n = n&gt;&gt;<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<hr>
<p>比较笨，但是对理解原码和补码很有用处。</p>
<ul>
<li>非负数比较简单，循环除以2直到除尽，累加每轮循环之前2的余数。</li>
<li>负数的话，用长度为32的数组模拟其相反数的各个二进制位，然后各个二进制位取反，然后加1，最后统计这个数组里1的个数。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> n &gt;= <span class="number">0</span>:</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">                count += n % <span class="number">2</span></span><br><span class="line">                n = n &gt;&gt; <span class="number">1</span> <span class="comment">#等价于 n=int(n/2)</span></span><br><span class="line">            <span class="keyword">return</span> count</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mylist = [<span class="number">0</span>]*<span class="number">32</span></span><br><span class="line">            i = <span class="number">0</span></span><br><span class="line">            n = -n</span><br><span class="line">            <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">                mylist[i] = n &amp; <span class="number">1</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                n = n &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">                mylist[i] = <span class="number">1</span>-mylist[i]</span><br><span class="line"></span><br><span class="line">            toplus = <span class="number">1</span></span><br><span class="line">            i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">                <span class="keyword">if</span> toplus == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> mylist[i] == <span class="number">0</span>:</span><br><span class="line">                    mylist[i] = <span class="number">1</span></span><br><span class="line">                    toplus = <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    mylist[i] = <span class="number">0</span></span><br><span class="line">                    toplus = <span class="number">1</span></span><br><span class="line">            count = sum(mylist)</span><br><span class="line">            <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<hr>
<p>一个性质：</p>
<ul>
<li>把一个整数减去1，在和原整数做与运算，会把该整数二进制的最右边一个1变成0。</li>
<li>用与运算的结果替换掉原整数，可以再次进行上述操作。而一个整数的二进制有多少个1，就可以进行多少次这样的操作，使得与运算结果为0。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n != <span class="number">0</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            n &amp;= n<span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指10-矩形覆盖</title>
    <url>/2019/09/12/algs/arrow4Offer/2019-09-12-10-%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>我们可以用<code>2*1</code>的小矩形横着或者竖着去覆盖更大的矩形。请问用n个<code>2*1</code>的小矩形无重叠地覆盖一个<code>2*n</code>的大矩形，总共有多少种方法？</p>
<hr>
<ul>
<li>按第一个小矩形靠近一端的摆放方式，可以分为互斥且互补的两个空间：
<ul>
<li>横放，有F(n-2)种方法</li>
<li>竖放，有F(n-1)种方法</li>
</ul></li>
<li>因此有F(n) = F(n-1)+F(n-2)。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rectCover</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> number &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> number == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> number == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 教训：能用循环就不要用递归，防止栈溢出</span></span><br><span class="line">        a, b = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">3</span>, number+<span class="number">1</span>):</span><br><span class="line">            a, b = b, a + b</span><br><span class="line">        <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指09-变态跳台阶</title>
    <url>/2019/09/12/algs/arrow4Offer/2019-09-12-09-%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<hr>
<p>设n级的台阶的跳法数表示为F(n)</p>
<ul>
<li>按第一次跳的台阶数，可以将跳法空间分为互斥且互补的n个空间：
<ul>
<li>第一次跳1个台阶，跳法有F(n-1)</li>
<li>第一次跳2个台阶，跳法有F(n-2)</li>
<li>...</li>
<li>第一次跳n-1个台阶，跳法有F(1)</li>
<li>第一次跳n个台阶，跳法有1</li>
</ul></li>
<li>因此F(n) = F(n-1)+F(n-2)+...+F(1)+1</li>
<li>进而可得F(n)=2F(n-1)，其中F(1) = 1</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloorII</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> number == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> number == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>*self.jumpFloorII(number<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指08-跳台阶</title>
    <url>/2019/09/12/algs/arrow4Offer/2019-09-12-08-%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
<hr>
<p>设n级的台阶的跳法数表示为F(n)</p>
<ul>
<li>按第一次跳的台阶数，可以将跳法空间分为互斥且互补的两个空间
<ul>
<li>第一次跳1级台阶，剩余的跳法有F(n-1)</li>
<li>第二次跳2级台阶，剩余的跳法有F(n-2)</li>
</ul></li>
<li>因此有递归公式F(n) = F(n-1)+F(n-2)，其中F(1) = 1，F(2) = 2</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloor</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        a, b = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> number:</span><br><span class="line">            a, b = a + b, a</span><br><span class="line">            number -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指07-斐波那契数列</title>
    <url>/2019/09/12/algs/arrow4Offer/2019-09-12-07-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。 n&lt;=39</p>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Fibonacci</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">            a, b = b, a+b</span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指06-旋转数组的最小数字</title>
    <url>/2019/09/12/algs/arrow4Offer/2019-09-12-06-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。</p>
<p>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<hr>
<ul>
<li>最小值左右的子序列都是递增的，可用二分查找。</li>
<li>通过画出旋转后的数组大小的增长曲线，很容易看出二分点在左子序列还是在右子序列。</li>
<li>某次迭代时元素比较少时，比如二分点是查询区间的左端，也就是只剩两个元素，可以直接给出结果。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray</span><span class="params">(self, rotateArray)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(rotateArray) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        i, j = <span class="number">0</span>, len(rotateArray)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            mid = (i+j)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> i == mid:</span><br><span class="line">                <span class="keyword">return</span> min(rotateArray[i:j+<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> rotateArray[mid] &lt;= rotateArray[j] <span class="keyword">and</span>  rotateArray[mid] &lt;= rotateArray[i]:</span><br><span class="line">                j = mid</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> rotateArray[mid] &gt;= rotateArray[j] <span class="keyword">and</span>  rotateArray[mid] &gt;= rotateArray[i]:</span><br><span class="line">                i = mid</span><br><span class="line">        <span class="keyword">return</span> rotateArray[i]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指05-用两个栈实现队列</title>
    <url>/2019/09/12/algs/arrow4Offer/2019-09-12-05-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stack = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.stack.append(x)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(self.stack) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        val = self.stack[<span class="number">-1</span>]</span><br><span class="line">        self.stack = self.stack[:<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.stack)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stack1 = MyStack()</span><br><span class="line">        self.stack2 = MyStack()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.stack1.push(node)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># return xx</span></span><br><span class="line">        <span class="keyword">while</span> self.stack1.length() &gt; <span class="number">0</span>:</span><br><span class="line">            self.stack2.push(self.stack1.pop())</span><br><span class="line">        val = self.stack2.pop()</span><br><span class="line">        <span class="keyword">while</span> self.stack2.length() &gt; <span class="number">0</span>:</span><br><span class="line">            self.stack1.push(self.stack2.pop())</span><br><span class="line">        <span class="keyword">return</span> val</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指04-重建二叉树</title>
    <url>/2019/09/12/algs/arrow4Offer/2019-09-12-04-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<hr>
<ul>
<li>可以唯一确定一棵树的遍历组合是<code>先序和中序</code>和<code>后续和中序</code>；而<code>先序和后续</code>不能唯一确定一棵树。</li>
</ul>
<p>思路：</p>
<ul>
<li>先由先根序列的第一个字符将中根序列分为左右两个子序列，该字符为根节点，左序列是左子树的中根遍历序列，右序列是右子树的中根遍历序列。</li>
<li>由左序列和左序列里字符在先根序列中的先后序列，可以用递归的方式得到左子树；同样的方式可以获得右子树。</li>
<li>一个特性：深度优先遍历里，左子树和右子树的打印序列不会有交叉。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rebuild</span><span class="params">(self, pre, tin)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(pre) != len(tin) <span class="keyword">or</span> pre <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> len(pre) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root = TreeNode(pre[<span class="number">0</span>])</span><br><span class="line">        mid = tin.index(pre[<span class="number">0</span>])</span><br><span class="line">        root.left = self.rebuild(pre[<span class="number">1</span>:mid+<span class="number">1</span>], tin[:mid])</span><br><span class="line">        root.right = self.rebuild(pre[mid+<span class="number">1</span>:], tin[mid + <span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指03-从尾到头打印链表</title>
    <url>/2019/09/12/algs/arrow4Offer/2019-09-12-03-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p>
<hr>
<p>用栈，从表头遍历到表尾，依次将值压入栈。遍历结束，将值一个个出栈，顺序正好是与链表中相反。 如下代码用列表存放值，最后将列表首位对调，与栈的用法相通。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回从尾部到头部的列表值序列，例如[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span><span class="params">(self, listNode)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        mylist = []</span><br><span class="line">        <span class="keyword">while</span> listNode <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            mylist.append(listNode.val)</span><br><span class="line">            listNode = listNode.next</span><br><span class="line">        <span class="keyword">return</span> mylist[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指02-替换空格</title>
    <url>/2019/09/12/algs/arrow4Offer/2019-09-12-02-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p>
<p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s 源字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        temp = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] != <span class="string">' '</span>:</span><br><span class="line">                temp += s[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temp += <span class="string">'%20'</span></span><br><span class="line">        <span class="keyword">return</span> temp</span><br></pre></td></tr></table></figure>
<hr>
<p>c语言的字符串与python中不同，用指针可以更改任意元素，而且其占用字节数可能会有冗余。比如字符串内容是'hello再加上末尾的标志位，至少需要6个字节存储该字符串，然而可能会占用10个字节。如果该字符串里只有一个空格，那么只需要该空格之后的字符由后向前顺序后移2个位，然后把空格替换为<code>%20</code>多占2个字节，仍然没有超过原字符串空间。具体的，先统计空格总数，然后从后往前遍历源字符串的各个字符：</p>
<ul>
<li>非空格，下标i，前面有sc个空格，后移之后下标是i+2*sc。</li>
<li>空格，下标i，也就是第sc个空格，下标<code>i+2*sc-2</code>、<code>i+2*sc-1</code>和<code>i+2*sc</code>变成'%20'。</li>
<li>直到前面无空格即sc=0。</li>
</ul>
<p>按照上述思路实现的字符串替换代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s 源字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        ln = len(s)</span><br><span class="line">        sc = <span class="number">0</span> <span class="comment"># space count</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">' '</span> == c:</span><br><span class="line">                sc += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> sc == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        s = [s[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(ln)]</span><br><span class="line">        s.extend([<span class="string">' '</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>*sc)])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(ln<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> sc == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">' '</span>:</span><br><span class="line">                s[i+<span class="number">2</span>*sc<span class="number">-2</span>], s[i+<span class="number">2</span>*sc<span class="number">-1</span>], s[i+<span class="number">2</span>*sc] = <span class="string">'%'</span>, <span class="string">'2'</span>, <span class="string">'0'</span></span><br><span class="line">                sc -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s[i+<span class="number">2</span>*sc] = s[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(s)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指01-二维数组中的查找</title>
    <url>/2019/09/12/algs/arrow4Offer/2019-09-12-01-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述：</p>
<p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<hr>
<p>根据二维数组特性，如果数字target在第m行，则必有<code>array[m][0]&lt;=target</code> 且<code>array[m][N-1]&gt;=target</code>，即大于等于行首元素，小于等于行尾元素。 因此，从第一行<code>m=0</code>到最后一行<code>m=M-1</code>的每行，依次做如下两步检测：</p>
<ul>
<li>如果<code>array[m][N-1] &lt; target</code>则该行肯定不存在该数，直接进入下一行；</li>
<li>如果<code>array[m][0] &gt; target</code>则整个数组内将不存在该数，返回False。</li>
</ul>
<p>经过上述检测的某行，则满足<code>array[m][0]&lt;=target</code> 且<code>array[m][N-1]&gt;=target</code>，但这只是必要条件。还需要检查target是否真的在这一行。如果不在这一行，还要继续进入下一行继续检测。</p>
<ul>
<li>检查target是否真的在这一行，用了二分查找。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Find</span><span class="params">(self, target, array)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(num, array)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(array) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            s, t = <span class="number">0</span>, len(array)<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> s &lt; t:</span><br><span class="line">                mid = (s+t)&gt;&gt;<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> array[mid] == num:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">elif</span> array[mid] &gt; num:</span><br><span class="line">                    t = mid</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    s = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> array[s] == num</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> array <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> len(array) == <span class="number">0</span> <span class="keyword">or</span> len(array[<span class="number">0</span>]) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        M, N = len(array),len(array[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> range(M):</span><br><span class="line">            <span class="keyword">if</span> array[m][N<span class="number">-1</span>] &lt; target:</span><br><span class="line">                <span class="comment"># 该行肯定不存在该数，直接进入下一行</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> array[m][<span class="number">0</span>] &gt; target:</span><br><span class="line">                <span class="comment"># 整个数组内将不存在该数</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> search(target, array[m]): </span><br><span class="line">                    <span class="comment"># 如果不在这一行，还要继续进入下一行继续检测</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<hr>
<p>将二维数组array看成是平面上<span class="math inline">\(M\times N\)</span>个小格子组成的一个矩形，则比较某元素array[m][n]与搜索目标target的关系，对搜索空间有如下影响：</p>
<ul>
<li>如果<code>array[m][n] &lt; target</code>，则任何横坐标<span class="math inline">\(m&#39;\le m\)</span> 或者纵坐标<span class="math inline">\(n&#39;\le n\)</span>的小格子都不再考虑,即包括array[m][n]的左上角所有格子组成的小矩形。</li>
<li>如果<code>array[m][n] &gt; target</code>，则任何横坐标<span class="math inline">\(m&#39;\ge m\)</span> 或者纵坐标<span class="math inline">\(n&#39;\ge n\)</span>的小格子都不再考虑，即包括array[m][n]的右下角所有格子组成的小矩形。</li>
<li>如果<code>array[m][n] == target</code>，查找结束。</li>
</ul>
<p>也就是说，如果<code>array[m][n]</code>没有命中，则搜索空间将被抠掉一个以<code>array[m][n]</code>为右下角或者左上角的小矩形。那么，如果每次选择的<code>array[m][n]</code>位于当前矩形空间的左小角或者右上角，那么结果是要么命中，要么搜索空间被抠掉其所在的行或者列，仍然留下了一个矩形的待搜索空间。那么，就可以用迭代来继续按照上述方法做，直到找到或者待搜索空间为空。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Find</span><span class="params">(self, num, array)</span>:</span></span><br><span class="line">        row = <span class="number">0</span></span><br><span class="line">        col = len(array[<span class="number">0</span>])<span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> array == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> row&lt;len(array) <span class="keyword">and</span> col &gt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> array[row][col] == num:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> array[row][col] &gt; num:</span><br><span class="line">                col -=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                row +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>股票的最大利润</title>
    <url>/2019/09/09/algs/general/2019-09-10-%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可获得的最大利润是多少？</p>
<p>例子： 例如，一只股票在某些时间节点的价格为<code>[9,11,8,5,7,12,16,14]</code>。如果我们能在价格为5的时候买入并在价格为16时卖出，则能获得最大的利润为11.</p>
<hr>
<h3 id="买卖各一次">1.买卖各一次</h3>
<ul>
<li>从前往后构建新的序列minB,与价格序列一一对应，元素<code>minB[i]</code>表示在<code>i</code>之前（不包括<code>i</code>）遇到的价格最小值。</li>
<li>从后往前构建新的序列maxA,也与价格序列一一对应，元素<code>maxA[i]</code>表示在<code>i</code>之后（包括<code>i</code>）遇到的价格最大值。</li>
<li>计算maxA与minB对应位置元素的差（忽略首位元素），其最大值就是能获得的最大利润。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(prices)</span>:</span></span><br><span class="line">    lp = len(prices)</span><br><span class="line">    </span><br><span class="line">    minB = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,lp): <span class="comment"># 由前向后生成minB序列</span></span><br><span class="line">        <span class="keyword">if</span> len(minB)==<span class="number">0</span>:</span><br><span class="line">            minB.append(prices[i<span class="number">-1</span>]) </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            minB.append(min(prices[i<span class="number">-1</span>],minB[i<span class="number">-2</span>]))</span><br><span class="line"></span><br><span class="line">    maxA = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(lp<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>): <span class="comment"># 由后向前生成maxA序列</span></span><br><span class="line">        <span class="keyword">if</span> len(maxA) == <span class="number">0</span>:</span><br><span class="line">            maxA.insert(<span class="number">0</span>,prices[i])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            maxA.insert(<span class="number">0</span>,max(maxA[<span class="number">0</span>],prices[i]))</span><br><span class="line">    <span class="keyword">return</span> max([maxA[i]-minB[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(lp<span class="number">-1</span>)])</span><br></pre></td></tr></table></figure>
<hr>
<p>在访问第<code>i</code>个价格之前，记录所遇到的最低价格minP和最大盈利maxProfit，二者在每访问一个价格之后就可以更新。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">    lp = len(prices)</span><br><span class="line">    <span class="keyword">if</span> lp &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    minP, maxProfit = prices[<span class="number">0</span>], <span class="number">0</span> </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(lp):</span><br><span class="line">        maxProfit = max(maxProfit, prices[i]-minP)</span><br><span class="line">        minP = min(minP,prices[i])</span><br><span class="line">    <span class="keyword">return</span> maxProfit</span><br></pre></td></tr></table></figure>
<hr>
<p>第i天买第j天卖，收益函数<code>prices[j]-prices[i] = prices[j]-prices[j-1]+prices[j-1]-prices[j-2]+...+prices[i]-prices[i]</code>等价于从i到j相邻两天价格差的求和。收益函数最大，也就是求相邻价格差组成的序列的最大和子序列。</p>
<p>将原输入数组<code>[9,11,8,5,7,12,16,14]</code>进行改造，得到相邻两天的价格差的数组<code>[2,-3,-3,2,5,4,-2]</code>，则原问题变成了一个求最大连续和子数列问题: 以<span class="math inline">\(f(i)\)</span>表示以从左到右第<span class="math inline">\(i\)</span>个数字结尾的子数组的最大和，则<span class="math inline">\(max[f(i)]\)</span>就是全局的最大和。用动态规划，有如下递推公式： <span class="math display">\[f(x)=
\begin{cases}
pdiffs[i],\qquad i=0 \vee f(i-1)\le 0 \\
f(i-1)+pdiffs[i],\quad i\ne 0 \wedge f(i-1)\ge 0
\end{cases}
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(prices)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(prices) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    pdiffs = [prices[i]-prices[i<span class="number">-1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(prices))]</span><br><span class="line">    states = []</span><br><span class="line">    val = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(pdiffs)):</span><br><span class="line">        val = val + pdiffs[i] <span class="keyword">if</span> val + pdiffs[i] &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        states.append(val)</span><br><span class="line">    <span class="keyword">return</span> max(states)</span><br></pre></td></tr></table></figure>
<p>上面求最大连续和子数列的复杂度是<code>2n</code>，再加上求价格差和最大值，总复杂度是<code>4n</code>，即O(N)。</p>
<h3 id="多次买卖两次买卖之间无交叉">2.多次买卖，两次买卖之间无交叉</h3>
<p>很简单，相邻两天的价格差的数组，将其大于0的元素求和即得到多次买卖的最大利润。</p>
<p>如果一次买卖决策是第i天买入第j天卖出，有如下两种情形：</p>
<ul>
<li>如果j&gt;i+1，多个连续价格差的和。易知利润等价于i到j天的价格差之和。而且同时i、j之间的相邻两天价格差必然全为非负。</li>
<li>如果j=i+1，单独一个价格差，其左右相邻两个价格差必为负。</li>
</ul>
<p>两种情况都是为正数的价格差的求和。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        sumProfit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(prices)):</span><br><span class="line">            diff = prices[i]-prices[i<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> diff &gt; <span class="number">0</span>:</span><br><span class="line">                sumProfit += diff </span><br><span class="line">        <span class="keyword">return</span> sumProfit</span><br></pre></td></tr></table></figure></p>
<h3 id="至多两次买卖两次买卖之间无交叉">3.至多两次买卖，两次买卖之间无交叉</h3>
<p>令<code>i=0..n-1</code>，定义</p>
<ul>
<li>dp1[i]是子序列<code>prices[0-i]</code>这个<code>i+1</code>序列的最多一次买卖的最大盈利，</li>
<li>dp2[i]是子序列<code>prices[i:]</code>这个<code>n-i</code>序列的最多一次买卖的最大盈利。</li>
<li>则<code>dp[i]=dp1[i]+dp2[i]</code>表示第i天前后两个子序列<code>prices[0-i]</code>和<code>prices[i:]</code>都不超过一次买卖的的最大盈利。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp1 = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        dp2 = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        minval = prices[<span class="number">0</span>]</span><br><span class="line">        maxval = prices[<span class="number">-1</span>]</span><br><span class="line">        <span class="comment">#前向   </span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            dp1[i] = max(dp1[i<span class="number">-1</span>], prices[i] - minval)</span><br><span class="line">            minval = min(minval, prices[i])</span><br><span class="line">        <span class="comment">#后向    </span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            dp2[i] = max(dp2[i+<span class="number">1</span>], maxval - prices[i])</span><br><span class="line">            maxval = max(maxval, prices[i])</span><br><span class="line">        </span><br><span class="line">        dp = [dp1[i] + dp2[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">return</span> max(dp)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>最大连续和</tag>
      </tags>
  </entry>
  <entry>
    <title>统计学习方法的总结</title>
    <url>/2019/09/09/ML-AI/2019-09-09-%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第二章感知机">第二章感知机</h1>
<h3 id="感知机学习算法的原始形式">2.3.1 感知机学习算法的原始形式</h3>
<ul>
<li>感知机的学习算法是错误的分类样本锁驱动的，采用随机梯度下降法。</li>
<li>当没有错误分类时，学习停止。因此可知对于线性可分数据集，感知机的收敛解有无数个。</li>
</ul>
<h1 id="第三章-k近邻法">第三章 k近邻法</h1>
<h3 id="k值的选择">3.2.3 k值的选择</h3>
<ul>
<li>k值减小意味着模型变得复杂，容易过拟合</li>
<li>k值增大意味着模型变得简单，例如<span class="math inline">\(k=N\)</span>时最简单。</li>
</ul>
<h3 id="分类决策规则">3.2.4 分类决策规则</h3>
<ul>
<li>所用的多数表决规则，等价于0-1损失函数时的经验风险最小化。</li>
</ul>
<h1 id="第四章-朴素贝叶斯法">第四章 朴素贝叶斯法</h1>
<h2 id="朴素贝叶斯的学习与分类">4.1 朴素贝叶斯的学习与分类</h2>
<p>条件概率分布<span class="math inline">\(P(X\mid Y)\)</span>的参数个数是<span class="math inline">\(K\prod_{j=1}^nS_j\)</span>，是指数级的。先验概率<span class="math inline">\(P(Y)\)</span>的参数个数是<span class="math inline">\(K\)</span>。</p>
<h3 id="后验概率最大化的含义">4.1.2 后验概率最大化的含义</h3>
<p>容易验证朴素贝叶斯模型里，根据0-1损失函数时的期望风险最小化准则，可以推导出后验概率最大化准则。</p>
<ul>
<li>损失函数和期望风险函数参考公式1.5-1.9.</li>
</ul>
<h2 id="朴素贝叶斯的参数估计">4.2 朴素贝叶斯的参数估计</h2>
<p>可知朴素贝叶斯的先验概率<span class="math inline">\(p(y)\)</span>和似然函数<span class="math inline">\(p(x\mid y)\)</span>（也就是条件概率）是通过极大似然估计来计算得到的，然后通过后验概率最大来获得预测值p(yx)。</p>
<p>以公式4.8所示的先验概率<span class="math inline">\(P(Y=c_k)\)</span>的计算来说，用<span class="math inline">\(x\)</span>来指代该变量，然后用符号<span class="math inline">\(p\)</span>来指代观测到的<span class="math inline">\(y=c_k\)</span>的频率即<span class="math inline">\(\frac{\sum_{i=1}^NI(y_i=c_k)}{N}\)</span>，则<span class="math inline">\(x\)</span> 的似然函数为<span class="math inline">\(x^{pN}\cdot (1-x)^{(1-p)N}\)</span>，可以很容易计算该似然函数最大时<span class="math inline">\(x\)</span>取值与<span class="math inline">\(p\)</span>相等。同理可用同样的极大似然估计方法来计算似然函数<span class="math inline">\(p(x\mid y)\)</span>。</p>
<p>因此，第12章(p211)对朴素贝叶斯锁总结的学习策略有两个，即极大似然估计和极大后验概率估计。</p>
<h3 id="贝叶斯估计">4.2.3 贝叶斯估计</h3>
<p>样本不足时，上述极大似然估计得到的先验概率和条件概率时可能为0，显然是不合适的。</p>
<p>贝叶斯估计的处理办法：如果值有s种，则对每个概率的分子添加<span class="math inline">\(\lambda\)</span>值，对分母添加<span class="math inline">\(s\lambda\)</span>值。当<span class="math inline">\(\lambda\)</span>为0时就蜕化成了极大后验概率估计，当<span class="math inline">\(\lambda\)</span>为1时又叫做拉普拉斯平滑。</p>
<p>上述处理公式的推到，需要了解<a href="https://github.com/wolfbrother/biji-logs/blob/master/Algorithms/MachineLearning/20190527.md" target="_blank" rel="noopener">共轭先验</a>。</p>
<h1 id="第五章-决策树">第五章 决策树</h1>
<h2 id="决策树模型与学习">5.1 决策树模型与学习</h2>
<ul>
<li>决策树路径的特征：互斥并且完备。</li>
<li>每个叶节点上的条件概率偏向于某一类，分类时会将该节点的实例强制分到该类里。与朴素贝叶斯、最大熵模型不同的是，决策树并不能给出每个样本属于某个类的条件概率。</li>
<li>决策树学习算法包含三个过程：特征选择，决策树生成，剪枝。
<ul>
<li>决策树越深，模型越复杂。决策树生成只考虑局部最优，而剪枝考虑全局最优</li>
</ul></li>
</ul>
<h2 id="基于信息增益的特征选择">5.2 基于信息增益的特征选择</h2>
<ul>
<li>信息增益：特征A对训练数据集D的信息增益<span class="math inline">\(g(D,A)\)</span>，定义为集合D的类别信息的经验熵<span class="math inline">\(H(D)\)</span>与特征<span class="math inline">\(A\)</span>给定条件下D的经验条件熵<span class="math inline">\(H(D\mid A)\)</span>之差，即<span class="math inline">\(g(D,A)=H(D)-H(D\mid A)\)</span>。
<ul>
<li>之所以叫做经验熵和经验条件熵，是因为二者都是直接从数据集中根据极大似然估计所得到的（p61）。</li>
<li>信息增益<span class="math inline">\(g(D,A)\)</span>实际上是训练数据集中类与特征的互信息。</li>
<li>信息增益可以直观地看成给定特征<span class="math inline">\(A\)</span>之后，类别信息的不确定性的减少量，即特征<span class="math inline">\(A\)</span>的分类能力(公式5.7,5.8)。</li>
</ul></li>
<li>信息增益比
<ul>
<li>信息增益有个缺陷，如果某个特征的取值较多，其信息增益偏向于比较高。因此用该特征的经验熵<span class="math inline">\(H(A)\)</span>对其信息增益<span class="math inline">\(g(D,A)\)</span>进行归一化得到信息增益比<span class="math inline">\(g_r(D,A)\)</span>用于特征选择 （公式5.10）。</li>
</ul></li>
</ul>
<h2 id="决策树的生成">5.3 决策树的生成</h2>
<ul>
<li>有两种生成算法分别是ID3和C4.5，区别在于前者采用信息增益，后者采用信息增益比进行特征选择。</li>
<li>几个要点：
<ul>
<li>每条路径上特征最多只用一次。实际操作中，选择某个特征之后，将该特征从其子路径的特征集里剔除。</li>
<li>有个预设的信息增益阈值，如果所选特征的信息增益小于该阈值，则该路径停止，当前节点作为叶子节点。</li>
<li>路径停止的条件还有一个，即特征集为空的时候。</li>
</ul></li>
</ul>
<h2 id="决策树的剪枝">5.4 决策树的剪枝</h2>
<ul>
<li>减小模型复杂度，而模型复杂度用叶节点的个数来表示。</li>
<li>损失函数（公式5.11）包含两部分，一个是叶节点的类别信息的经验熵的加权求和（权重是该叶节点的样本数），另一个是模型复杂度。前者为0，则说明没有错误分类，其值越大，表示分类误差越大。后者越大，模型复杂度越大。因此剪枝过程对损失函数求极小。</li>
<li>剪枝时可以只计算局部的损失函数变化，因此：1.不用考虑叶节点的顺序；2.可以用动态规划来层层来剪枝。</li>
</ul>
<h2 id="cart算法">5.5 CART算法</h2>
<h3 id="cart生成">5.5.1 CART生成</h3>
<ul>
<li>回归树
<ul>
<li>一个回归树对应着特征空间的一个划分，以及在划分的单元上的一个常数的输出值。</li>
<li>适用于分段常数数据集</li>
<li>损失函数是平方误差和：1）给定某个划分单元，该单元的输出值将设定为均值；2）而最优划分点可以通过依次计算获得。有最小二乘法的影子，因此回归树又叫做最小二乘回归树。</li>
</ul></li>
<li>分类树
<ul>
<li>只是将决策树中的熵替换为基尼系数。</li>
<li>基尼系数、熵之半的曲线接近，可以近似分类误差率（图5.7）</li>
</ul></li>
</ul>
<h1 id="第六章-逻辑斯蒂回归于最大熵模型">第六章 逻辑斯蒂回归于最大熵模型</h1>
<p>最大熵模型的模型表达式，有介绍其推导过程。而逻辑斯蒂回归模型没有推导过程，而直接给出模型表达式。然后根据模型表达式，去优化参数，优化方法可以是梯度下降法和拟牛顿法，对于前者还有个专用的&quot;改进的迭代尺度法IIS&quot;。</p>
<h2 id="逻辑斯蒂回归模型">逻辑斯蒂回归模型</h2>
<ul>
<li>logistic函数也就是经常说的sigmoid函数： <span class="math display">\[\frac{1}{1+e^{-x}}\]</span> logistic函数在统计学和机器学习领域应用最为广泛或者最为人熟知的肯定是逻辑回归模型了。逻辑回归（Logistic Regression，简称LR）作为一种对数线性模型（log-linear model）被广泛地应用于分类和回归场景中。此外，logistic函数也是神经网络最为常用的激活函数，即sigmoid函数。</li>
</ul>
<h2 id="最大熵模型">6.2 最大熵模型</h2>
<h3 id="最大熵原理">6.2.1 最大熵原理</h3>
<p>最大熵原理认为要选择的概率模型首先必须满足已有的约束条件。而其余不确定的部分应该是等可能的。而等可能不容易操作，但由此而来的熵是一个可优化的数值指标。因此最大熵原理通过熵的最大化来表示等可能性。</p>
<h3 id="最大熵模型的学习">6.2.3 最大熵模型的学习</h3>
<p>对偶问题，即公式6.19的内层是关于条件概率<span class="math inline">\(p(y\mid x)\)</span>的函数，外层才是关于<span class="math inline">\(w\)</span>的函数。因此p84底部，求解内层时要对<span class="math inline">\(p(y\mid x)\)</span>求导。</p>
<p>求导得0，进而获得了最大熵模型（公式6.22）。</p>
<p>然后带入最大熵模型，求解外层（其表达式是公式6.27）。</p>
<h3 id="极大似然估计">6.2.4 极大似然估计</h3>
<p>对偶问题（公式6.19）的外层（公式6.27）是关于参数<span class="math inline">\(w\)</span>求解极大值的函数，而对数似然函数最大化（公式6.26）也是关于参数<span class="math inline">\(w\)</span>的求解极大值的函数。可以验证二者的公式，在最大熵模型时，是等价的。</p>
<h1 id="第七章-支持向量机">第七章 支持向量机</h1>
<h2 id="线性可分支持向量机与硬间隔最大化">7.1 线性可分支持向量机与硬间隔最大化</h2>
<ul>
<li>线性可分支持向量机的最优化问题 <span class="math display">\[min_{w,b}\frac{1}{2}\mid\mid w\mid\mid ^2, s.t. y_i(w\cdot x_i+b)-1&gt;=0\]</span></li>
</ul>
<p>其直观地推导方法如下：参考图7.3，假设<span class="math inline">\((w,b)\)</span>就是要找的超平面的参数，那么对于两侧的支持向量有<span class="math inline">\(y_i(w\cdot x_i+b)-1=0\)</span>，易知外侧的样本点<span class="math inline">\((x_i,y_i)\)</span>必有<span class="math inline">\(y_i(w\cdot x_i+b)-1&gt;0\)</span>，因此参数满足<span class="math inline">\(y_i(w\cdot x_i+b)-1&gt;=0\)</span>。根据平行面的距离公式，易知两个超平面的距离是<span class="math inline">\(\frac{2}{\mid\mid w\mid\mid }\)</span>，因此间隔最大化意味着$w$最小化。</p>
<p>因此支持向量机寻找超平面实际上就是寻找两个让支持向量集合里正例和反例分别是为<span class="math inline">\(+1/-1\)</span>的两个平行面，并且要使得这两个平行面的间隔尽可能地大。</p>
<ul>
<li>凸二次规划问题 <span class="math display">\[min_x f(x), s.t. g_i(x)&lt;=0,h_j(x)=0\]</span> 其中<span class="math inline">\(f(x)\)</span>和<span class="math inline">\(g(x)\)</span>是连续可微的二次凸函数，<span class="math inline">\(h(x)\)</span>是仿射函数。</li>
</ul>
<p>易知线性可分支持向量机的最优化问题，本质上是凸二次优化问题。</p>
<h3 id="学习的对偶算法">7.1.4 学习的对偶算法</h3>
<p>这一节很好地诠释了拉格朗日对偶性（附录 C）便于求解的作用： + 原始问题（公式7.13和7.14）引入拉格朗日算子（本质上是新的变量）去掉了约束条件，同时转化成了极大极小问题。该极大极小问题的内层的梯度为0的性质可以用来获得新的约束条件（公式7.20， 只含有拉格朗日算子，去掉了最初的参数<span class="math inline">\(w\)</span>和<span class="math inline">\(b\)</span>），将极大极小问题转换成一个有约束的极大问题（公式7.21），后者又叫做原始问题的对偶问题： <span class="math display">\[min_\alpha \frac{1}{2}\sum_{i=1}^{N}\sum_{j=1}^{N}\alpha_i\alpha_jy_iy_j(x_i\cdot x_j)-\sum_{i=1}^{N}\alpha_i\]</span> <span class="math display">\[s.t. \sum_{i=1}^{N}\alpha_iy_i=0, \alpha_i\ge 0, i=1,2, \cdots, N\]</span></p>
<ul>
<li>拉格朗日对偶算法求解SVM的意义
<ul>
<li>降低求解复杂度：原问题的优化是一个二次规划问题，求解较麻烦，用拉格朗日乘子法转换后可以用smo等算法更简单地优化。</li>
<li>方便引入核函数：由于转换后的假设函数主要由内积运算构成，可以使用核函数简化特征映射到高维空间后的内积运算，高效地求解非线性问题。</li>
</ul></li>
</ul>
<h2 id="线性支持向量机与软间隔最大化">7.2 线性支持向量机与软间隔最大化</h2>
<p>注：p109 <span class="math inline">\(w\)</span>的解唯一，但<span class="math inline">\(b\)</span>的解不唯一存在一个区间。</p>
<p>近似线性可分时，给每个样本<span class="math inline">\((x_i,y_i)\)</span>引进一个松弛变量<span class="math inline">\(\xi_i\ge 0\)</span>，是的实际的函数间隔可以小于1甚至为负；并将松弛变量作为代价引入到原目标函数以对松弛变量进行限制，变成如下的原始问题： <span class="math display">\[min_{w,b,\xi}\frac{1}{2}\mid\mid w\mid\mid ^2+C\sum_{i=1}^{N}\xi_i\]</span> <span class="math display">\[s.t. y_i(w\cdot x_i+b)\ge 1-\xi_i, \xi_i\ge 0\]</span></p>
<p>其对偶问题是： <span class="math display">\[min_\alpha \frac{1}{2}\sum_{i=1}^{N}\sum_{j=1}^{N}\alpha_i\alpha_jy_iy_j(x_i\cdot x_j)-\sum_{i=1}^{N}\alpha_i\]</span> <span class="math display">\[s.t. \sum_{i=1}^{N}\alpha_iy_i=0, 0\le\alpha_i\le C, i=1,2, \cdots, N\]</span></p>
<h3 id="支持向量">7.2.3 支持向量</h3>
<p>结合图7.5分析变量与空间位置关系：</p>
<ul>
<li>超平面<span class="math inline">\(w\cdot x +b =0\)</span>将<span class="math inline">\(w=\sum_{i=1}^{N}\alpha_iy_ix_i\)</span>带入进去，变成了<span class="math inline">\(\sum_{i=1}^{N}\alpha_iy_i(x\cdot x_i)+b=0\)</span>，因此只有<span class="math inline">\(\alpha_i&gt;0\)</span>的样本点为支持向量。</li>
<li>判别函数是<span class="math inline">\(f(x)=sign(\sum_{i=1}^{N}\alpha_iy_i(x\cdot x_i)+b)\)</span></li>
<li>由原始问题关于<span class="math inline">\(\xi\)</span>的含义，可知<span class="math inline">\(\xi=0\)</span>的样本点在间隔边界上或外面，<span class="math inline">\(0&lt;\xi&lt;1\)</span>的说明<span class="math inline">\(y_i(w\cdot x_i+b)=1-\xi\)</span>所以在间隔边界和超平面之间，<span class="math inline">\(\xi_i&gt;1\)</span>说明<span class="math inline">\(y_i(w\cdot x_i+b)=1-\xi&lt;0\)</span>位于超平面误分的一侧。</li>
</ul>
<h3 id="合页损失函数">合页损失函数</h3>
<p>上面7.2节的原始问题，等价于最优化问题： <span class="math display">\[\min_{w,b,\xi}\sum_{i=1}^{N}[1-y_i(w\cdot x_i+b)]_{+}+\lambda\mid\mid w\mid\mid ^2\]</span></p>
<p>其中前项是合页损失函数。</p>
<p>根据图7.6将合页损失函数与0-1损失和感知机的损失函数作对比，说明合页损失函数不仅要分类正确而且确信度足够高时损失才是0，即对学习有更高要求。</p>
<h2 id="非线性支持向量机与核函数">7.3 非线性支持向量机与核函数</h2>
<ul>
<li>在学习中只定义核函数<span class="math inline">\(K(x,y)\)</span>，而不显示地定义从输入空间到特征空间的映射函数<span class="math inline">\(\phi(x)\)</span>，二者关系：<span class="math inline">\(K(x,y)=(\phi(x)\cdot\phi(y))\)</span></li>
<li>对偶问题的目标函数的内积<span class="math inline">\((x_i\cdot x_j)\)</span>可以用核函数<span class="math inline">\(K(x_i,x_j)\)</span>来代替。</li>
</ul>
<h2 id="序列最小最优化算法smo">7.4 序列最小最优化算法SMO</h2>
<ul>
<li>SMO是一种启发式算法，其基本思路：
<ul>
<li>如果所有变量<span class="math inline">\(\alpha\)</span>都满足KKT条件，由于KKT条件是最优解的充分必要条件，则说明已经找到最优解。</li>
<li>不然以一定规则选择其中两个变量，固定其它变量，将问题转化成一个二元二次规划的子问题，对该子问题的优化会使得原目标函数值更小，而且该问题有解析解。</li>
<li>该两个变量的选取规则：一个是违反KKT条件（公式7.111-7.113）最严重的哪一个，另一个由约束条件自动确定。</li>
</ul></li>
</ul>
<h1 id="第八章-提升方法">第八章 提升方法</h1>
<h3 id="提升方法的基本思路">8.1.1 提升方法的基本思路</h3>
<p>AdaBoost如何实施提升方法的两个步骤：</p>
<ul>
<li>每一轮如何改变训练数据的权值或概率分布 提高哪些被前一轮弱分类器错误分类样本的权值，而降低那些被正确分类样本的权值。这样一来，那些没有得到正确分类的数据，由于其权值的加大而受到后一轮的弱分类器的更大关注。</li>
<li>如何将弱分类器组合成一个强分类器 加权线性组合的方式。具体的，分类误差率小的弱分类器的权值较大，而分类误差率大的弱分类器的权值较小。</li>
</ul>
<h3 id="adaboost算法">8.1.2 AdaBoost算法</h3>
<p>本节讲述了算法及其说明：</p>
<ul>
<li>最终分类器是基本分类器<span class="math inline">\(G_m(x)\)</span>的加权求和，其中第m个基本分类器<span class="math inline">\(G_m(x)\)</span>的系数是<span class="math inline">\(\alpha_m = \frac{1-e_m}{e_m}\)</span>，其中<span class="math inline">\(e_m\)</span>是第<span class="math inline">\(m\)</span>次迭代时<span class="math inline">\(G_m(x)\)</span>分类错误的样本的权值之和。</li>
<li>权值更新是对上次迭代的权值加一个系数然后归一化，分类正确的样本的权重所加的系数是<span class="math inline">\(e^{-\alpha_m}\)</span>被缩小，分类错误的样本的权重所加系数是<span class="math inline">\(e^{\alpha_m}\)</span>被放大。</li>
</ul>
<h3 id="adaboost算法的分类误差分析">8.2 AdaBoost算法的分类误差分析</h3>
<ul>
<li>AdaBoost算法的最终分类器的训练误差是有上界的，该上界是各个分类器的权值分布的规范化因子(公式8.5)之积。</li>
<li>AdaBoost的训练误差是以指数速率下降的。</li>
</ul>
<h2 id="adaboost算法的解释">8.3 AdaBoost算法的解释</h2>
<ul>
<li>加法模型</li>
</ul>
<p><span class="math inline">\(f(x)=\sum_{m=1}^{M}\beta_mb(x;\gamma_m)\)</span>，其中<span class="math inline">\(\beta_mb(x;\gamma_m)\)</span>为基函数，<span class="math inline">\(\gamma_m\)</span>为基函数的参数，<span class="math inline">\(\beta_m\)</span>为基函数的系数。 + 损失函数为指数函数 <span class="math display">\[L(y,f(x))=exp(-yf(x))\]</span> + 学习算法为前向分布算法</p>
<p>因为学习的是加法模型(公式8.13)，如果能够从前向后，每一步只学习一个基函数及其系数，逐步逼近优化目标函数式，那么可以简化优化的复杂度。</p>
<h2 id="提升树">8.4 提升树</h2>
<ul>
<li>本节的提升树是以回归树为基本分类器，与CART的回归树本质上没区别。。</li>
<li>AdaBoost的损失函数是指数函数，而提升树考虑了其它类型的损失函数。不同的损失函数，在每次找弱分类器所用的数据（包括权重）的产生方法不同
<ul>
<li>当损失函数是平方损失时，弱分类器的数据是上一轮所得到的模型与所用数据的差即残差。</li>
<li>对于更一般的损失函数，弱分类器的数据是损失函数的负梯度。损失函数时平方损失时的负梯度，就是残差。</li>
</ul></li>
</ul>
<h1 id="em算法及其推广">EM算法及其推广</h1>
<ul>
<li>EM算法主要应用于含有隐变量的概率模型的学习，如高斯混合模型和隐马尔可夫模型。
<ul>
<li>与隐变量对应的是观测变量，与变量对应的是参数。观测变量的数据又叫不完全数据，观测变量的数据与隐变量连在一起称为完全数据。要知道参数、隐变量和观测变量的区别。</li>
</ul></li>
<li>理论分析里E步和M步的工作: EM算法的目标函数是观测数据<span class="math inline">\(Y\)</span>关于参数<span class="math inline">\(\theta\)</span>的对数自然函数，即<span class="math inline">\(L(\theta)=\log P(Y\mid \theta)=\log \left(\sum_Z P(Y\mid Z,\theta)P(Z\mid \theta)\right)\)</span>
<ul>
<li>E步：</li>
</ul>
计算完全数据的对数似然函数<span class="math inline">\(\log P(Y,Z\mid \theta)\)</span>关于在给定观测数据<span class="math inline">\(Y\)</span>和当前参数<span class="math inline">\(\theta^{(i)}\)</span>下对隐变量<span class="math inline">\(Z\)</span>的条件概率分布<span class="math inline">\(P(Z\mid Y,\theta^{(i)})\)</span>的期望，即EM算法里的Q函数： <span class="math display">\[Q(\theta,\theta^{(i)})=\sum_{Z}\log P(Y,Z\mid \theta)P(Z\mid Y,\theta^{(i)})\]</span>
<ul>
<li>M步：</li>
</ul>
<p>求<span class="math inline">\(\theta\)</span>使得最大化Q函数</p></li>
<li>编程实践里E步和M步的工作
<ul>
<li>E步：在当前模型参数之下结合观测变量集，计算观测变量每个取值分别来自于每个隐变量取值的概率</li>
</ul>
GMM模型里是是[0,1]区间的变量（p164 <span class="math inline">\(\hat{\gamma_{jk}}\)</span>）；而K均值里是0-1变量；而例9.1里隐变量是观测变量来自于硬币B或C的概率。
<ul>
<li>M步：计算模型参数</li>
</ul>
<p>GMM模型里计算模型参数见公式9.30-9.32，其模型参数分两部分，即<span class="math inline">\(K\)</span>个高斯模型的参数<span class="math inline">\((\mu_k,\sigma_k^2)\)</span>及其权重<span class="math inline">\(\alpha_k\)</span>；而K均值里，参数是各个聚类中心，注意其没有权重的概念；而例9.1里参数是(<span class="math inline">\(\pi,p,q\)</span>)</p></li>
</ul>
<h1 id="第10章-隐马尔科夫链">第10章 隐马尔科夫链</h1>
<h2 id="隐马尔可夫模型的基本概念">10.1 隐马尔可夫模型的基本概念</h2>
<h3 id="隐马模型的定义">10.1.1 隐马模型的定义</h3>
<ul>
<li>状态序列和观测序列等长，元素一一对应</li>
<li>隐马模型<span class="math inline">\(\lambda\)</span>的三元组表示法<span class="math inline">\(\lambda=(A,B,\pi)\)</span>。</li>
</ul>
<p>其中初始状态概率向量<span class="math inline">\(\pi\)</span>和状态转移矩阵<span class="math inline">\(A\)</span>确定了隐藏的马尔科夫链（即不可观测到的状态序列<span class="math inline">\(I\)</span>），而观测概率矩阵<span class="math inline">\(B\)</span>确定了如何从状态生成观测，与状态序列<span class="math inline">\(I\)</span>综合确定了如何产生观测序列<span class="math inline">\(O\)</span>。</p>
<p>用于标注问题时，状态对应着要求给出的标记，观测序列对应要被标注的数据。</p>
<ul>
<li>隐马模型的两个基本假设
<ul>
<li>齐次性假设</li>
<li>观测独立性假设 t ### 10.1.3 隐马模型的三个基本问题</li>
</ul></li>
</ul>
<p>可以用词性标注问题来理解这三类问题。</p>
<ul>
<li>概率计算问题</li>
</ul>
<p>给定<span class="math inline">\(\lambda\)</span>和<span class="math inline">\(O\)</span>，计算<span class="math inline">\(P(O\mid \lambda)\)</span>；词性标注场景里，给定模型参数，计算词序列概率。</p>
<ul>
<li>学习问题
<ul>
<li><p>有<span class="math inline">\(I\)</span>，监督学习：已知<span class="math inline">\(O\)</span>和<span class="math inline">\(I\)</span>,推断<span class="math inline">\(\lambda\)</span>，使得<span class="math inline">\(P(O\mid \lambda)\)</span>最大</p></li>
<li><p>无<span class="math inline">\(I\)</span>，属于无监督学习：已知<span class="math inline">\(O\)</span>,推断<span class="math inline">\(\lambda\)</span>，使得<span class="math inline">\(P(O\mid \lambda)\)</span>最大；词性标注场景里，给定词序列，去学习模型参数。</p></li>
</ul></li>
<li>预测问题</li>
</ul>
<p>已知<span class="math inline">\(\lambda\)</span>和<span class="math inline">\(O\)</span>，给出<span class="math inline">\(I = argmax P(I\mid O)\)</span>；词性标注场景里，给定模型和分好的词，来标注词性。</p>
<h2 id="概率计算算法">10.2 概率计算算法</h2>
<h3 id="直接计算法">10.2.1 直接计算法</h3>
<p><span class="math inline">\(P(O\mid \lambda)=\sum_{I}P(O\mid I,\lambda)P(I\mid \lambda)=\sum_{i}\pi_{i_1}b_{i_1}(o_1)a_{i_1i_2}b_{i_2}(o_2)\cdots a_{i_{T-1}i_T}b_{i_T}(o_T)\)</span> 计算量很大，是O(TN^T)阶的。</p>
<h3 id="前向算法和后向算法">10.2.2-10.2.3 前向算法和后向算法</h3>
<ul>
<li>前向算法和后向算法都属于动态规划</li>
<li>两个概念是理解算法的钥匙
<ul>
<li>前向概率：给定隐马模型<span class="math inline">\(\lambda\)</span>，定义到时刻<span class="math inline">\(t\)</span>部分观测序列为<span class="math inline">\(o_1,o_2,\cdots,o_t\)</span>且状态为<span class="math inline">\(q_i\)</span>的概率为前向概率，记作<span class="math display">\[\alpha_t(i)=P(o_1,o_2,\cdots,o_t,i_t=q_i\mid \lambda)\]</span> 递推公式有，<span class="math inline">\(\alpha_1(i)=\pi_ib_i(o_1)\)</span>,而对于<span class="math inline">\(t=1,2,\cdots,T-1\)</span> <span class="math display">\[\alpha_{t+1}(i)=\left(\sum_{j=1}^{N}\alpha_t(j)a_{ji}\right)b_i(o_{t+1})\]</span> 终止时有 <span class="math display">\[P(O\mid \lambda)=\sum_{i=1}^{N}\alpha_T(i)\]</span></li>
<li>后向概率：给定隐马模型<span class="math inline">\(\lambda\)</span>，定义到时刻<span class="math inline">\(t\)</span>状态为<span class="math inline">\(q_i\)</span>的条件下，从<span class="math inline">\(t+1\)</span>到<span class="math inline">\(T\)</span>的部分观测序列为<span class="math inline">\(o_{t+1},o_{t+2},\cdots,o_T\)</span>的概率为后向概率，记作<span class="math display">\[\beta_t(i)=P(o_{t+1},o_{t+2},\cdots,o_T\mid i_t=q_i,\lambda)\]</span> 递推公式有，<span class="math inline">\(\beta_T(i)=1\)</span>，而对于<span class="math inline">\(t=T-1,T-2,\cdots,1\)</span> <span class="math display">\[\beta_t(i)=\sum_{j=1}^{N}a_{ij}b_j(o_{t+1})\beta_{t+1}(j)\]</span> 终止时有<span class="math display">\[P(O\mid \lambda)=\sum_{i=1}^{N}\pi_ib_i(o_1)\beta_1(i)\]</span></li>
</ul></li>
</ul>
<h2 id="学习算法">10.3 学习算法</h2>
<h3 id="监督学习方法">10.3.1 监督学习方法</h3>
<p>用极大似然估计法，可以通过直接统计得到<span class="math inline">\(\lambda\)</span>各参数。</p>
<h3 id="baum-welch算法">10.3.2 Baum-Welch算法</h3>
<p>属于无监督学习，期望最大化方法：把观测序列看做观测数据，将状态序列看做隐数据，那么隐马模型是一个含有隐变量的概率模型<span class="math inline">\(P(O\mid \lambda)=\sum_IP(O\mid I,\lambda)P(I\mid \lambda)\)</span> + EM算法的E步的Q函数是<span class="math inline">\(Q(\lambda,\hat{\lambda})=\sum_I\log P(O,I\mid \lambda)P(O,I\mid \hat{\lambda})\)</span>，其中之所以可以采用<span class="math inline">\(P(O,I\mid \hat{\lambda})\)</span>而非EM常用的<span class="math inline">\(P(I\mid O,\hat{\lambda})\)</span>是因为二者有常数比例的关系：<span class="math inline">\(P(\hat{\lambda})=\frac{P(O,I\mid \hat{\lambda})}{P(I\mid O,\hat{\lambda})}\)</span>。 + Baum-Welch算法的E步只列出了Q函数，并没有显式地计算期望；然后直接在M步,利用概率的性质，通过拉格朗日算子法来计算参数。</p>
<h2 id="预测算法">10.4 预测算法</h2>
<h3 id="维特比算法">10.4.2 维特比算法</h3>
<ul>
<li>维特比算法，和前向算法和后向算法一样，都属于动态规划</li>
</ul>
<h1 id="第11章-条件随机场">第11章 条件随机场</h1>
<h2 id="概率无向图模型">11.1 概率无向图模型</h2>
<p>三个概念：</p>
<ul>
<li>成对、局部、全局马尔科夫性，三者定义是等价的</li>
<li>概率无向图模型基于马尔科夫性的定义:联合概率分布<span class="math inline">\(P(Y)\)</span>满足上述马尔科夫性。</li>
<li>概率无向图的最大团<span class="math inline">\(C\)</span>的概念，即基于最大团的因式分解</li>
</ul>
<p>概率无向图模型的联合概率分布<span class="math inline">\(P(Y)\)</span>可以表示为如下形式： <span class="math display">\[P(Y)=\frac{1}{Z}\prod_C\Psi_C(Y_C)\]</span> 其中<span class="math inline">\(Z=\sum_Y\prod_C\Psi_C(Y_C)\)</span>，而<span class="math inline">\(\Psi_C(Y_C)\)</span>称为势函数，通常定义为指数函数<span class="math inline">\(\Psi_C(Y_C)=exp\left(-E(Y_C)\right)\)</span>。</p>
<h2 id="条件随机场的定义与形式">11.2 条件随机场的定义与形式</h2>
<ul>
<li>线性链条件随机场的参数化形式 <span class="math display">\[P(y\mid x)=\frac{1}{Z(x)}exp\left(\sum_{i,k}\lambda_kt_k(y_{i-1},y_i,x,i)+\sum_{i,l}\mu_ls_l(y_i,x,i)\right)\]</span> 其中<span class="math inline">\(Z(x)=\sum_{y}exp\left(\sum_{i,k}\lambda_kt_k(y_{i-1},y_i,x,i)+\sum_{i,l}\mu_ls_l(y_i,x,i)\right)\)</span>，其中<span class="math inline">\(t_k(y_{i-1},y_i,x,i)\)</span>是转移函数，<span class="math inline">\(s_l(y_i,x,i)\)</span>是状态函数。</li>
</ul>
<h2 id="条件随机场的概率计算问题">11.3 条件随机场的概率计算问题</h2>
<p>前向后向算法</p>
<h2 id="条件随机场的学习算法">11.4 条件随机场的学习算法</h2>
<p>学习方法是极大似然估计或者正则化的极大似然估计，优化算法是牛顿、拟牛顿法</p>
<h2 id="条件随机场的预测算法">11.5 条件随机场的预测算法</h2>
<p>维特比算法</p>
]]></content>
      <categories>
        <category>ML-AI</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习概念总结三分之一部</title>
    <url>/2019/09/09/ML-AI/2019-09-09-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E4%B8%89%E5%88%86%E4%B9%8B%E4%B8%80%E9%83%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="求mtimes-k的矩阵a和ntimes-k矩阵b的欧几里得距离">求<span class="math inline">\(m\times k\)</span>的矩阵<span class="math inline">\(A\)</span>和<span class="math inline">\(n\times k\)</span>矩阵<span class="math inline">\(B\)</span>的欧几里得距离。</h2>
<p>说明：认为样本是k维横向量，矩阵A和B分别包含m和n个样本。那么，A和B的欧几里得距离，就是A的m个样本和B的n个样本的距离的集合，是个<span class="math inline">\(m\times n\)</span>维矩阵D， 其中<span class="math inline">\(D_{ij}\)</span>表示<span class="math inline">\(A_i\)</span>和<span class="math inline">\(D_j\)</span>的欧几里得距离。</p>
<p>分析：<span class="math inline">\(D^2_{ij} = \mid\mid A_i-B_j\mid\mid ^2 = A^2_i-2A_iB^T_j+B^2_i= A_iA^T_i-2A_iB^T_j+B_jB^T_j\)</span>，其中有<span class="math inline">\(i&lt;m, j&lt;n\)</span>。</p>
<p>对于A，首先计算m个横向量的模的平方，得到m维列向量，然后复制n份，得到<span class="math inline">\(m\times n\)</span>的矩阵；</p>
<p>对于B，计算n个横向量的模的平放，得到n维列两向量，然后复制m份，得到的矩阵进行转置，得到<span class="math inline">\(m\times n\)</span>的矩阵；</p>
<p>对于<span class="math inline">\(A\times B^T\)</span>，直接带入计算即可。</p>
<p>将三个矩阵带入计算就行。</p>
<h2 id="梯度与方向导数">梯度与方向导数</h2>
<p>一元函数的导数:<span class="math inline">\(f&#39;(x) = \lim_{\Delta x\rightarrow 0}\frac{f(x+\Delta x)-f(x)}{\Delta x}\)</span></p>
<p>多元函数有偏导数，对f(x,y)，有<span class="math inline">\(f_x(x,y) = \lim_{\Delta x}\frac{f(x+ \Delta x,y)-f(x,y)}{\Delta x}\)</span>，表示y不变时，沿x轴的变化率。同理可定义<span class="math inline">\(f_y(x,y)\)</span>。</p>
<p>方向导数：多元函数是一个平面，方向有很多， 而<span class="math inline">\(f_x(x,y)\)</span>的x 轴和<span class="math inline">\(f_y(x,y)\)</span>的y 轴只是其中两个方向的变化率而已。方向导数可以表示任意方向变化率。 对于方向<span class="math inline">\(u=cos\theta i + sin \theta j\)</span>，有 <span class="math display">\[\lim_{\Delta t}\frac{f(x+ cos\theta\Delta t, y+ sin\theta\Delta t)-f(x,y)}{\Delta t} = f_x(x,y)cos\theta + f_y(x,y)sin\theta\]</span> 可以看出，增量是向量<span class="math inline">\((f_x,f_y)\)</span>与方向<span class="math inline">\(u\)</span>的单位向量的向量积。想要增量最大，则只能让方向与向量<span class="math inline">\((f_x,f_y)\)</span>保持一致，而后者又叫做梯度。</p>
<h4 id="批量梯度下降bgd随机梯度下降sgd小批量梯度下降mbgd">批量梯度下降BGD，随机梯度下降SGD，小批量梯度下降MBGD</h4>
<ul>
<li>BGD：每次在更新参数时使用所有的样本；</li>
<li>SGD：每次更新参数时采用随机抽样的单个样本；</li>
<li>MBGD:BGD和SGD这两种极端方案的折中。</li>
</ul>
<h4 id="sgdmomentumadagardadam">SGD,Momentum,Adagard,Adam</h4>
<ul>
<li>总结
<ul>
<li>一阶动量（梯度）衰减方案利于全局搜索，</li>
<li>二阶动量（梯度的平方）衰减方案使得学习率自动调整，之所以要衰减是为了防止梯度消失</li>
<li>求梯度时用到前瞻性预估</li>
</ul></li>
<li>牛客网上的总结： <a href="https://www.nowcoder.com/tutorial/95/a785d36cf4264dfa93c3de133d0bb339" target="_blank" rel="noopener">链接</a></li>
<li>对这几个优化方法的介绍比较全面： <a href="https://fengxc.me/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95.html" target="_blank" rel="noopener">链接</a></li>
<li>各个优化方法的优缺点总结的比较好：<a href="https://www.cnblogs.com/GeekDanny/p/9655597.html" target="_blank" rel="noopener">链接</a></li>
<li>这个写得更完善： <a href="https://www.jianshu.com/p/aebcaf8af76e" target="_blank" rel="noopener">链接</a></li>
<li>最生动的解释，讲了各个方法的关系： <a href="https://www.bilibili.com/video/av16001891/?p=18" target="_blank" rel="noopener">链接</a>
<ul>
<li>Momentum和AdaGrad的组合</li>
</ul></li>
<li>这儿总结的也不错 从 SGD 到 Adam —— 6大常见优化算法总结 - zhahzhi的文章 - 知乎<a href="https://zhuanlan.zhihu.com/p/64113429" target="_blank" rel="noopener">链接</a></li>
</ul>
<h2 id="海森矩阵与牛顿法">海森矩阵与牛顿法</h2>
<p>二阶可微函数<span class="math inline">\(f(x)\)</span>在<span class="math inline">\(x_0\)</span>处的二阶展开式 <span class="math display">\[f(x) = f(x_0)+g_0^T(x-x_0)+\frac1{2}(x-x_0)^TH_0(x-x_0)+o^n\]</span> 其中<span class="math inline">\(x,x_0\)</span>都是向量, <span class="math inline">\(g_0\)</span>是<span class="math inline">\(x_0\)</span>处的梯度向量，<span class="math inline">\(H_0\)</span>是<span class="math inline">\(x_)\)</span>处的海森矩阵。</p>
<ul>
<li>当<span class="math inline">\(x_0\)</span>处梯度<span class="math inline">\(g_0=0\)</span>且海森矩阵<span class="math inline">\(H_0\)</span>是正定矩阵时，<span class="math inline">\(x_0\)</span>为极小值。</li>
</ul>
<p>证明：正定矩阵<span class="math inline">\(H_0\)</span>必满足对任意非零向量<span class="math inline">\(x\)</span>有<span class="math inline">\(x^TH_0x&gt;0\)</span>。那么对于<span class="math inline">\(\triangle x\)</span>有<span class="math inline">\(f(x_0+\triangle x)&gt;f(x_0)\)</span>。</p>
<ul>
<li>牛顿法的迭代公式</li>
</ul>
<p>说明：由极小值的必要条件，对<span class="math inline">\(f(x)\)</span>进行求导并且令倒数为0，有<span class="math inline">\(g_0+H_0(x-x_0)=0\)</span>。 得到<span class="math inline">\(x = x_0-\frac{g_0}{H_0}\)</span>，将其作为迭代公式。</p>
<ul>
<li>牛顿法的缺点</li>
</ul>
<p>有两个：1.计算海森矩阵的逆矩阵的计算量比较大；2.海森矩阵的存储空间需求比较大</p>
<p>因此需要拟牛顿法，思路是找一个矩阵来近似海森矩阵的逆矩阵。</p>
<p>牛顿法为什么收敛快：牛顿法是二阶收敛，梯度下降是一阶收敛，所以牛顿法就更快。如果更通俗地说的话，比如你想找一条最短的路径走到一个盆地的最底部，梯度下降法每次只从你当前所处位置选一个坡度最大的方向走一步，牛顿法在选择方向时，不仅会考虑坡度是否够大，还会考虑你走了一步之后，坡度是否会变得更大。所以，可以说牛顿法比梯度下降法看得更远一点，能更快地走到最底部。</p>
<p>参考：</p>
<ul>
<li>梯度下降法、牛顿法和拟牛顿法 <a href="https://zhuanlan.zhihu.com/p/37524275" target="_blank" rel="noopener">链接</a></li>
<li>最优化问题中，牛顿法为什么比梯度下降法求解需要的迭代次数更少？ <a href="https://www.zhihu.com/question/19723347/answer/14636244" target="_blank" rel="noopener">链接</a></li>
</ul>
<h2 id="线性回归和局部加权线性回归">线性回归和局部加权线性回归</h2>
<ul>
<li>二者的基本公式可参考我的博客“LR vs LWLR”：<a href="https://wolfbrother.blog.csdn.net/article/details/46778039" target="_blank" rel="noopener">链接</a>，注意那张插图所说明的LWLR的应用场景的例子。</li>
<li>贝叶斯框架推到线性回归公式，关于先验、后验、似然函数、贝叶斯公式：<a href="https://zhuanlan.zhihu.com/p/44809220" target="_blank" rel="noopener">链接</a></li>
<li>线性回归是局部加权线性回归的特殊形式，具体的加权矩阵是单位矩阵，某个样本的损失函数就是其本身的损失函数值。而局部加权线性回归里，一个样本的损失函数，是与其它所有的样本（包括其自身）的损失函数值的乘积的加权和。当计算一个新的样本值的输出值<span class="math inline">\(y\)</span>时，首先计算其损失函数（是一个关于<span class="math inline">\(y\)</span>的二次函数），然后求解<span class="math inline">\(y\)</span>。</li>
</ul>
<h2 id="l2和l1正则化">L2和L1正则化</h2>
<ul>
<li>参考：<a href="https://blog.csdn.net/golden1314521/article/details/46778369" target="_blank" rel="noopener">链接</a></li>
<li>L2正则化又叫岭回归，有解析解。岭回归是一种专用于共线性数据分析的有偏估计回归方法，实质上是一种改良的最小二乘估计法，通过放弃最小二乘法的无偏性，以损失部分信息、降低精度为代价获得回归系数更为符合实际、更可靠的回归方法，对病态数据的拟合要强于普通最小二乘法。那么什么样得数据算是病态数据，主要有两种，一种是数据点少于变量数（特征维数），这种情况下特征信息矩阵维数无法求逆，不满足最小二乘得条件；第二种是自变量中的某几个存在多重共线性，对于这样得数据虽然可得到无偏解，但是却有可能和实际情况相差甚远（<a href="https://lidongxuan.github.io/blog/regression" target="_blank" rel="noopener">链接</a> 和 <a href="https://www.zhihu.com/question/28221429/answer/53858036" target="_blank" rel="noopener">链接</a> ）。</li>
<li><p>L1正则化的lasso算法思想：每次迭代中，依次对权值向量的每个值，增大或者减小一个小量（就像梯度下降算法里对自变量的改变一样）同时权值向量的其他值保持不变，计算函数值；对每次迭代里，函数值最优的那个改变（包括权值的位置，该变量的方向）作为本次迭代的改进（参见牛客网的 <a href="https://www.nowcoder.com/tutorial/95/a785d36cf4264dfa93c3de133d0bb339" target="_blank" rel="noopener">链接</a> 所提到的坐标轴下降法）。</p></li>
<li><p><a href="https://www.zhihu.com/question/23536142/answer/90135994" target="_blank" rel="noopener">LR正则化与数据先验分布的关系？</a> 从贝叶斯的角度来看, 正则化等价于对模型参数引入先验分布, L2相当于参数向量的高斯先验分布，L1X相当于参数向量的拉普拉斯先验分布。</p></li>
</ul>
<h4 id="二者特点">二者特点</h4>
<ul>
<li>都能让参数向量值变小 （<a href="https://www.cnblogs.com/alexanderkun/p/6922428.html" target="_blank" rel="noopener">正则化为什么能防止过拟合</a>）。</li>
<li>L2 并不具有产生稀疏解的能力，也就是说参数并不会真出现很多零。假设我们的预测结果与两个特征相关，L2正则倾向于综合两者的影响，给影响大的特征赋予高的权重；</li>
<li>而 L1 正则倾向于选择影响较大的参数，而舍弃掉影响较小的那个；</li>
<li>实际应用中 L2正则表现往往会优于 L1正则，但 L1正则会大大降低我们的 计算量（因为参数少吧）</li>
</ul>
]]></content>
      <categories>
        <category>ML-AI</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习概念总结三分之二部</title>
    <url>/2019/09/09/ML-AI/2019-09-09-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E4%B8%89%E5%88%86%E4%B9%8B%E4%BA%8C%E9%83%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="过拟合">过拟合</h2>
<p>随着训练过程的进行，在训练集上的错误率渐渐减小，但是在验证集上的错误率却反而渐渐增大。也就是说训练出来的网络过拟合了训练集，对训练集外的数据却不工作。</p>
<p>过拟合是一种在项目实践中遇到的一个常见的现象，并不是一种高深的理论。“简单函数的泛化能力更好”不是一个有着坚实理论和数学基础的理论定理，它只是在长久的数据科学项目中，数据科学家们发现的一个普遍现象。可以理解为属于 经验科学 的一个范畴，简单的模型不容易产生过拟合，简单的模型泛化能力更好，甚至所谓的奥卡姆剃刀原理。这个经验在很多时候是有效的，我们也没有什幺理由不去应用这个经验。毕竟数据科学还是一个偏向实践和以结果说话的学科，得到好的结果是最重要的。</p>
<p>过拟合的原因 （<a href="https://zhuanlan.zhihu.com/p/26122044" target="_blank" rel="noopener">大白话解释模型产生过拟合的原因</a>有具体的例子，<a href="https://flashgene.com/archives/11824.html" target="_blank" rel="noopener">浅议过拟合现象(overfitting)以及正则化技术原理</a>）： + 数据有噪声 + 训练数据不足，在有限的样本中搜索过大的模型空间 + 训练模型过度导致模型非常复杂</p>
<p>避免过拟合的方法 （<a href="https://zhuanlan.zhihu.com/p/26122044" target="_blank" rel="noopener">大白话解释模型产生过拟合的原因</a>）：</p>
<ul>
<li>early stopping</li>
<li>数据集扩增（Data augmentation）</li>
<li>正则化（Regularization）包括L1、L2（L2 regularization也叫weight decay）</li>
<li>dropout (<a href="https://www.cnblogs.com/alexanderkun/p/6922428.html" target="_blank" rel="noopener">正则化为什么能防止过拟合</a>)。</li>
<li>最大池化层（maxpool）</li>
</ul>
<p>其它：</p>
<ul>
<li><a href="https://www.jianshu.com/p/a9cc62db419e" target="_blank" rel="noopener">正则化为什么能防止过拟合</a> 直观地说明了在多项式拟合里，为什么过拟合的系数比较大，进而说明正则化（不管是L1还是L2都能让参数趋于小）对过拟合有用：过拟合，就是拟合函数需要顾忌每一个点，最终形成的拟合函数波动很大。在某些很小的区间里，函数值的变化很剧烈。这就意味着函数在某些小区间里的导数值（绝对值）非常大，由于自变量值可大可小，所以只有系数足够大，才能保证导数值很大。</li>
<li>术语&quot;泛化&quot;指的是一个假设模型能够应用到新样本的能力。新样本数据是指没有出现在训练集中的数据。</li>
</ul>
<h4 id="高偏差与高方差"><a href="https://www.jianshu.com/p/a585d5506b1e" target="_blank" rel="noopener">高偏差与高方差</a></h4>
<ul>
<li>过拟合意味着高方差，欠拟合意味着高偏差（https://www.cnblogs.com/jianxinzhou/p/4083921.html ）</li>
<li>偏差（bias）：我们要预测第二天的收益，而估值指标经常用于长线投资，虽然每次预测都是信誓旦旦，但是模型从本质上就把目标搞错了。</li>
<li>方差（variance）：过多的已知条件，导致模型无法给出确定的预测，预测结果和瞎蒙一样，给人的感觉是不靠谱。</li>
<li>无法消除的误差：我们都知道，完美预测第二天的情况，是不可能的。这样的误差难以消除，我们希望它越小越好，一般就忽略掉了。所以，我们可以优化的误差=偏差+方差 相关描述可以看一下知乎答案：<a href="https://www.zhihu.com/question/20700829/answer/119314862" target="_blank" rel="noopener">链接</a></li>
</ul>
<h2 id="贝叶斯学派和频率学派">贝叶斯学派和频率学派</h2>
<ul>
<li>先验概率、似然函数与后验概率</li>
</ul>
<p>似然函数（likelihood function），也称作似然，是一个关于统计模型参数的函数。也就是这个函数中自变量是统计模型的参数。对于结果 x ，在参数集合 θ 上的似然，就是在给定这些参数值的基础上，观察到的结果的概率 <span class="math inline">\(L(θ\mid x)=P(x\mid θ)\)</span>。也就是说，似然是关于参数的函数，在参数给定的条件下，对于观察到的 x 的值的条件分布。</p>
<p>用<span class="math inline">\((θ)\)</span>表示概率分布函数，用 <span class="math inline">\(p(x\mid θ)\)</span>表示观测值 x 的似然函数。后验概率定义为： <span class="math inline">\(p(θ\mid x)=\frac{p(x\mid θ)p(θ)}{p(x)}\)</span> 。由于分母不变，可以表达成如下正比关系： 后验概率<span class="math inline">\(p(θ\mid x)\)</span> ∝ 似然函数<span class="math inline">\(p(x\mid θ)\)</span>×先验概率p(x)</p>
<p><a href="https://www.cnblogs.com/wjgaas/p/4523779.html" target="_blank" rel="noopener">先验概率、似然函数与后验概率</a> 最大后验概率和极大似然估计很像，只是多了一项先验分布，它体现了贝叶斯认为参数也是随机变量的观点，在实际运算中通常通过超参数给出先验分布。极大似然估计和最大后验概率都是参数的点估计。在频率学派中，参数固定了，预测值也就固定了。最大后验概率是贝叶斯学派的一种近似手段，因为完全贝叶斯估计不一定可行。另一方面，最大后验概率可以看作是对先验和MLE的一种折衷，如果数据量足够大，最大后验概率和最大似然估计趋向于一致，如果数据为0,最大后验仅由先验决定。</p>
<p>用抛硬币的例子来依次讲解极大似然估计、最大后验概率估计和贝叶斯估计：<a href="https://blog.csdn.net/yangliuy/article/details/8296481" target="_blank" rel="noopener">链接</a></p>
<h2 id="拉格朗日乘子法">拉格朗日乘子法</h2>
<p>分为只含有等式约束，以及含有不等式约束两种情况。</p>
<h4 id="只有等式约束">只有等式约束</h4>
<p>参考 维基百科<a href="https://zh.wikipedia.org/wiki/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B9%98%E6%95%B0" target="_blank" rel="noopener">拉格朗日乘数</a>。例如如下特征，即目标函数取极值时目标函数和各个等式约束的在该极值处相切，即它们在极值处梯度方向相等或者相反，即它们的各个偏导数成比例关系。</p>
<p>举例：<span class="math inline">\(f(x,y)\)</span>在<span class="math inline">\(g(x,y) = c\)</span>约束下的极值问题，则极值点<span class="math inline">\((x_0,y_0)\)</span>处有<span class="math inline">\(f_x+\lambda g_x = 0, f_y+\lambda g_y=0\)</span>，同时有<span class="math inline">\(g(x_0,y_0)=c\)</span>。因此就将原来的约束优化问题，转换成如下拥有三个自变量<span class="math inline">\((x,y,\lambda)\)</span>的无约束极值问题 <span class="math inline">\(f(x,y)+\lambda (g(x,y)-c)\)</span>，其中<span class="math inline">\(\lambda\)</span>任意取值。</p>
<p>对该无约束问题进行分析，由于<span class="math inline">\(\lambda\)</span>可以任意取值，因此只能由<span class="math inline">\(g(x,y)-c=0\)</span>，另外取极值时梯度为0，即<span class="math inline">\(f&#39;+\lambda g&#39;=0\)</span>，可见于原约束优化问题是等价的。</p>
<p>其中原约束优化问题是“原始问题”，转换后的无约束优化问题是“对偶问题”，二者最优解等价的条件就是取该最优解时满足<span class="math inline">\(f&#39;+\lambda g&#39;=0\)</span>和<span class="math inline">\(g=c\)</span>。</p>
<h4 id="含有不等式约束">含有不等式约束</h4>
<p>参考《统计学习方法》附录C的“<a href="https://zhuanlan.zhihu.com/p/38182879" target="_blank" rel="noopener">拉格朗日对偶性</a>”，关于原始问题和对偶问题的最优解相等的时候该最优解必须满足的KKT条件。</p>
<p>参考等式约束情况下原始问题到对偶问题的转化，以及最优解需满足的KKT条件（包含两部分，原始问题的约束条件，以及梯度条件）。</p>
<h4 id="对偶问题和kkt条件">对偶问题和KKT条件</h4>
<p>猜测引入对偶问题的原因，是方便推导出KKT条件，进而通过求解KKT条件来求解原始问题。</p>
<h2 id="共轭先验">共轭先验</h2>
<p>在贝叶斯统计中，如果后验分布与先验分布属于同类，则先验分布与后验分布被称为共轭分布，而先验分布被称为似然函数的共轭先验。共轭先验的好处主要在于代数上的方便性，可以直接给出后验分布的封闭形式，否则的话只能数值计算。共轭先验也有助于获得关于似然函数如何更新先验分布的直观印象。</p>
]]></content>
      <categories>
        <category>ML-AI</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习概念总结三分之三部</title>
    <url>/2019/09/09/ML-AI/2019-09-09-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E4%B8%89%E5%88%86%E4%B9%8B%E4%B8%89%E9%83%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="生成模型和判别模型">生成模型和判别模型</h2>
<h4 id="生成模型">生成模型</h4>
<ul>
<li>有朴素贝叶斯和隐形马尔科夫链。</li>
</ul>
<h4 id="判别模型">判别模型</h4>
<ul>
<li>有感知机、k近邻、决策树、逻辑斯蒂回归和最大熵、支持向量机、提升方法、提交随机场。</li>
</ul>
<h2 id="损失函数">损失函数</h2>
<h4 id="误分点到超平面距离">误分点到超平面距离</h4>
<h4 id="对数似然损失">对数似然损失</h4>
<h4 id="逻辑斯蒂损失">逻辑斯蒂损失</h4>
<h4 id="合页损失">合页损失</h4>
<h4 id="指数损失">指数损失</h4>
<h2 id="评估结果的几个参数">评估结果的几个参数</h2>
<ul>
<li>查准率和查全率，可以根据字面理解其含义，并画出图 <a href="https://img-blog.csdn.net/20150707170145495" target="_blank" rel="noopener">连接</a> ，并结合图给出真阳率和真阴率的概念。另外，查准率和查全率分别对应精确率P和召回率R，以这样的方式来记忆准确率和召回率，不然就太难记了。</li>
<li>然后根据精确率P和召回率R写出 <span class="math inline">\(F_1=\frac{PR}{P+R}\)</span> 的公式，以及准确率的公式<span class="math inline">\(A_{cc}=\frac{TN+TP}{ALL}\)</span>。然后给出ROC曲线的横坐标和纵坐标（分别是假阳率和真阳率），以及AUC的含义。</li>
<li>以上面的图结合ROC来分析，横纵坐标分别是途中的判别线（虚线）左侧的两个部分分别占所在椭圆的比例，而AUC的大小可以用来作为两个椭圆映射到与水平方向上的重合度，这个重合度与模型的判别效果有关。具体的，判别效果最差的情况，二者重合，那么假阳率和真阳率的变化相同，是一条直线，AUC是0.5；最好的情况，二者完全没有重合，则是个直角，AUC是1。</li>
<li>物体识别领域的MAP（mean average precision）的概念，以及从P到AP再到MAP的层层递进。可以参考 <a href="https://blog.csdn.net/katherine_hsr/article/details/79266880" target="_blank" rel="noopener">连接</a>
<ul>
<li>P是某一张图片里某个类的物体，能够检测到的个数除以该类物体的总的个数</li>
<li>AP是对于某个类，所有照片的P值的均值</li>
<li>MAP是AP在所有类上的均值。</li>
</ul></li>
</ul>
<p>## 深度学习中梯度消失，和激活函数Relu，sigmoid ，tanh的区别</p>
<ul>
<li>激活函数通常有以下性质：
<ul>
<li>非线性：如果激活函数都为线性，那么神经网络的最终输出都是和输入呈线性关系（矩阵连乘）；显然这不符合事实。</li>
<li>可导性：神经网络的优化都是基于梯度的，求解梯度时需要确保函数可导。</li>
<li>单调性:激活函数是单调的，否则不能保证神经网络抽象的优化问题为凸优化问题了。</li>
<li>输出范围有限：激活函数的输出值的范围是有限时，基于梯度的方法会更加稳定。</li>
</ul></li>
<li>参考<a href="http://www.voidcn.com/article/p-tmaepxar-bms.html" target="_blank" rel="noopener">连接</a> 和<a href="https://zhuanlan.zhihu.com/p/38537439" target="_blank" rel="noopener">连接</a></li>
<li>梯度牵涉到链式求导运算，每层因子相乘的结果不断减小，产生梯度消失，会造成网络的前层网络的权重的梯度很小，这些w很可能得不到更新；而如果相乘的结果越来越大，则产生梯度爆炸。sigmoid和tanh都有这个问题，而relu没有。如下解决办法:
<ul>
<li>1、使用relu类激活函数，他们求导过程中梯度为1，不同网络层的权重可以得到同速度的更新</li>
<li>2、Batch normalization. 具有加速网络收敛速度，提升训练稳定性的效果，Batchnorm本质上是解决反向传播过程中的梯度问题。batchnorm全名是batch normalization，简称BN，即批规范化，通过规范化操作将输出信号x规范化保证网络的稳定性。batchnorm就是通过对每一层的输出规范为均值和方差一致的方法，消除了每层x带来的放大缩小的影响，进而解决梯度消失和爆炸的问题，或者可以理解为BN将输出从饱和区拉倒了非饱和区。</li>
<li>3、残差网络。非常深的网络很难训练，存在梯度消失和梯度爆炸问题，学习 skip connection它可以从某一层获得激活，然后迅速反馈给另外一层甚至更深层，利用 skip connection可以构建残差网络ResNet来训练更深的网络，ResNet网络是由残差模块构建的</li>
</ul></li>
<li>ReLU 也有缺点，就是训练的时候很”脆弱”，很容易就”die”了。一个非常大的梯度流过一个 ReLU 神经元，更新过参数之后，这个神经元再也不会对任何数据有激活现象了。如果这个情况发生了，那么这个神经元的梯度就永远都会是0.实际操作中，如果你的learning rate 很大，那么很有可能你网络中的40%的神经元都”dead”了。 当然，如果你设置了一个合适的较小的learning rate，这个问题发生的情况其实也不会太频繁。</li>
<li>单纯看sigmoid，它主要有以下缺点：
<ul>
<li>梯度消失（Gradient Vanishing） 会导致BP时，w的系数太小，w更新很慢。所以对初始化时要特别注意，避免过大的初始值使神经元进入饱和区。</li>
<li>输出不是zero-center 这会导致后层的神经元的输入是非0均值的信号，这会对梯度产生影响：假设后层神经元的输入都为正(e.g. x&gt;0 elementwise in ),那么对w求局部梯度则都为正，这样在反向传播的过程中w要么都往正方向更新，要么都往负方向更新，导致有一种捆绑的效果，使得收敛缓慢。 如果你是按batch去训练，那么每个batch可能得到不同的符号（正或负），那么相加一下这个问题还是可以缓解</li>
<li>指数运算耗时，计算效率低</li>
</ul></li>
<li>tanh和relu相比sigmoid计算效率高，但tanh和sigmoid都有梯度消失现象，而relu容易死。</li>
</ul>
]]></content>
      <categories>
        <category>ML-AI</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2019/09/09/algs/general/2019-09-10-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="归并排序">归并排序</h2>
<p>如下归并排序的代码里，merge函数里采用了一个辅助数组temp，用来存储排序后的数组，然后再拷贝到原数组。由于排序的复杂度是n，拷贝也是n，因此复杂度是2n。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergesort</span><span class="params">(nums, l, r)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> l == r:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    mid = (l + r)&gt;&gt;<span class="number">1</span></span><br><span class="line">    mergesort(nums, l, mid)</span><br><span class="line">    mergesort(nums, mid+<span class="number">1</span>, r)</span><br><span class="line">    merge(nums, l, r)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(nums, l, r)</span>:</span></span><br><span class="line">    mid = (l + r)&gt;&gt;<span class="number">1</span></span><br><span class="line">    i, j = l, mid + <span class="number">1</span></span><br><span class="line">    temp = []</span><br><span class="line">    <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= r:</span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt;= nums[j]:</span><br><span class="line">            temp.append(nums[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            temp.append(nums[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= mid:</span><br><span class="line">        temp.append(nums[i])</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &lt;= r:</span><br><span class="line">        temp.append(nums[j])</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(l, r + <span class="number">1</span>):</span><br><span class="line">        nums[i] = temp[i-l]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>partition</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的遍历：递归、非递归和分层</title>
    <url>/2019/09/09/algs/general/2019-09-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%EF%BC%9A%E9%80%92%E5%BD%92%E3%80%81%E9%9D%9E%E9%80%92%E5%BD%92%E5%92%8C%E5%88%86%E5%B1%82/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>首先创建一棵树，用于测试</p>
<pre><code>     A
   /   \
  B     C
 /    /   \
D    E     F
      \   / \
       G H   I</code></pre>
<p>建树语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = None</span><br><span class="line">        self.right = None</span><br><span class="line"></span><br><span class="line">L = &#123;&apos;A&apos;: TreeNode(&apos;A&apos;),&apos;B&apos;: TreeNode(&apos;B&apos;),&apos;C&apos;: TreeNode(&apos;C&apos;),&apos;D&apos;: TreeNode(&apos;D&apos;), &apos;E&apos;: TreeNode(&apos;E&apos;), &apos;F&apos;: TreeNode(&apos;F&apos;),&apos;G&apos;: TreeNode(&apos;G&apos;), &apos;H&apos;: TreeNode(&apos;H&apos;), &apos;I&apos;: TreeNode(&apos;I&apos;)&#125;</span><br><span class="line"></span><br><span class="line">L[&apos;F&apos;].left, L[&apos;F&apos;].right = L[&apos;H&apos;], L[&apos;I&apos;]</span><br><span class="line">L[&apos;E&apos;].right = L[&apos;G&apos;]</span><br><span class="line">L[&apos;C&apos;].left, L[&apos;C&apos;].right = L[&apos;E&apos;], L[&apos;F&apos;]</span><br><span class="line">L[&apos;A&apos;].left, L[&apos;A&apos;].right = L[&apos;B&apos;], L[&apos;C&apos;]</span><br><span class="line">L[&apos;B&apos;].left = L[&apos;D&apos;]</span><br><span class="line">root = L[&apos;A&apos;]</span><br></pre></td></tr></table></figure>
<h2 id="递归遍历">递归遍历</h2>
<p>递归遍历用了递归，不借助于栈和队列。而循环遍历要用到栈，分层遍历要用到队列。</p>
<h3 id="先根遍历">先根遍历</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preroot</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> [] <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span>  [root.val] + preroot(root.left) + preroot(root.right)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<blockquote>
<p>['A', 'B', 'D', 'C', 'E', 'G', 'F', 'H', 'I']</p>
</blockquote>
<h3 id="中根遍历">中根遍历</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">midroot</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> [] <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> midroot(root.left) + [root.val] + midroot(root.right)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<blockquote>
<p>['D', 'B', 'A', 'E', 'G', 'C', 'H', 'F', 'I']</p>
</blockquote>
<h3 id="后根遍历">后根遍历</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postroot</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> [] <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> postroot(root.left) + postroot(root.right) + [root.val]</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<blockquote>
<p>['D', 'B', 'G', 'E', 'H', 'I', 'F', 'C', 'A']</p>
</blockquote>
<h2 id="非递归遍历">非递归遍历</h2>
<p>非递归遍历就是循环遍历，要用到栈，而非队列；而层次遍历要用队列，而非栈。一个直观解释：</p>
<ul>
<li>从递归遍历的代码可以看出遍历序列的一个性质：深度优先遍历（包括先序、中序和后序）的打印序列，节点、其左子树序列和右子树序列这三者不会有两两交叉，即节点不会在其左子树或右子树序列里被打印，其左子树和右子树序列也是分开的。而且，打印序列里的左子树序列总是位于右子树序列之前。</li>
<li>遍历树结构时，总是先拿到节点，然后才能拿到其孩子。
<ul>
<li>对于中序、后序遍历里的节点和左子树，节点总是先被添加进该数据结构，等待左子树所有节点被打印之后，才会把该节点取出并打印。显然该数据结构是栈而非队列。</li>
<li>对于先序如果该数据结构用队列，每个循环访问一个队列元素，而且左右孩子都要添加进队列，那么势必有节点的左孩子的孩子节点位列该节点的右孩子之后，而队列里位置先后意味着访问顺序的先后。</li>
</ul></li>
<li>而层次遍历可以先进来先打印，故要用队列，而不是栈。</li>
</ul>
<p>难点：</p>
<ul>
<li>三个概念：拿到节点，访问节点，打印节点。
<ul>
<li>拿到节点，是节点首次进栈，有的程序一个节点只进栈一次</li>
<li>访问节点，是从栈里读取（不出栈）或者抛出节点</li>
<li>打印节点，是从栈里抛出节点并打印</li>
</ul></li>
<li>先根遍历里，拿到节点先入栈；第一次访问时，就打印节点值并将其从栈里抛出并将其两个孩子节点压入栈，因此只访问一次。</li>
<li>在中根和后根遍历里，拿到节点之后先入栈。第一次访问节点并不打印其值，而是先入栈其左孩子节点，或者全部的两个孩子节点。第二次访问是才要抛出栈并打印，如果右孩子在第一次访问时未入栈，则还要入栈其右孩子节点。由于两访问时的操作不同，需要对该访问次数有个记录才行。</li>
</ul>
<h3 id="先根遍历-1">先根遍历</h3>
<p>抛出栈并打印节点值后，先入栈右孩子，再入栈左孩子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">npreroot</span><span class="params">(root)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    stack.append(root)</span><br><span class="line">    <span class="keyword">while</span> len(stack) &gt; <span class="number">0</span>:</span><br><span class="line">        node = stack.pop(<span class="number">-1</span>)  </span><br><span class="line">        res.append(node.val)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            stack.append(node.right)</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            stack.append(node.left)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="中根遍历-1">中根遍历</h3>
<h4 id="节点和状态绑定执行入栈出栈">节点和状态绑定执行入栈出栈</h4>
<ul>
<li>第一次访问对节点做访问记录，不打印节点值而是去压其左孩子节点入栈（毕竟中序遍历，即遍历完左子树再访问该节点的值）</li>
<li>第二次访问打印该节点的值并抛出栈，以及压其右孩子节点入栈。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nmidroot</span><span class="params">(root)</span>:</span></span><br><span class="line">    res, stack = [], []</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    stack.append((root, <span class="literal">False</span>))</span><br><span class="line">    <span class="keyword">while</span> len(stack) &gt; <span class="number">0</span>:</span><br><span class="line">        node, visited = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> visited:</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append((node.right, <span class="literal">False</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            stack.append((node, <span class="literal">True</span>))</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append((node.left, <span class="literal">False</span>))</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="贪婪策略找最深左孩子">贪婪策略找最深左孩子</h4>
<ul>
<li>访问每个节点时，先用贪婪找到其最深的左孩子，该过程中找到的所有左孩子依次入栈，然后依次出栈打印。</li>
<li>打印每个节点时，查看该节点有无右孩子，如果有则入栈。</li>
<li>贪婪策略和变量nextn共同发挥了log记录状态的作用。贪婪策略的存在，使得不用再根据节点访问状态来决定是是访问左孩子还是打印或者访问右孩子。如果nextn为空，则打印节点；不然继续将孩子压入栈。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nmidroot</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: </span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">    res, stack = [], []   </span><br><span class="line">    nextn = root <span class="comment"># 下一个要入栈的节点</span></span><br><span class="line">    <span class="keyword">while</span> nextn <span class="keyword">or</span> stack:         </span><br><span class="line">        <span class="keyword">while</span> nextn: </span><br><span class="line">            stack.append(nextn)</span><br><span class="line">            nextn = nextn.left </span><br><span class="line">        current = stack.pop() <span class="comment"># 要打印的节点</span></span><br><span class="line">        res.append(current.val) </span><br><span class="line">        nextn = current.right     </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="后根遍历-1">后根遍历</h3>
<h4 id="状态记录和节点绑定入栈左右孩子一起入栈">状态记录和节点绑定入栈，左右孩子一起入栈</h4>
<ul>
<li>后根遍历和先根遍历，都可以<code>左右孩子一起入栈</code>，这能减少程序逻辑的工作量。原因在于，左右孩子之间没有根节点。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">npostroot</span><span class="params">(root)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>: </span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">    res, stack = [], [(root, <span class="literal">False</span>)]   </span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        current, visited = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> visited: <span class="comment"># 只有访问状态为True的节点才能被操作</span></span><br><span class="line">            res.append(current.val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            stack.append((current, <span class="literal">True</span>))</span><br><span class="line">            <span class="keyword">if</span> current.right:</span><br><span class="line">                stack.append((current.right, <span class="literal">False</span>))</span><br><span class="line">            <span class="keyword">if</span> current.left:</span><br><span class="line">                stack.append((current.left, <span class="literal">False</span>))               </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="右孩子在打印节点之后入栈有右子树会被访问三次">右孩子在打印节点之后入栈，有右子树会被访问三次</h4>
<p>循环（访问）次数偏多的原因：没有利用<code>左右孩子一起入栈</code>这个特性，反而最大限度地利用log来查询节点状态。</p>
<ul>
<li>确定左子树已经访问（打印）完毕之后才将右孩子入栈</li>
<li>有右孩子的节点会被访问三次，无右孩子的节点会被访问两次
<ul>
<li>有右孩子的，第二次访问不打印，而是将右孩子入栈；第三次访问时右子树已被访问并打印，才打印本节点</li>
<li>无右孩子的，第二次就打印</li>
</ul></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">npostroot</span><span class="params">(root)</span>:</span></span><br><span class="line">    stack = [root]</span><br><span class="line">    log = []</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> len(stack) &gt; <span class="number">0</span>:</span><br><span class="line">        node = stack[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> log: <span class="comment"># 第一次访问</span></span><br><span class="line">            log.append(node)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)     </span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="comment"># 第二次访问，没有右孩子或者右子树已被访问的时候，打印节点值</span></span><br><span class="line">            <span class="comment"># 如果有右孩子且右孩子未被访问，则不打印该节点，而是将其右孩子节点入栈</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.right: <span class="comment"># 没有右节点，则打印，属于第二次访问本节点</span></span><br><span class="line">                res.append(stack.pop(<span class="number">-1</span>).val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> node.right <span class="keyword">not</span> <span class="keyword">in</span> log:  </span><br><span class="line">                    <span class="comment"># 右节点未被访问过，也意味着右子树节点都未被拿到过，属于第二次访问，还会有第三次访问</span></span><br><span class="line">                    stack.append(node.right)</span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># 右子树被访问过，属于第三次访问本节点</span></span><br><span class="line">                    <span class="comment"># 右孩子被访问过，在这里也意味着打印过，也意味着整个右子树打印过</span></span><br><span class="line">                    res.append(stack.pop(<span class="number">-1</span>).val)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="贪婪策略入栈和出栈两个迭代">贪婪策略，入栈和出栈两个迭代</h4>
<ul>
<li>左孩子迭代入栈：访问每个节点时，先用贪婪策略找到其最深的左孩子，该过程中找到的所有左孩子依次入栈，直到没有左孩子。</li>
<li>迭代出栈：依次出栈，打印，直到节点有右孩子。有右孩子且右子树未被访问，则对右孩子做<code>左孩子迭代入栈</code>操作。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">npostroot</span><span class="params">(root)</span>:</span></span><br><span class="line">    res, stack = [], []</span><br><span class="line">    nextn = root <span class="comment"># 下一个压入栈的节点</span></span><br><span class="line">    <span class="keyword">while</span> nextn <span class="keyword">or</span> len(stack) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">while</span> nextn:</span><br><span class="line">            stack.append((nextn, <span class="literal">False</span>))</span><br><span class="line">            nextn = nextn.left</span><br><span class="line">        <span class="keyword">while</span> len(stack) &gt; <span class="number">0</span>:</span><br><span class="line">            node, visited = stack.pop(<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> visited:</span><br><span class="line">                stack.append((node, <span class="literal">True</span>))</span><br><span class="line">                nextn = node.right</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(node.val)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="利用打印节点和栈顶节点的关系来推测状态">利用打印节点和栈顶节点的关系来推测状态</h4>
<p>节点状态、访问次数，其实意味着是从左子树回来还是从右子树回来，那么如果能利用打印节点和栈顶节点的关系来推测状态，就可以不用记录节点状态或者访问次数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">npostroot</span><span class="params">(root)</span>:</span></span><br><span class="line">    stack = []</span><br><span class="line">    nextn = root <span class="comment"># 下一个要入栈的节点</span></span><br><span class="line">    res = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> nextn <span class="keyword">or</span> len(stack) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">while</span> nextn:</span><br><span class="line">            stack.append(nextn)</span><br><span class="line">            nextn = nextn.left <span class="keyword">if</span> nextn.left <span class="keyword">else</span> nextn.right </span><br><span class="line">        node = stack.pop() <span class="comment"># 出栈并打印的节点</span></span><br><span class="line">        res.append(node.val)</span><br><span class="line">        <span class="keyword">if</span> len(stack) &gt; <span class="number">0</span> <span class="keyword">and</span> stack[<span class="number">-1</span>].left == node: </span><br><span class="line">            <span class="comment"># 从栈顶二叉树的左子树回来，就直接将右孩子压入栈</span></span><br><span class="line">            nextn = stack[<span class="number">-1</span>].right</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 从栈顶二叉树的右子树回来，就访问栈顶二叉树的根节点</span></span><br><span class="line">            nextn = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="利用后序的反序列与先序关系">利用后序的反序列与先序关系</h4>
<p>后序遍历的顺序是<code>左右根</code>，那么其反序是<code>根右左</code>，和先序遍历的<code>根左右</code>的左右顺序相反，那么只要把代码里访问左右节点的顺序互换就好了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">npostroot</span><span class="params">(root)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    stack.append(root)</span><br><span class="line">    <span class="keyword">while</span> len(stack) &gt; <span class="number">0</span>:</span><br><span class="line">        node = stack.pop(<span class="number">-1</span>)  </span><br><span class="line">        res.append(node.val)</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            stack.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            stack.append(node.right)</span><br><span class="line">    <span class="keyword">return</span> res[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h2 id="分层遍历">分层遍历</h2>
<p>与先根、后根、中根遍历不同，分层遍历里同一层的节点在同一个访问批次，它们的孩子节点在之后的批次被访问。这种区别导致分层遍历可以用队列这种数据结构，而不是栈。</p>
<p>分层遍历属于广度优先遍历，而先根、中根和后根都是深度优先遍历。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">levelroot</span><span class="params">(root)</span>:</span></span><br><span class="line">    queue = [root]</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> len(queue) &gt; <span class="number">0</span>:</span><br><span class="line">        node = queue.pop(<span class="number">0</span>)</span><br><span class="line">        res.append(node.val)</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            queue.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            queue.append(node.right)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<blockquote>
<p>['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I']</p>
</blockquote>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title>力扣0322-零钱兑换</title>
    <url>/2019/09/09/algs/leetcode/0322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>问题</p>
<p>给定不同面额的硬币(coins)和一个总金额(amount) 。写一个函数来计算可以凑成总金额所需的最少的硬币个数，如果没有任何一种硬币组合能满足，返回 -1。</p>
<p>示例1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：coins = [1, 2, 5], amount = 11</span><br><span class="line">输出：3 (5+5+1)</span><br></pre></td></tr></table></figure>
<p>示例2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：coins = [2], amount = 3</span><br><span class="line">输出：-1 (无法满足)</span><br></pre></td></tr></table></figure>
<hr>
<p>核心在于应用动态规划思想，有递归和非递归连个版本的实现方案。</p>
<p>用动态规划和递归的实现版本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coins</span><span class="params">(coinL,Sum)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> Sum &lt; min(coinL):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> Sum <span class="keyword">in</span> coinL:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    minNum = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> coin <span class="keyword">in</span> coinL:</span><br><span class="line">        coinret = coins(coinL, Sum-coin)</span><br><span class="line">        <span class="keyword">if</span> coinret &gt; <span class="number">0</span>: <span class="comment"># 无解的情况的直接忽略</span></span><br><span class="line">            <span class="keyword">if</span> minNum <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                minNum = coinret</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> minNum &gt; coinret:</span><br><span class="line">                    minNum = coinret</span><br><span class="line">    <span class="keyword">if</span> minNum <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+minNum</span><br></pre></td></tr></table></figure>
<p>想进一步将上述递归该成尾递归，进而去掉尾递归以提高效率，却发现不容易做。通过对比猜测原因：回溯法（如智能体版本的八皇后）实现的递归，比较容易改成尾递归；或者无分叉的递归（如阶乘），也容易修改成尾递归版本。然而零钱兑换既有分叉，又不好用回溯，因此不容易用尾递归实现。</p>
<hr>
<p>虽然不容易通过尾递归这条路线摆脱递归，但可以通过从底层到高层构建状态集合来摆脱递归。</p>
<p>用了动态规划思想，但没用递归而是用循环。 令<code>num=states[sum]</code>表示sum金额的最小硬币数是num，作为一个状态。sum较小的状态定义为小状态，sum越大则状态越大。不用递归的话，只能先构建小的状态，在小状态基础上构建大状态，直到构建到题目要求的状态Sum为止。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coins</span><span class="params">(coinL,Sum)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> Sum &lt; min(coinL):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    states = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> coin <span class="keyword">in</span> coinL:</span><br><span class="line">        states[coin] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> range(<span class="number">1</span>,Sum+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">not</span> <span class="keyword">in</span> states.keys():</span><br><span class="line">            minNum = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">for</span> coin <span class="keyword">in</span> coinL:</span><br><span class="line">                <span class="keyword">if</span> s-coin <span class="keyword">in</span> states.keys():</span><br><span class="line">                    <span class="keyword">if</span> minNum <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                        minNum = states[s-coin]+<span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">if</span> minNum &gt; states[s-coin]+<span class="number">1</span>:</span><br><span class="line">                            minNum = states[s-coin]+<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> minNum <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                states[s] = minNum</span><br><span class="line">    <span class="keyword">if</span> Sum <span class="keyword">in</span> states.keys():</span><br><span class="line">        <span class="keyword">return</span> states[Sum]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0052-N皇后 II</title>
    <url>/2019/09/09/algs/leetcode/0052-N%E7%9A%87%E5%90%8E%20II/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>问题：</p>
<p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给定一个整数 n，返回 n 皇后不同的解决方案的数量。</p>
<hr>
<ul>
<li>按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法。</li>
<li>回溯是深度优先搜索的一种</li>
</ul>
<p>皇后问题的解的个数：</p>
<table>
<thead>
<tr class="header">
<th>问题规模</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>解的个数</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>2</td>
<td>10</td>
<td>4</td>
<td>40</td>
<td>92</td>
<td>352</td>
<td>724</td>
<td>2680</td>
<td>14200</td>
</tr>
</tbody>
</table>
<h2 id="循环递归">循环+递归</h2>
<h3 id="获得解的列表">获得解的列表</h3>
<ul>
<li><code>Queen(foundK, queenStore)</code>接受参数是一个数foundK（表示已经找到了<code>foundK</code>个皇后，现在要找索引为<code>foundK</code>的皇后，也就是第<code>foundK+1</code>个皇后），和一个列表<code>queenStore</code>（其长度与皇后问题规模<code>N</code>相同）。
<ul>
<li><code>queenStore</code>列表的前foundK个元素，表示已经找到的<code>foundK</code>个皇后在其所在行的位置。</li>
<li>返回值是皇后问题的解（N个皇后的摆放方案）的列表，如果没有则返回空列表。</li>
</ul></li>
<li>子函数<code>_check(idx, foundQs)</code>接受参数是一个数<code>idx</code>（假定第<code>foundK+1</code>个皇后在其所在行的位置）和一个列表<code>foundQs</code>（已经找到的<code>foundK</code>个皇后的列表），返回值表示第<code>foundK+1</code>个皇后放在i这个位置是否成立。</li>
<li>进入分支之前用<code>_check(idx, foundQs)</code>进行审核，审核通过的才会进入分支。
<ul>
<li>边界判断语句<code>if k &gt; N or k &lt; 0 or N == 0: return res</code>，只要调用最初调用<code>Queen(foundK, queenStore)</code>的参数没问题，这个判断语句就不会起作用。</li>
</ul></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Queen</span><span class="params">(foundK, queenStore)</span>:</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_check</span><span class="params">(idx, foundQs)</span>:</span></span><br><span class="line">        <span class="comment">#用于检查(foundK,idx)这个位置是否可以放置一个皇后</span></span><br><span class="line">        <span class="keyword">for</span> q_idx, q <span class="keyword">in</span> enumerate(foundQs):</span><br><span class="line">            <span class="keyword">if</span> idx == q <span class="keyword">or</span> abs(idx - q) == abs(len(foundQs) - q_idx):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">    N = len(queenStore) <span class="comment"># 皇后问题的规模</span></span><br><span class="line">    <span class="keyword">if</span> foundK &gt; N <span class="keyword">or</span> foundK &lt; <span class="number">0</span> <span class="keyword">or</span> N == <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 边界情况，返回空列表</span></span><br><span class="line">        <span class="keyword">return</span> []  </span><br><span class="line">    <span class="keyword">elif</span> foundK == N: <span class="comment"># 找到一个解</span></span><br><span class="line">        <span class="keyword">return</span> [queenStore[::]]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        res = [] <span class="comment"># 存储问题的解</span></span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> range(N):</span><br><span class="line">            <span class="keyword">if</span> _check(idx, queenStore[:foundK]):        </span><br><span class="line">                queenStore[foundK] = idx</span><br><span class="line">                res.extend(Queen(foundK+<span class="number">1</span>, queenStore))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>用Queen(foundK, queenStore)求解6皇后问题的用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">N = 6</span><br><span class="line">Queen(0, [0]*N)</span><br></pre></td></tr></table></figure>
<h3 id="获得解的个数">获得解的个数</h3>
<p>如果只要返回解的数量，而非具体的摆放皇后的方案，则可将上述代码改成如下版本：</p>
<ul>
<li>如果参数有误则返回0，如果找到一个解（最后一行，且能放置皇后）则返回1，其它情况（所在位置放置了皇后，且不在最后一行）则各分支的返回值求和并返回。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Queen</span><span class="params">(foundK, queenStore)</span>:</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_check</span><span class="params">(idx, foundQs)</span>:</span></span><br><span class="line">        <span class="comment">#用于检查(foundK,idx)这个位置是否可以放置一个皇后</span></span><br><span class="line">        <span class="keyword">for</span> q_idx, q <span class="keyword">in</span> enumerate(foundQs):</span><br><span class="line">            <span class="keyword">if</span> idx == q <span class="keyword">or</span> abs(idx - q) == abs(len(foundQs) - q_idx):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">    N = len(queenStore) <span class="comment"># 皇后问题的规模</span></span><br><span class="line">    <span class="keyword">if</span> foundK &gt; N <span class="keyword">or</span> foundK &lt; <span class="number">0</span> <span class="keyword">or</span> N == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">elif</span> foundK == N: <span class="comment"># 找到一个解</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> range(N):</span><br><span class="line">            <span class="keyword">if</span> _check(idx, queenStore[:foundK]):        </span><br><span class="line">                queenStore[foundK] = idx</span><br><span class="line">                count += Queen(foundK+<span class="number">1</span>, queenStore)</span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<h2 id="纯递归">纯递归</h2>
<h3 id="纯递归-1">纯递归</h3>
<ul>
<li>只用递归，不用循环。<code>纯递归</code>与<code>循环+递归</code>都是深度优先，区别在于前者搜索路径上任意一点在往下搜索时不记录该点的其它分支，搜索路径是一条线，而后者通过循环结构记录了其它分支，其搜索路径是一棵树。</li>
<li>相比<code>循环+递归</code>方案，<code>纯递归</code>方案的递归层数大大增加，而且一直累加，问题规模大于6时就发生栈溢出而导致该方案不可用。前者的栈的深度等于皇后问题的规模N，而后者的上限可能是<span class="math inline">\(N^N\)</span>。</li>
<li>Queen(foundK, idx, pathStore)返回值是方案个数，三个输入参数是搜索所需要的全部信息。这三个输入参数是
<ul>
<li>一个数foundK<span class="math inline">\(\in [0, 1, \cdots, N]\)</span>（表示已经找到了foundK个皇后，现在要找行索引为foundK的皇后，也就是第foundK+1个皇后），</li>
<li>idx是要检测的第foundK行的<span class="math inline">\(idx\in [0, 1, \cdots, N-1]\)</span>位置，</li>
<li>一个列表queenStore（其长度与皇后问题规模N相同）,</li>
</ul></li>
<li>Queen函数的递归调用形成一个不断增长的栈，每个栈上有个值用于标记该栈上产生的解的数量（0个或1个），直到搜索完毕。搜索完毕后不断出栈，同时将抛出栈的解的数量累加并将该值往调用处传递，如此则最初调用Queen函数处的返回值就是皇后问题的解的数量。</li>
<li>当某一层已经搜索到最后一个位置且审核未通过，或者搜索到最后一层的最后一个位置（通过与否无所谓），就要用<code>_goback(foundK, queenStore)</code>往之前的层回退，直到遇到第一个该层皇后的位置不是该行最后一个位置的层，继续搜索。如果这样的层不存在，则开启出栈过程。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Queen</span><span class="params">(foundK, idx, queenStore)</span>:</span>    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_check</span><span class="params">(idx, foundQs)</span>:</span></span><br><span class="line">        <span class="comment">#用于检查(foundK,idx)这个位置是否可以放置一个皇后</span></span><br><span class="line">        <span class="keyword">for</span> q_idx, q <span class="keyword">in</span> enumerate(foundQs):</span><br><span class="line">            <span class="keyword">if</span> idx == q <span class="keyword">or</span> abs(idx - q) == abs(len(foundQs) - q_idx):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_goback</span><span class="params">(foundK, queenStore)</span>:</span></span><br><span class="line">        N = len(queenStore)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(foundK - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> queenStore[i] != N - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line">    N = len(queenStore)</span><br><span class="line">    new = <span class="number">0</span> <span class="comment"># 标记是否产生了一个新的解   </span></span><br><span class="line">    <span class="keyword">if</span> _check(idx, queenStore[:foundK]):</span><br><span class="line">        <span class="comment"># 审核通过，按是否是最后一个皇后，分两种情况处理</span></span><br><span class="line">        queenStore[foundK] = idx </span><br><span class="line">        <span class="keyword">if</span> foundK != N <span class="number">-1</span>: </span><br><span class="line">            <span class="comment"># 如果找到的不是最后一层的皇后，则检查下一层的第一个位置</span></span><br><span class="line">            <span class="keyword">return</span> Queen(foundK+<span class="number">1</span>, <span class="number">0</span>, queenStore) </span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 找到一个解</span></span><br><span class="line">            new += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 接下来覆盖两种情况，一种是审核未通过，第二种是审核通过了且是最后一层的皇后</span></span><br><span class="line">    <span class="keyword">if</span> idx != N <span class="number">-1</span>: <span class="comment"># idx不是该行最后一个位置</span></span><br><span class="line">        ret = Queen(foundK, idx+<span class="number">1</span>, queenStore)</span><br><span class="line">        <span class="keyword">return</span> new + ret</span><br><span class="line">    <span class="keyword">else</span>: <span class="comment"># 此时idx = N -1 </span></span><br><span class="line">        foundK = _goback(foundK, queenStore)</span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> foundK <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            idx = queenStore[foundK]+<span class="number">1</span></span><br><span class="line">            ret = Queen(foundK, idx, queenStore)</span><br><span class="line">        <span class="keyword">return</span> new + ret</span><br></pre></td></tr></table></figure>
<p>用法，求五皇后问题的解的个数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N = <span class="number">5</span></span><br><span class="line">count = Queen(<span class="number">0</span>, <span class="number">0</span>, [<span class="number">0</span>]*N)</span><br><span class="line">print(count)</span><br></pre></td></tr></table></figure>
<h3 id="尾递归">尾递归</h3>
<p>如果既要用纯递归，又要摆脱栈溢出问题，只能采用尾递归。尾递归就是操作的最后一步是调用自身的递归。它和一般的递归不同在对内存的占用，普通递归创建stack累积而后计算收缩，尾递归只会占用恒量的内存（和迭代一样）。与普通递归相比，调用递归函数是用return语句，另外搜索状态完全由递归函数的参数决定，而不依赖函数参数之外的参数。</p>
<ul>
<li>Python语言不直接支持尾递归，因此写了个装饰器<code>@tail_call_optimized</code>修饰<code>Queen</code>函数，用以手工操作尾递归的栈数据。</li>
<li>与上边的纯递归版本相比，尾递归版本的所有的<code>Queen</code>函数递归调用都是直接将其本身执行<code>return</code>。只好定义一个引用变量(单元素列表)记录找到的解的数量，作为递归函数的全局变量。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tail_call_optimized</span><span class="params">(g)</span>:</span>   </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TailRecurseException</span><span class="params">(BaseException)</span>:</span>  </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, args, kwargs)</span>:</span>  </span><br><span class="line">            self.args = args  </span><br><span class="line">            self.kwargs = kwargs </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(*args, **kwargs)</span>:</span>  </span><br><span class="line">        <span class="keyword">import</span> sys </span><br><span class="line">        f = sys._getframe()  </span><br><span class="line">        <span class="keyword">if</span> f.f_back <span class="keyword">and</span> f.f_back.f_back <span class="keyword">and</span> f.f_back.f_back.f_code == f.f_code:  </span><br><span class="line">            <span class="keyword">raise</span> TailRecurseException(args, kwargs)    </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            <span class="keyword">while</span> <span class="number">1</span>:  </span><br><span class="line">                <span class="keyword">try</span>:  </span><br><span class="line">                    <span class="keyword">return</span> g(*args, **kwargs)  </span><br><span class="line">                <span class="keyword">except</span> TailRecurseException <span class="keyword">as</span> e:  </span><br><span class="line">                    args = e.args  </span><br><span class="line">                    kwargs = e.kwargs  </span><br><span class="line">    func.__doc__ = g.__doc__  </span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"><span class="meta">@tail_call_optimized</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Queen</span><span class="params">(foundK, idx, queenStore, count)</span>:</span>    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_check</span><span class="params">(idx, foundQs)</span>:</span></span><br><span class="line">        <span class="comment">#用于检查(foundK,idx)这个位置是否可以放置一个皇后</span></span><br><span class="line">        <span class="keyword">for</span> q_idx, q <span class="keyword">in</span> enumerate(foundQs):</span><br><span class="line">            <span class="keyword">if</span> idx == q <span class="keyword">or</span> abs(idx - q) == abs(len(foundQs) - q_idx):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_goback</span><span class="params">(foundK, queenStore)</span>:</span></span><br><span class="line">        N = len(queenStore)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(foundK - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> queenStore[i] != N - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line">    N = len(queenStore)</span><br><span class="line">    new = <span class="number">0</span> <span class="comment"># 标记是否产生了一个新的解   </span></span><br><span class="line">    <span class="keyword">if</span> _check(idx, queenStore[:foundK]):</span><br><span class="line">        <span class="comment"># 审核通过，按是否是最后一个皇后，分两种情况处理</span></span><br><span class="line">        queenStore[foundK] = idx </span><br><span class="line">        <span class="keyword">if</span> foundK != N <span class="number">-1</span>: </span><br><span class="line">            <span class="comment"># 如果找到的不是最后一层的皇后，则检查下一层的第一个位置</span></span><br><span class="line">            <span class="keyword">return</span> Queen(foundK+<span class="number">1</span>, <span class="number">0</span>, queenStore, count) </span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 找到一个解</span></span><br><span class="line">            new += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 接下来覆盖两种情况，一种是审核未通过，第二种是审核通过了且是最后一层的皇后</span></span><br><span class="line">    count[<span class="number">0</span>] += new</span><br><span class="line">    <span class="keyword">if</span> idx != N <span class="number">-1</span>: <span class="comment"># idx不是该行最后一个位置</span></span><br><span class="line">        <span class="keyword">return</span> Queen(foundK, idx+<span class="number">1</span>, queenStore, count)</span><br><span class="line">    <span class="keyword">else</span>: <span class="comment"># 此时idx = N -1 </span></span><br><span class="line">        foundK = _goback(foundK, queenStore)</span><br><span class="line">        <span class="keyword">if</span> foundK <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            idx = queenStore[foundK]+<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> Queen(foundK, idx, queenStore, count)</span><br></pre></td></tr></table></figure>
<p>用法，求八皇后问题的解的个数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N = <span class="number">8</span></span><br><span class="line">count = [<span class="number">0</span>]</span><br><span class="line">Queen(<span class="number">0</span>, <span class="number">0</span>, [<span class="number">0</span>]*N, count)</span><br><span class="line">print(count[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<h2 id="纯循环">纯循环</h2>
<p>尾递归仍然进行大量栈操作，效率不佳。好在尾递归可以很容易改造成纯循环，大大降低栈的开销。</p>
<ul>
<li>尾递归改成纯循环的方法：主要在每个循环体开始时把递归函数需要的几个参数准备好即可，也就是在尾递归的递归调用处，更新参数并用continue进入下一个循环体。循环体共用一个全局变量来统计解的个数。</li>
<li><code>_goback(foundK, queenStore)</code>无返回值时，打破循环，返回解的数量。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Queen</span><span class="params">(foundK, idx, queenStore)</span>:</span>    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_check</span><span class="params">(idx, foundQs)</span>:</span></span><br><span class="line">        <span class="comment">#用于检查(foundK,idx)这个位置是否可以放置一个皇后</span></span><br><span class="line">        <span class="keyword">for</span> q_idx, q <span class="keyword">in</span> enumerate(foundQs):</span><br><span class="line">            <span class="keyword">if</span> idx == q <span class="keyword">or</span> abs(idx - q) == abs(len(foundQs) - q_idx):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_goback</span><span class="params">(foundK, queenStore)</span>:</span></span><br><span class="line">        N = len(queenStore)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(foundK - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> queenStore[i] != N - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line">    N = len(queenStore)</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> _check(idx, queenStore[:foundK]):</span><br><span class="line">            <span class="comment"># 审核通过，按是否是最后一个皇后，分两种情况处理</span></span><br><span class="line">            queenStore[foundK] = idx </span><br><span class="line">            <span class="keyword">if</span> foundK != N <span class="number">-1</span>: </span><br><span class="line">                <span class="comment"># 如果找到的不是最后一层的皇后，则检查下一层的第一个位置</span></span><br><span class="line">                foundK, idx = foundK+<span class="number">1</span>, <span class="number">0</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 找到一个解</span></span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 接下来覆盖两种情况，一种是审核未通过，第二种是审核通过了且是最后一层的皇后</span></span><br><span class="line">        <span class="keyword">if</span> idx != N <span class="number">-1</span>: <span class="comment"># idx不是该行最后一个位置</span></span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 此时idx = N -1 </span></span><br><span class="line">            foundK = _goback(foundK, queenStore)</span><br><span class="line">            <span class="keyword">if</span> foundK <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                idx = queenStore[foundK]+<span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>回溯</tag>
        <tag>尾递归</tag>
      </tags>
  </entry>
  <entry>
    <title>更新中...</title>
    <url>/2019/01/01/tools/2019-01-01%E6%9B%B4%E6%96%B0%E4%B8%AD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote class="blockquote-center"><p>不愤不启,不悱不发</p>
</blockquote>
]]></content>
      <categories>
        <category>工具箱</category>
      </categories>
  </entry>
  <entry>
    <title>中秋来兮独赏月</title>
    <url>/2018/09/28/literature/2015-09-28-%E4%B8%AD%E7%A7%8B%E6%9D%A5%E5%85%AE%E7%8B%AC%E8%B5%8F%E6%9C%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote class="blockquote-center"><p>秋雨为弦风来弹，</p>
<p>缘何频频望东南。</p>
<p>何当携手伴圆月，</p>
<p>再叙今日思君难。</p>
</blockquote>
]]></content>
      <categories>
        <category>小雕虫</category>
      </categories>
      <tags>
        <tag>打油诗</tag>
      </tags>
  </entry>
  <entry>
    <title>还能咋整？</title>
    <url>/2018/07/31/literature/2016-07-31-%E8%BF%98%E8%83%BD%E5%92%8B%E6%95%B4%EF%BC%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote class="blockquote-center"><p>上联：有头无尾，一叶孤舟终破浪；</p>
<p>下联：白云黑土，比翼劳燕本作空。</p>
<p>横批：还能咋整？</p>
</blockquote>
]]></content>
      <categories>
        <category>小雕虫</category>
      </categories>
      <tags>
        <tag>打油诗</tag>
      </tags>
  </entry>
  <entry>
    <title>鸿鹄</title>
    <url>/2018/07/27/literature/2018-07-27-%E9%B8%BF%E9%B9%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote class="blockquote-center"><p>浑浑噩噩一天天，</p>
<p>遮遮掩掩又一年。</p>
<p>当初也言鸿鹄志，</p>
<p>今日忆起透心寒。</p>
</blockquote>
]]></content>
      <categories>
        <category>小雕虫</category>
      </categories>
      <tags>
        <tag>打油诗</tag>
      </tags>
  </entry>
  <entry>
    <title>游子吟</title>
    <url>/2018/07/24/literature/2018-07-24-%E6%B8%B8%E5%AD%90%E5%90%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote class="blockquote-center"><p>日沉添心闷，驾车临草甸。</p>
<p>火云如画美，可是天要黑。</p>
<p>天要黑，天要黑，</p>
<p>脚下野花趋心拢，原上乌雀向林飞。</p>
<p>士子万里何所栖？寒水黑树语孤灯。</p>
<p>雨扣纱窗又惊梦，起读卫霍少年功，</p>
<p>怎奈鬓斑脑肥腹中空。</p>
<p>汉高知命斩蛇始，逐鹿十年葬群雄。</p>
<p>试看敢效弑君者，铁马长缨会暴龙。</p>
</blockquote>
]]></content>
      <categories>
        <category>小雕虫</category>
      </categories>
      <tags>
        <tag>打油诗</tag>
      </tags>
  </entry>
</search>
