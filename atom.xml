<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>狼哥空间</title>
  
  <subtitle>虚怀若谷，求知若渴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wolfbrother.github.io/"/>
  <updated>2020-03-30T02:36:40.262Z</updated>
  <id>https://wolfbrother.github.io/</id>
  
  <author>
    <name>wolfbrother</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>老家做饭</title>
    <link href="https://wolfbrother.github.io/2020/03/30/life/2020-03-30-%E8%80%81%E5%AE%B6%E5%81%9A%E9%A5%AD/"/>
    <id>https://wolfbrother.github.io/2020/03/30/life/2020-03-30-老家做饭/</id>
    <published>2020-03-29T16:00:00.000Z</published>
    <updated>2020-03-30T02:36:40.262Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="蒸面条">蒸面条</h2><p>现货面，用压面条的机器压出来的面条，比手擀面劲道。配菜有炒豆腐片，炒蒜苗和莴笋苗。 <img src="/images/20200330-蒸面条.jpg" alt="蒸面条"></p><h2 id="西红柿鸡蛋面">西红柿鸡蛋面</h2><figure><img src="/images/20200330-煮面条.jpg" alt="煮面条"><figcaption>煮面条</figcaption></figure><h2 id="蒸青菜">蒸青菜</h2><p>青菜有芫荽、莴笋苗、菠菜，蒜臼做蒜泥用来拌菜。 <img src="/images/20200330-蒸青菜.jpg" alt="蒸青菜"></p><h2 id="鸡蛋羹">鸡蛋羹</h2><p>用的凉开水搅鸡蛋，真的一点气泡都没有。 <img src="/images/20200330-鸡蛋羹.jpg" alt="鸡蛋羹"></p><h2 id="凉拌粉丝">凉拌粉丝</h2><p>蒜苗和葱做的青菜太多了。 <img src="/images/20200330-凉拌粉丝.jpg" alt="凉拌粉丝"></p><h2 id="炒红薯豆腐片和煮米汤">炒红薯豆腐片和煮米汤</h2><figure><img src="/images/20200330-炒红薯和米汤.jpg" alt="炒红薯和米汤"><figcaption>炒红薯和米汤</figcaption></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="生活" scheme="https://wolfbrother.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="锅碗瓢盆" scheme="https://wolfbrother.github.io/tags/%E9%94%85%E7%A2%97%E7%93%A2%E7%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>春日草木记</title>
    <link href="https://wolfbrother.github.io/2020/03/20/life/2020-03-20-%E6%98%A5%E6%97%A5%E8%8D%89%E6%9C%A8%E8%AE%B0/"/>
    <id>https://wolfbrother.github.io/2020/03/20/life/2020-03-20-春日草木记/</id>
    <published>2020-03-19T16:00:00.000Z</published>
    <updated>2020-04-02T07:01:45.943Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今年天气特别暖和，三月下旬的之前几天，老家已经连续数天最高气温27摄氏度，已经有人开始对农田进行浇水。</p><h2 id="新栽花草">新栽花草</h2><p>网购了多种花草，有紫竹根、常青藤苗、爬山虎、藤本蔷薇、玫瑰、凌霄花、覆盆子和佛肚竹。这些花草里面好几种都是耐阴耐旱的植物，主要栽种到了院子的四个角落，屋子两侧与院墙的夹缝，葡萄架与院墙的中间，厕所门口等。院墙外面的路边，也种了凌霄花。 <img src="/images/20200320-新栽花草之处.jpg" alt="新栽花草之处"></p><p>网购了两株金桂树，三年龄，当年开花，栽种到大门外两侧。金桂四季常绿，在北方的冬天显得很重要。桂树旁边是多年生的花草，有百合科的大萱草和铁皮石斛，很耐旱。 <img src="/images/20200324-两棵金桂树.jpg" alt="两棵金桂树"></p><p>又买了10株小人参，比小拇指小一些，在房子西侧与院墙的夹缝里种了几株，剩下的全都我家院子的外面，希望一二十年之后我能收获几个大人参，哈哈。 <img src="/images/20200328-人参.jpg" alt="人参"></p><p>还买了几片仙人掌，带根的那种，找了个废弃的铝盆和塑胶花的陶瓷花瓶种下，然后放到了小平房的房顶，那里一般不会有人去，适合仙人掌在那里。希望数年后仙人掌枝繁叶茂花枝招展，伸出院外，既能迎客又能防贼。 <img src="/images/20200328-仙人掌.jpg" alt="仙人掌"></p><p>院墙和院外的路的中间，也有栽种常青藤、藤本月季、黄杨和冬青。</p><h2 id="果树护理">果树护理</h2><p>下图是3月20日的果林，最近处是樱桃，其次是桃树和杏树。 <img src="/images/20200320-3月20日的果林.jpg" alt="3月20日的果林"></p><p>一月下旬买了牛奶大青枣果树树苗，两株，栽在了院子里，至今未见发芽。还买了两株樱桃，嫁接好的，也栽在了院子南侧，未发芽。另有20株奶油草莓苗，栽在了院子东侧靠墙位置，本月初就开始开花结果了。 <img src="/images/20200320-草莓.jpg" alt="草莓"></p><p>院子里之前已经有数棵果树，分别是三棵桃树，一棵杏树，一株樱桃树，一株苹果树，和多株葡萄。樱桃树3月8日开始首先开花，有蜜蜂传粉。 <img src="/images/20200320-樱桃花.jpg" alt="樱桃花"></p><p>其次是杏树开花， <img src="/images/20200320-杏花.jpg" alt="杏花"> 再然后是桃花，现在桃花正开。 <img src="/images/20200320-桃花盛开.jpg" alt="桃花盛开"> 苹果树开始发芽。 <img src="/images/20200320-苹果树.jpg" alt="苹果树"> 葡萄树至今未发芽。 <img src="/images/20200320-葡萄架.jpg" alt="葡萄架"></p><p>杏树、桃树和苹果树上面蚜虫很多，从含苞待放时花苞上就有很多蚜虫，然后现在幼芽上也满是。去镇上买了一瓶噻虫高氯氟，专治蚜虫的，用喷雾器连续喷了两天，效果不错。</p><h2 id="狗狗">狗狗</h2><p>一只纯种金毛，另一只个头和柴犬差不多的田园犬。 <img src="/images/20200320-冬天的狗狗.jpg" alt="冬天的狗狗"></p><p>春天宠物身上容易生跳蚤，冬天就在金毛身上发现了跳蚤。在一月初买了跳蚤药，并给两只狗狗使用，效果不错。还给狗买了内服的打虫药，钙片和微量元素片，保障它们的身体健康。 <img src="/images/20200328-狗狗的药.jpg" alt="狗狗的药"></p><p>金毛总是时不时地咬草莓植株和玫瑰的芽，春天发芽不易，保护起来。下面的图是栽种在院子靠近门口的玫瑰，树枝和笼子是用来保护下面的玫瑰芽的： <img src="/images/20200328-玫瑰.jpg" alt="玫瑰"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="生活" scheme="https://wolfbrother.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="花鸟虫鱼" scheme="https://wolfbrother.github.io/tags/%E8%8A%B1%E9%B8%9F%E8%99%AB%E9%B1%BC/"/>
    
  </entry>
  
  <entry>
    <title>跳绳减脂走起来！</title>
    <link href="https://wolfbrother.github.io/2020/01/08/life/2020-01-08-%E8%B7%B3%E7%BB%B3%E5%87%8F%E8%84%82%E8%B5%B0%E8%B5%B7%E6%9D%A5/"/>
    <id>https://wolfbrother.github.io/2020/01/08/life/2020-01-08-跳绳减脂走起来/</id>
    <published>2020-01-07T16:00:00.000Z</published>
    <updated>2020-03-20T06:11:23.399Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>工作后更要养成健身的习惯。</p><h3 id="一口气连续跳绳40分钟">一口气连续跳绳40分钟</h3><p>消耗的热量相当于减脂100g，连续这样跳5天则至少减掉1斤体重。</p><figure><img src="/images/20200108-一次连跳40分钟.jpg" alt="一次连跳40分钟"><figcaption>一次连跳40分钟</figcaption></figure><h3 id="连续跳20分钟无失误">连续跳20分钟无失误</h3><p>太难得了有没有？因为心理波动和肌体疲劳很容易导致跳绳失误。</p><figure><img src="/images/20200108-20分钟无失误.jpg" alt="20分钟无失误"><figcaption>20分钟无失误</figcaption></figure><h3 id="年11月份的跳绳总结">2019年11月份的跳绳总结</h3><p>各项参数的统计结果：</p><ul><li>累计用时1431分钟；</li><li>总数量20万4千多个；</li><li>消耗23421千卡，相当于6斤脂肪的热量。</li></ul><figure><img src="/images/20200108-11月跳绳总结.jpg" alt="11月跳绳总结"><figcaption>11月跳绳总结</figcaption></figure><h3 id="体重记录">体重记录</h3><p>不久前，持续两个月的锻炼和节食来减肥，如今恰好130斤体重。此后，一边增肌，一边减脂，保持体重130斤永不变。</p><figure><img src="/images/20200108-恰好130斤的体重.jpg" alt="恰好130斤的体重"><figcaption>恰好130斤的体重</figcaption></figure><h3 id="我养的缸子肉">我养的缸子肉</h3><p>最后贴上我养的多肉，其实是养在了一个小碟子里，然后把小碟子放在了一个小茶缸上面。 就叫它<em>缸子肉</em>吧。</p><figure><img src="/images/20200108-缸子肉.jpg" alt="缸子肉"><figcaption>缸子肉</figcaption></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="生活" scheme="https://wolfbrother.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="运动健身" scheme="https://wolfbrother.github.io/tags/%E8%BF%90%E5%8A%A8%E5%81%A5%E8%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>我和她的重要节日之表白</title>
    <link href="https://wolfbrother.github.io/2020/01/04/life/2020-01-04-%E6%88%91%E5%92%8C%E5%A5%B9%E7%9A%84%E9%87%8D%E8%A6%81%E8%8A%82%E6%97%A5/"/>
    <id>https://wolfbrother.github.io/2020/01/04/life/2020-01-04-我和她的重要节日/</id>
    <published>2020-01-03T16:00:00.000Z</published>
    <updated>2020-03-20T06:11:23.396Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote class="blockquote-center"><p><font face="fantasy" color="FF00FF" size="15">阳历1月4日</font></p><figure><img src="/images/20200104-牵着她的手.jpg" alt="牵着她的手"><figcaption>牵着她的手</figcaption></figure><figure><img src="/images/20200104-蜡烛们.jpg" alt="蜡烛和花瓣们"><figcaption>蜡烛和花瓣们</figcaption></figure><figure><img src="/images/20200104-烛光合照.jpg" alt="烛光合照"><figcaption>烛光合照</figcaption></figure><figure><img src="/images/20200104-金针菇合照.jpg" alt="金针菇合照"><figcaption>金针菇合照</figcaption></figure></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="生活" scheme="https://wolfbrother.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>快排中的Partition函数</title>
    <link href="https://wolfbrother.github.io/2019/09/30/algs/general/2019-09-30-%E5%BF%AB%E6%8E%92%E4%B8%AD%E7%9A%84Partition%E5%87%BD%E6%95%B0/"/>
    <id>https://wolfbrother.github.io/2019/09/30/algs/general/2019-09-30-快排中的Partition函数/</id>
    <published>2019-09-29T16:00:00.000Z</published>
    <updated>2020-03-20T06:11:23.380Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="快排算法与partition函数">快排算法与partition函数</h3><h4 id="快排算法的递归形式">快排算法的递归形式：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(nums, l, r)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> l &gt;= r:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    k = partition(nums, l, r)</span><br><span class="line">    quicksort(nums, l, k - <span class="number">1</span>)</span><br><span class="line">    quicksort(nums, k + <span class="number">1</span>, r)</span><br></pre></td></tr></table></figure><h4 id="快排算法的非递归形式">快排算法的非递归形式</h4><ul><li>使用了栈</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(nums, l, r)</span>:</span></span><br><span class="line">    stack = [(l, r)]</span><br><span class="line">    <span class="keyword">while</span> len(stack) &gt; <span class="number">0</span>:</span><br><span class="line">        l, r = stack.pop(<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">if</span> l &gt;= r:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        ix = partition3(nums, l, r)</span><br><span class="line">        stack.append((ix+<span class="number">1</span>, r))</span><br><span class="line">        stack.append((l, ix<span class="number">-1</span>))</span><br></pre></td></tr></table></figure><h4 id="partition函数">partition函数</h4><p>其中partition函数输入参数是一个数组nums和两个位置索引<code>l</code>和<code>r</code>，输出为位置索引k。需要满足：</p><ul><li><span class="math inline">\(l\le k \le r\)</span></li><li><span class="math inline">\(nums[l..k-1]\le nums[k]\)</span> 且<span class="math inline">\(nums[k+1..r]\ge nums[k]\)</span></li></ul><p>而一般的partition函数的实现不仅能够满足上述两个条件，还会更严格，如把第二个条件中的其中一个等号去掉：</p><ul><li><span class="math inline">\(nums[l..k-1] &lt; nums[k]\)</span> 且<span class="math inline">\(nums[k+1..r]\ge nums[k]\)</span></li></ul><p>不但能够用来排序，还能做其它事情。</p><h3 id="partition函数实现">Partition函数实现：</h3><p>如下版本返回值k，均满足<span class="math inline">\(nums[l..k-1] &lt; nums[k]\)</span> 且<span class="math inline">\(nums[k+1..r]\ge nums[k]\)</span></p><h4 id="单向扫描">单向扫描</h4><ul><li><code>for</code>循环遍历基准元素左侧所有元素，里指针s所指元素及其左侧元素都是小于最右侧基准元素<code>nums[r]</code>。</li><li>出了<code>for</code>循环，s再前进一位，所指元素与基准元素对调，以确保最终的列表里其右侧元素均大于等于其所指元素。</li><li><code>for</code>循环里以指针<code>i</code>为核心，其向右遍历，如果小于基准元素，则替换以大于等于基准元素。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(nums, l, r)</span>:</span></span><br><span class="line">    s = l - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(l, r):</span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt; nums[r]:</span><br><span class="line">            s += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> s != i:</span><br><span class="line">                nums[s], nums[i] = nums[i], nums[s]</span><br><span class="line">    s += <span class="number">1</span></span><br><span class="line">    nums[s], nums[r] = nums[r], nums[s]</span><br><span class="line">    <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><h4 id="双向扫描">双向扫描</h4><ul><li>双重while循环出来，后有<code>i==j</code>且<code>nums[l..i-1]&lt;x</code>，<code>nums[i+1..r]&gt;=x</code>。<ul><li>然后根据<code>nums[i]</code>与x的大小关系，分三种情况处理，并决定返回值： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> nums[i] &gt; x: </span><br><span class="line">    nums[i], nums[r] = x, nums[i]</span><br><span class="line"><span class="keyword">elif</span> nums[i] &lt; x: </span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> nums[i] &gt; x:</span><br><span class="line">        nums[i], nums[r] = x, nums[i]</span><br></pre></td></tr></table></figure></li></ul></li><li>返回值i必然大于等于l，小于等于r，quicksort根据其划分的子问题规模必然小于原问题。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition3</span><span class="params">(nums, l, r)</span>:</span></span><br><span class="line">    x = nums[r]</span><br><span class="line">    i, j = l, r<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; j: </span><br><span class="line">        <span class="keyword">while</span> nums[i] &lt; x <span class="keyword">and</span> i &lt; j: <span class="comment"># 循环终止时i满足nums[i]&gt;=x或者i==j</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> nums[j] &gt;= x <span class="keyword">and</span> i &lt; j: <span class="comment"># 循环终止时j满足nums[j]&lt;x或者i==j</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> j &gt; i: <span class="comment"># 说明必有nums[i]&gt;=x且nums[j]&lt;x，需要调换二者位置</span></span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> nums[i] &lt; x: </span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    nums[i], nums[r] = x, nums[i] </span><br><span class="line">    <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure><h3 id="partition函数的应用">partition函数的应用</h3><h4 id="leetcode215.-数组中的第k个最大元素">LeetCode215. 数组中的第K个最大元素</h4><ul><li>第K大，就是第L-K+1个最小元素。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span> <span class="keyword">or</span> k &lt;= <span class="number">0</span> <span class="keyword">or</span> k &gt; len(nums):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        i, j = <span class="number">0</span>, len(nums)<span class="number">-1</span></span><br><span class="line">        k = len(nums) - k</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            ix = partition(nums, i, j)</span><br><span class="line">            <span class="keyword">if</span> ix == k:</span><br><span class="line">                <span class="keyword">return</span> nums[ix]</span><br><span class="line">            <span class="keyword">elif</span> ix &lt; k:</span><br><span class="line">                i = ix + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j = ix - <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="剑指29-最小的k个数">剑指29-最小的K个数</h4><p>用快排的partition方法来找到第k大的数，那么该数以及其左侧k-1个数一起，就是最小的k个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetLeastNumbers_Solution</span><span class="params">(self, tinput, k)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> tinput <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> len(tinput) &lt; k <span class="keyword">or</span> k &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        s, t = <span class="number">0</span>, len(tinput)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            ix = partition(tinput, s, t)</span><br><span class="line">            <span class="keyword">if</span> ix == k <span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">return</span> sorted(tinput[:k])</span><br><span class="line">            <span class="keyword">elif</span> ix &gt; k <span class="number">-1</span>:</span><br><span class="line">                t = ix <span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s = ix + <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="剑指28-数组中出现次数超过一半的数字">剑指28-数组中出现次数超过一半的数字</h4><ul><li>快排的partition函数能够以某个数为基准，将数组内元素按大小分为小于该数和大于等于该数两部分。可以用来将数组分成前k个较小值和其余的值两部分，方法是迭代，将partition函数的输入区间向k和拢。</li><li>而出现次数超过一半的数，排序之后肯定会在下标<code>len(numbers)&gt;&gt;1</code>上出现，因此用partition函数找到该数，然后检查其是否满足条件即可。</li><li>每次迭代使得partition的输出更接近<code>len(numbers)&gt;&gt;1</code>这个下标，直到二者相等。如果有出现次数超过一半的数，则必然是该下标的元素。究竟是不是，也要检查一番才能确定。</li><li>注意：虽然partition的输出下标左侧的元素肯定要小于该下标所指的元素，但最终<code>len(numbers)&gt;&gt;1</code>这个下标左侧的元素却是小于等于该下标所指元素。只是由<code>while True</code>循环里对<code>s</code>和<code>t</code>的更新方式导致的。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(self, numbers)</span>:</span>  </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">checkMoreThanHalf</span><span class="params">(num, numbers)</span>:</span></span><br><span class="line">            half = (len(numbers)&gt;&gt;<span class="number">1</span>)+<span class="number">1</span> <span class="comment"># 一半加一</span></span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">                <span class="keyword">if</span> n == num:</span><br><span class="line">                    half -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> half &lt;= <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(numbers) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        s, t = <span class="number">0</span>, len(numbers)<span class="number">-1</span></span><br><span class="line">        mid = len(numbers)&gt;&gt;<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            ix = partition(numbers, s, t) </span><br><span class="line">            <span class="keyword">if</span> ix &gt; mid:</span><br><span class="line">                t = ix - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> ix &lt; mid: </span><br><span class="line">                s = ix + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        num = numbers[mid]</span><br><span class="line">        <span class="keyword">return</span> num <span class="keyword">if</span> checkMoreThanHalf(num, numbers) <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="刷题" scheme="https://wolfbrother.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="partition" scheme="https://wolfbrother.github.io/tags/partition/"/>
    
  </entry>
  
  <entry>
    <title>n位二进制中m个1的所有组合个数</title>
    <link href="https://wolfbrother.github.io/2019/09/28/algs/general/2019-09-28-n%E4%BD%8D%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%ADm%E4%B8%AA1%E7%9A%84%E6%89%80%E6%9C%89%E7%BB%84%E5%90%88%E4%B8%AA%E6%95%B0/"/>
    <id>https://wolfbrother.github.io/2019/09/28/algs/general/2019-09-28-n位二进制中m个1的所有组合个数/</id>
    <published>2019-09-27T16:00:00.000Z</published>
    <updated>2020-03-20T06:11:23.377Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>用递归和动态规划：</p><p>将n个元素从左往右排好序。每次选择的m个元素的组合按如下步骤，</p><ul><li>先选第一个元素，有n-m+1种选择方案</li><li>第一个元素的位置确定后，其余待选择的m-1个元素从已选择元素的右边选择。这是个与原问题同构的子问题，可以用递归。</li><li>递归的终止条件有两个，一个是n==m也就是剩余元素数量和剩余位置数量相等，只有一种组合方法；一个是m==0也就是m个元素都已经排完了。</li><li>用一个全局的数据结构存储动态规划的子问题状态，避免重复计算。</li></ul><p>而根据第一个元素的位置生成的n-m+1个子问题是互斥且完备的，因此方法成立。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combination</span><span class="params">(n, m)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(n, m, states)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == m <span class="keyword">or</span> m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n-m+<span class="number">2</span>):</span><br><span class="line">                <span class="keyword">if</span> (n-i, m<span class="number">-1</span>) <span class="keyword">not</span> <span class="keyword">in</span>  states:</span><br><span class="line">                    num = recur(n-i, m<span class="number">-1</span>, states)</span><br><span class="line">                    states[(n-i, m<span class="number">-1</span>)] = num</span><br><span class="line">                    res += num</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res += states[(n-i, m<span class="number">-1</span>)]</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">    states = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span> <span class="keyword">and</span> n == <span class="number">0</span>) <span class="keyword">or</span> m &gt; n <span class="keyword">or</span> m &lt; <span class="number">0</span> <span class="keyword">or</span> n &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> recur(n,m, states)</span><br></pre></td></tr></table></figure><p>带入参数计算combination(1000, 500)得到一个很大的组合数数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2702882409454365695156146936259752754961520084465482870073928751066254287055</span><br><span class="line">2219389861248392450237016536260608502154610480220975005067991754989421969951</span><br><span class="line">8475423665484263751733356162464079737887344364574161119497604571044985756287</span><br><span class="line">880514600994219426752366915856603136862602484428109296905863799821216320</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="刷题" scheme="https://wolfbrother.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="https://wolfbrother.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="递归" scheme="https://wolfbrother.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>魔改hexo框架</title>
    <link href="https://wolfbrother.github.io/2019/09/18/tools/2019-09-18-%E9%AD%94%E6%94%B9hexo%E6%A1%86%E6%9E%B6/"/>
    <id>https://wolfbrother.github.io/2019/09/18/tools/2019-09-18-魔改hexo框架/</id>
    <published>2019-09-17T16:00:00.000Z</published>
    <updated>2020-03-20T07:04:18.226Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="安装配置">安装配置</h3><p>下载本仓库，安装第三方包和环境，并在本机测试： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone -b hexo git@github.com:wolfbrother/wolfbrother.github.io.git</span><br><span class="line">npm install hexo --save</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">compile-push-deploy.bat</span><br><span class="line">compile-test.bat</span><br></pre></td></tr></table></figure></p><p>测试成功后部署到github pages： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile-push-deploy.bat</span><br></pre></td></tr></table></figure></p><p>清除历史commit记录并同步到远端仓库： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clean-history-hexo.bat</span><br></pre></td></tr></table></figure></p><p>从远端仓库同步到本地： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fetch-merge.bat</span><br></pre></td></tr></table></figure></p><p>提交本地仓库到远端： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add-commit-push.bat</span><br></pre></td></tr></table></figure></p><h3 id="列表顺序">列表顺序</h3><p>hexo平台有四中文章列表顺序的规则，分别对应about页面(也是最基本的排序方案)、category页面、archive页面和tag页面，分别由如下四处代码控制：</p><ul><li>文件<code>node_modules\hexo\lib\plugins\generator\post.js</code><ul><li>相关代码<code>const posts = locals.posts.sort('-date').toArray()</code></li></ul></li><li>文件<code>node_modules\hexo-generator-category\lib\generator.js</code><ul><li>相关代码<code>var posts = category.posts.sort(config.category_generator.order_by || '-date');</code></li></ul></li><li>文件<code>node_modules\hexo-generator-archive\lib\generator.js</code><ul><li>相关代码<code>var allPosts = locals.posts.sort(config.archive_generator.order_by || '-date');</code></li></ul></li><li>文件<code>node_modules\hexo-generator-tag\lib\generator.js</code><ul><li>相关代码<code>var posts = tag.posts.sort(config.tag_generator.order_by || '-date');</code></li></ul></li></ul><p>其中<code>post.js</code>文件的<code>-date</code>给替换成其它变量，不然会出错。而上面其它三个都是替换后的写法。其中的变量定义在根目录下的文件<code>_config.yml</code>，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">index_generator:</span><br><span class="line">  path: &apos;&apos;</span><br><span class="line">  per_page: 10</span><br><span class="line">  order_by: -dtindex</span><br><span class="line">archive_generator:</span><br><span class="line">  per_page: 10</span><br><span class="line">  order_by: -dtindex </span><br><span class="line">category_generator:</span><br><span class="line">  per_page: 10</span><br><span class="line">  order_by: -dtindex </span><br><span class="line">tag_generator:</span><br><span class="line">  order_by: -dtindex</span><br></pre></td></tr></table></figure><p>上面的<code>-date</code>就是每篇文章的头部的<code>date</code>，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dtindex: 2018-07-27鸿鹄0000</span><br><span class="line">title: 鸿鹄</span><br><span class="line">categories: 风骚</span><br><span class="line">tags: Essay</span><br><span class="line">author: wolfbrother</span><br><span class="line">date: 2018-07-27</span><br></pre></td></tr></table></figure><p>其中的dtindex是我自己添加的，把date和title连接起来截取前面部分。相对于用date排序，dtindex可以在给date相同的多篇文章排序时考虑title部分。添加的Python脚本如下，放到文章所在目录，运行即可。可以重复运行。：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line">xmls = glob.glob(<span class="string">'*.md'</span>)</span><br><span class="line"><span class="keyword">for</span> one_xml <span class="keyword">in</span> xmls:</span><br><span class="line">    f = open(one_xml, <span class="string">'r+'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">    all_the_lines = f.readlines()</span><br><span class="line">    <span class="comment">#print(all_the_lines)</span></span><br><span class="line">    i, j = <span class="number">-1</span>, <span class="number">-1</span></span><br><span class="line">    date, title = <span class="string">''</span>, <span class="string">''</span></span><br><span class="line">    ret_len = <span class="number">6</span></span><br><span class="line">    is_done = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> row, line <span class="keyword">in</span> enumerate(all_the_lines):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'dtindex'</span> <span class="keyword">in</span> line:</span><br><span class="line">            is_done = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        lstrip = line.strip()</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'---'</span> <span class="keyword">in</span> lstrip:</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span>:</span><br><span class="line">                i = row </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j = row</span><br><span class="line">        <span class="keyword">if</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">'date'</span> <span class="keyword">in</span> lstrip:</span><br><span class="line">                date = lstrip.split(<span class="string">':'</span>)[<span class="number">1</span>].strip()</span><br><span class="line">            <span class="keyword">if</span> <span class="string">'title'</span> <span class="keyword">in</span> lstrip:</span><br><span class="line">                title = lstrip.split(<span class="string">':'</span>)[<span class="number">1</span>].strip()</span><br><span class="line">                <span class="keyword">if</span> len(title) &gt; ret_len:</span><br><span class="line">                    title = title[:ret_len]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    title += <span class="string">'0'</span>*ret_len</span><br><span class="line">                    title = title[:ret_len]</span><br><span class="line">        <span class="keyword">if</span> j &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    f.close()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> is_done:</span><br><span class="line">        all_the_lines.insert(i+<span class="number">1</span>, <span class="string">'dtindex: '</span>+ date+title+<span class="string">'\n'</span>)</span><br><span class="line">        print(i,j, date+title)</span><br><span class="line">        f = open(one_xml, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">        f.write(<span class="string">''</span>.join(all_the_lines))</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure><h3 id="tex语法冲突">TeX语法冲突</h3><p>由于markdown和TeX语法的冲突，hexo在渲染TeX公式方面有不足。config文件里有选项是否开启mathjax，但是渲染效果并不是那么好。比如说会出现公式内的下划线无法识别，而识别为markdown的斜体。</p><p>更换Hexo的markdown引擎。,就是把hexo默认的渲染markdown的引擎换掉。 hexo-renderer-pandoc, 很强大的解析器，先卸载hexo默认的markd,再安装新的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-pandoc --save</span><br></pre></td></tr></table></figure><p>这些第三方安装包的下载安装的位置是根目录的node_modules文件夹下。而配置记录可以在根目录的package.json找到，这样根据package.json可以重新构建编译环境。</p><h3 id="隐藏首页的某些文章">隐藏首页的某些文章</h3><p>安装包hexo-generator-index2自带过滤功能，可以根据tag或category来过滤掉首页的某些文章。比如过滤掉tag为hexo的文章，则在<code>_config.yml</code>中配置如下： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">index2_include_index: true</span><br><span class="line">index2_generator:</span><br><span class="line">  per_page: 8</span><br><span class="line">  order_by: -dtindex # 按发布时间排序</span><br><span class="line">  exclude:</span><br><span class="line">    - tag  hexo # 不包含标签为hide的文章</span><br><span class="line">    - category hexo # 不包含分类为hide的文章</span><br></pre></td></tr></table></figure></p><p>需要注意的是，将order_by属性设置为-dtindex，也达到了首页文章按时间和标题排序的目的。</p><h3 id="文章结尾处的标签仓库链接">文章结尾处的标签、仓库链接</h3><p>位置<code>themes/next/layout/_macro/post.swig</code>，代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> post.tags and post.tags.length and not is_index %&#125;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"post-tags"</span>&gt;</span><br><span class="line">    &#123;% <span class="keyword">for</span> tag <span class="keyword">in</span> post.tags %&#125;</span><br><span class="line">      &lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" rel="tag"&gt;#&#123;&#123;tag.name &#125;&#125;&lt;/a&gt;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">    &lt;a href="https://github.com/wolfbrother/wolfbrother.github.io/blob/hexo/source/&#123;&#123;post.source&#125;&#125;" rel="tag" target="_blank"&gt;&amp;#64gitrepo&lt;/a&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&#123;% endif %&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&#123;% if not post.tags or not post.tags.length or is_index %&#125;</span></span><br><span class="line"><span class="regexp">  &lt;div class="post-tags"&gt; </span></span><br><span class="line"><span class="regexp">     &lt;a href="https:/</span><span class="regexp">/github.com/</span>wolfbrother/wolfbrother.github.io/blob/hexo/source/&#123;&#123;post.source&#125;&#125;<span class="string">" rel="</span>tag<span class="string">" target="</span>_blank<span class="string">"&gt;&amp;#64gitrepo&lt;/a&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">&#123;% endif %&#125;</span></span><br></pre></td></tr></table></figure><h3 id="在hexo-generator-index2的基础上添加文章置顶和解除主页过滤">在hexo-generator-index2的基础上添加文章置顶和解除主页过滤</h3><p>hexo-generator-index2自带过滤功能，能够按tag或category类别将文章从主页过滤，然而却不支持置顶和解除类别内特定文章的选项。</p><p>一方面，在文件<code>hexo-generator-index2/lib/generator2.js</code>的行<code>var posts = locals.posts.sort(generator.order_by);</code>下面添加如下代码来支持文章的top这个属性，也就是在已经按<code>generator.order_by</code>的文章的基础上，再按top属性排序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">posts.data = posts.data.sort(<span class="function"><span class="keyword">function</span>(<span class="params">first, second</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (first.top &amp;&amp; second.top) &#123; <span class="comment">// 两篇文章top都有定义</span></span><br><span class="line"><span class="keyword">if</span> (first.top != second.top) &#123;</span><br><span class="line"><span class="keyword">return</span> second.top - first.top;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> ((!first.dtindex)||(!second.dtindex)) &#123;</span><br><span class="line"><span class="keyword">return</span> second.date - first.date;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (second.dtindex &gt; first.dtindex) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (first.top &amp;&amp; !second.top) &#123; <span class="comment">// 以下是只有一篇文章top有定义，将有top的排在前面</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!first.top &amp;&amp; second.top) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> ((!first.dtindex)||(!second.dtindex)) &#123;</span><br><span class="line"><span class="keyword">return</span> second.date - first.date;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (second.dtindex &gt; first.dtindex) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>接下来，是按tag或category类别判断每篇文章是否从主页过滤的代码，在里面添加如下代码,即当属性post.not_exclude或者post.top为真时，不把改文章过滤掉：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (post.not_exclude || post.top) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一篇文章在被过滤掉的category里，要将其置顶，其源文件顶格内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">dtindex: 2019-01-01更新中000</span><br><span class="line">date: 2019-01-01</span><br><span class="line">title: 更新中...</span><br><span class="line">categories: 工具箱</span><br><span class="line">tags:  </span><br><span class="line">author: wolfbrother  </span><br><span class="line">top: true</span><br><span class="line">not_exclude: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h3 id="cloudflare-error-526-无效的ssl证书解決方法">CloudFlare Error 526 无效的SSL证书解決方法</h3><p>一段时间之后，网页打不开，显示上述问题CloudFlare Error 526 无效的SSL证书解決方法。</p><p>解决办法：登录CloudFlare，将SSL/TLS的加密模式选择为Flexible。 <img src="/images/20200320-SSL-TLS加密方案.png" alt="SSL-TLS加密方案"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="工具箱" scheme="https://wolfbrother.github.io/categories/%E5%B7%A5%E5%85%B7%E7%AE%B1/"/>
    
    
      <category term="hexo" scheme="https://wolfbrother.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>剑指42-和为S的两个数字</title>
    <link href="https://wolfbrother.github.io/2019/09/13/algs/arrow4Offer/2019-09-13-42-%E5%92%8C%E4%B8%BAS%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/"/>
    <id>https://wolfbrother.github.io/2019/09/13/algs/arrow4Offer/2019-09-13-42-和为S的两个数字/</id>
    <published>2019-09-12T16:00:00.000Z</published>
    <updated>2020-03-20T06:11:23.287Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p><p>输出描述:</p><blockquote><p>对应每个测试案例，输出两个数，小的先输出。</p></blockquote><hr><ul><li>乘积最小，肯定是两头优先，即较小值从序列最左侧开始找。</li><li>较小值上界是<code>0.5*tsum</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindNumbersWithSum</span><span class="params">(self, array, tsum)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(array) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> array:</span><br><span class="line">            <span class="keyword">if</span> num &gt;= <span class="number">0.5</span>*tsum:</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line">            <span class="keyword">if</span> tsum - num <span class="keyword">in</span> array:</span><br><span class="line">                <span class="keyword">return</span> [num, tsum-num]</span><br></pre></td></tr></table></figure><hr><ul><li>将查看数组是否包含某元素的操作，即'if tsum-num in array'，替换成了二分查找。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindNumbersWithSum</span><span class="params">(self, array, tsum)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(num, array)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(array) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            s, t = <span class="number">0</span>, len(array)<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> s &lt; t:</span><br><span class="line">                mid = (s+t)&gt;&gt;<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> array[mid] == num:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">elif</span> array[mid] &gt; num:</span><br><span class="line">                    t = mid</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    s = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> array[s] == num</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">if</span> len(array) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">for</span> ix, num <span class="keyword">in</span> enumerate(array):</span><br><span class="line">            <span class="keyword">if</span> num &gt;= <span class="number">0.5</span>*tsum:</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line">            <span class="keyword">if</span> search(tsum - num, array[ix+<span class="number">1</span>:]):</span><br><span class="line">                <span class="keyword">return</span> [num, tsum-num]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://wolfbrother.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指67-剪绳子</title>
    <link href="https://wolfbrother.github.io/2019/09/13/algs/arrow4Offer/2019-09-13-67-%E5%89%AA%E7%BB%B3%E5%AD%90/"/>
    <id>https://wolfbrother.github.io/2019/09/13/algs/arrow4Offer/2019-09-13-67-剪绳子/</id>
    <published>2019-09-12T16:00:00.000Z</published>
    <updated>2020-03-20T06:11:23.363Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p><p>给你一根长度为n的绳子，请把绳子剪成m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为<code>k[0],k[1],...,k[m]</code>。请问<code>k[0]*k[1]*...*k[m]</code>可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入描述:</span><br><span class="line">&gt; 输入一个数n，意义见题面。（2 &lt;= n &lt;= 60）</span><br><span class="line">输出描述:</span><br><span class="line">&gt; 输出答案。</span><br><span class="line"></span><br><span class="line">示例1</span><br><span class="line">输入 &gt; 8</span><br><span class="line">输出 &gt; 18</span><br></pre></td></tr></table></figure><hr><p>动态规划，递归。用函数cut(number)剪长度为number的绳子，由于m、n都是正整数，第一次调用cut和其后的调用有区别</p><ul><li>第一次调用必须非要把绳子至少一分为二为两个短绳子，对短绳子再次调用该cut函数，则可能会继续剪也可能不再继续剪。比如2第一次调用，必须要拆分成1和1；然而3的第二次调用也有的这个2，但是可以拆也可以不拆。 所以，cut函数内部要根据其是否是首次调用，分为两种情况处理。</li><li>由于number必然是整数，因此动态规划程序里可以用一个数组来保存子问题的结果。具体的，用长度为<code>number+1</code>的数组<code>cutlog</code>来记录非首次调用cut函数的返回值，cut(number)返回值用<code>cutlog[number]</code>来表示。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cutRope</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        self.cutlog = [<span class="number">0</span>]*(number+<span class="number">1</span>) <span class="comment">#记录非首次cut函数调用的返回值</span></span><br><span class="line">        self.cutlog[<span class="number">0</span>] = self.cutlog[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">cut</span><span class="params">(number, isDoor = False)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> isDoor:</span><br><span class="line">                res = []</span><br><span class="line">                <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">1</span>, number+<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> self.cutlog[number-n] == <span class="number">0</span>:</span><br><span class="line">                        self.cutlog[number-n] = cut(number-n)</span><br><span class="line">                    res.append(n*self.cutlog[number-n])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> number &lt;= <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">                res = []</span><br><span class="line">                <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">1</span>, number):</span><br><span class="line">                    <span class="keyword">if</span> self.cutlog[number-n] == <span class="number">0</span>:</span><br><span class="line">                        self.cutlog[number-n] = cut(number-n)</span><br><span class="line">                    res.append(n*self.cutlog[number-n])</span><br><span class="line">            <span class="keyword">return</span> max(res)</span><br><span class="line">        <span class="keyword">return</span> cut(number, isDoor=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://wolfbrother.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="动态规划" scheme="https://wolfbrother.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>剑指59-按之字形顺序打印二叉树</title>
    <link href="https://wolfbrother.github.io/2019/09/13/algs/arrow4Offer/2019-09-13-59-%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://wolfbrother.github.io/2019/09/13/algs/arrow4Offer/2019-09-13-59-按之字形顺序打印二叉树/</id>
    <published>2019-09-12T16:00:00.000Z</published>
    <updated>2020-03-20T06:11:23.340Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述</p><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p><ul><li>用队列nodeQ来临时存储节点，进而访问其子节点。</li><li>队列里两层之间有个要有个标记<code>|</code>，层的奇偶性也要有一个标记issOdd。<ul><li>访问到该标记时，在队列末尾添加该标记。</li></ul></li><li>要有个缓存nodeLayer来存放同一层访问到的节点值，该层结束时根据奇偶标记来选择输出顺序。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">levelrootSnake</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="comment"># 用队列存储节点，每层末尾做一个标志，这里以符号'n'来表示。</span></span><br><span class="line">    <span class="comment"># 访问末尾节点之后，必然产生新的末尾标志。</span></span><br><span class="line">    isOdd = <span class="literal">True</span></span><br><span class="line">    myqueue = [root, <span class="string">'n'</span>]</span><br><span class="line">    mylist, nodes_layer = [], []</span><br><span class="line">    <span class="keyword">while</span> len(myqueue) != <span class="number">0</span>:</span><br><span class="line">        node = myqueue.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> node != <span class="string">'n'</span>:</span><br><span class="line">            nodes_layer.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                myqueue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                myqueue.append(node.right)</span><br><span class="line">        <span class="keyword">if</span> len(myqueue) != <span class="number">0</span> <span class="keyword">and</span> myqueue[<span class="number">0</span>] == <span class="string">'n'</span>:</span><br><span class="line">            <span class="keyword">if</span> isOdd == <span class="literal">True</span>:</span><br><span class="line">                mylist.append(nodes_layer[::])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                mylist.append(nodes_layer[::<span class="number">-1</span>])</span><br><span class="line">            isOdd = <span class="keyword">not</span> isOdd</span><br><span class="line">            nodes_layer = []</span><br><span class="line">            myqueue.pop(<span class="number">0</span>)</span><br><span class="line">            myqueue.append(<span class="string">'n'</span>)</span><br><span class="line">    <span class="keyword">return</span> mylist</span><br></pre></td></tr></table></figure><hr><p>相对于前一个代码用一个数据结构来存储各层的节点，需要两个辅助数据：</p><ul><li>对层数是奇、偶，做标记。</li><li>两层的分割点，要做标记</li></ul><p>想到用两个数据结构来分别存储奇数、偶数层的节点，每个循环内依次对两个数据结构进行处理，不必追踪层数和层间隔。</p><ul><li>注意这两个数据结构可以用队列，也可以用栈，其实区别不大。比如前面的代码用数组，后面的代码用栈。</li><li>如下代码用的是栈，注意第一个栈先压入左节点，第二个栈先压入右节点。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回二维列表[[1,2],[4,5]]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        st1, st2 = [root], []</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> len(st1) &gt; <span class="number">0</span>:</span><br><span class="line">            temp = []</span><br><span class="line">            <span class="keyword">while</span> len(st1) &gt; <span class="number">0</span>:</span><br><span class="line">                node = st1.pop(<span class="number">-1</span>)</span><br><span class="line">                temp.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    st2.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    st2.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> len(temp) &gt; <span class="number">0</span>:</span><br><span class="line">                res.append(temp[::])</span><br><span class="line">            temp = []</span><br><span class="line">            <span class="keyword">while</span> len(st2) &gt; <span class="number">0</span>:</span><br><span class="line">                node = st2.pop(<span class="number">-1</span>)</span><br><span class="line">                temp.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    st1.append(node.right)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    st1.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> len(temp) &gt; <span class="number">0</span>:</span><br><span class="line">                res.append(temp[::])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://wolfbrother.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
</feed>
